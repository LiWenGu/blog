<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello</title>
  <subtitle>严律己，宽待人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-07T16:48:21.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TheOthers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三章：深入分析Java Web中的中文编码问题</title>
    <link href="http://yoursite.com/2017/08/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/08/07/读书笔记/深入分析Java_Web技术/第三章：深入分析Java Web中的中文编码问题/</id>
    <published>2017-08-07T14:56:30.000Z</published>
    <updated>2017-08-07T16:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-几种常见的编码格式"><a href="#1-几种常见的编码格式" class="headerlink" title="1. 几种常见的编码格式"></a>1. 几种常见的编码格式</h1><h2 id="1-为什么需要编码？"><a href="#1-为什么需要编码？" class="headerlink" title="1. 为什么需要编码？"></a>1. 为什么需要编码？</h2><ul>
<li>计算机中存储信息的最小单位是1个字节，即8个bit，所以能表示的字符范围是2^8=256个。</li>
<li>人类符号过于复杂，至少一个几个字节才能满足人类的一个单位。</li>
</ul>
<h2 id="2-常见编码"><a href="#2-常见编码" class="headerlink" title="2. 常见编码"></a>2. 常见编码</h2><p>编码即就是人类的字符-&gt;机器的字符的过程。</p>
<h3 id="1-ASCII码"><a href="#1-ASCII码" class="headerlink" title="1. ASCII码"></a>1. ASCII码</h3><p>总共有128个，用1个字节的低七位表示，0~31是控制字符，如换行、回车、删除，32~126是打印字符，可以通过键盘输入并且能够显示出来。</p>
<h3 id="2-ISO-8859-1"><a href="#2-ISO-8859-1" class="headerlink" title="2. ISO-8859-1"></a>2. ISO-8859-1</h3><p>128个字符显示是不够的，于是ISO组织在ASCII码基础上又制定了一系列标准来扩展ASCII编码，他们是ISO-8859-1至ISO-8859-15。ISO-8859-1仍然<br>是单字节编码，它总共能表示256个字符。</p>
<h3 id="3-GB2312"><a href="#3-GB2312" class="headerlink" title="3. GB2312"></a>3. GB2312</h3><p>GB2312全称是《信息技术·中文编码字符集》，总的编码范围是：A1~F7。它是双字节编码。包含了符号以及汉字。</p>
<h3 id="4-GBK"><a href="#4-GBK" class="headerlink" title="4. GBK"></a>4. GBK</h3><p>GBK全称是《汉字内码扩展规范》，是国家技术监督局为Windows95所制定新的汉字内码规范，它的出现是为了扩展GB2312，并加入更多的汉字。<br>编码范围是8140~FEFE，总共23940，表示21003个汉字，编码是和GB2312兼容，也就是GB2312编码的汉字可以用GBK解码，不会乱码。</p>
<h3 id="5-GB18030"><a href="#5-GB18030" class="headerlink" title="5. GB18030"></a>5. GB18030</h3><p>应用不广泛，与GB2312兼容</p>
<h3 id="6-UTF-16"><a href="#6-UTF-16" class="headerlink" title="6. UTF-16"></a>6. UTF-16</h3><p>Unicode（Universal Code统一码），ISO试图创建一个全新的超语言字典，世界上所有的语言都可以通过这个字典来相互翻译。可想而知这个字典是多么<br>复杂。Unicode是Java和XML的基础。<br>UTF-16具体定义了Unicode字符在计算机中的存取方法，UTF-16用两个字节来表示Unicode的转化格式，它采用定长的表示方法，即不论什么字符都可以用<br>两个字节表示。<br>两个字节是16个bit，所以叫UTF-16。UTF-16表示字符非常方便，每两个字节表示一个字符，简化了字符串操作，这也是Java以UTF-16作为内存的字符存储<br>格式的一个重要的原因。</p>
<h3 id="7-UTF-8"><a href="#7-UTF-8" class="headerlink" title="7. UTF-8"></a>7. UTF-8</h3><p>UTF-16统一采用两个字节表示一个字符，虽然表示上简单方便，但是也有其缺点，很大一部分字符用一个字节就可以表示的现在要用两个字节表示，存储空间<br>放大了一倍。而UTF-8采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1~6个字节组成。</p>
<ul>
<li>如果是一个字节。最高为为0，则表示这是一个ASCII字符，可见，所有ASCII编码已经是UTF-8了。</li>
<li>如果是一个字节，以11开头，则连续的1的个数暗示这个字符的字节数。例如：110xxxxx代表它是双字节UTF-8字符的首字节。</li>
<li>如果是一个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。</li>
</ul>
<h2 id="2-编码的场景"><a href="#2-编码的场景" class="headerlink" title="2. 编码的场景"></a>2. 编码的场景</h2><h3 id="1-I-O操作"><a href="#1-I-O操作" class="headerlink" title="1. I/O操作"></a>1. I/O操作</h3><p>Reader类和InputStream之间的InputStreamReader，通过StreamDecoder以及StreamEncoder进行字符和字节的转换，在解码过程必须指定编码格式，<br>否则按系统编码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">String file = <span class="string">"D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt"</span>;</div><div class="line">String charset = <span class="string">"UTF-8"</span>;</div><div class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fileOutputStream);</div><div class="line">writer.write(<span class="string">"这是要保存的中文字符"</span>);</div><div class="line">writer.close();</div><div class="line"></div><div class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fileInputStream, charset);</div><div class="line"></div><div class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="keyword">while</span>((count = reader.read(buf)) != -<span class="number">1</span>) &#123;</div><div class="line">    buffer.append(buf, <span class="number">0</span>, count);</div><div class="line">&#125;</div><div class="line">System.out.print(buffer.toString());</div><div class="line">reader.close();</div></pre></td></tr></table></figure></p>
<h3 id="2-在内存操作中的编码"><a href="#2-在内存操作中的编码" class="headerlink" title="2. 在内存操作中的编码"></a>2. 在内存操作中的编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种，通过字符串操作</span></div><div class="line">String s = <span class="string">"中文"</span>;</div><div class="line"><span class="keyword">byte</span>[] b = s.getBytes(<span class="string">"UTF-8"</span>);</div><div class="line">String n = <span class="keyword">new</span> String(b, <span class="string">"UTF-8"</span>);</div><div class="line">System.out.print(n);</div><div class="line"></div><div class="line"><span class="comment">// 第二种，通过nio中的Charset与Buffer实现编码解码。</span></div><div class="line">Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">ByteBuffer buffer = charset.encode(s);       <span class="comment">//字符转字节</span></div><div class="line">CharBuffer buffer1 = charset.decode(buffer); <span class="comment">//字节转字符</span></div><div class="line"><span class="keyword">char</span>[] a = buffer1.array();</div><div class="line">System.out.print(a);</div><div class="line"></div><div class="line"><span class="comment">// 第三种，通过将16bit的char拆分为2个8bit的byte，没有编码解码，只是软转化</span></div><div class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">ByteBuffer byteBuffer1 = byteBuffer.putChar(<span class="string">'a'</span>);</div></pre></td></tr></table></figure>
<h1 id="3-在Java中如何编解码"><a href="#3-在Java中如何编解码" class="headerlink" title="3. 在Java中如何编解码"></a>3. 在Java中如何编解码</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-几种常见的编码格式&quot;&gt;&lt;a href=&quot;#1-几种常见的编码格式&quot; class=&quot;headerlink&quot; title=&quot;1. 几种常见的编码格式&quot;&gt;&lt;/a&gt;1. 几种常见的编码格式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么需要编码？&quot;&gt;&lt;a href=&quot;#1-为什么
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>二、课外学习NIO</title>
    <link href="http://yoursite.com/2017/08/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%85%B3%E4%BA%8ENIO/"/>
    <id>http://yoursite.com/2017/08/04/读书笔记/深入分析Java_Web技术/第二章课外学习：关于NIO/</id>
    <published>2017-08-04T14:56:30.000Z</published>
    <updated>2017-08-07T13:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跑个Channel实例"><a href="#1-跑个Channel实例" class="headerlink" title="1.跑个Channel实例"></a>1.跑个Channel实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 源目标，春运的100W人</span></div><div class="line">    RandomAccessFile aFile=<span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>);</div><div class="line">    <span class="comment">// 获得源目标的运载交通工具，例如动车，同时动车的站台也站了100W人。</span></div><div class="line">    FileChannel inChannel=aFile.getChannel();</div><div class="line"></div><div class="line">    <span class="comment">// 分配buffer，这次春运，这辆D8888，每次跑两个字节单位的座位</span></div><div class="line">    ByteBuffer buf=ByteBuffer.allocate(<span class="number">2</span>);</div><div class="line">    <span class="comment">// 把动车的站台人和座位连接在一起，得到一个返回值，即该动车和两个字节单位座位的车票信息。</span></div><div class="line">    <span class="keyword">int</span> bytesRead=inChannel.read(buf);</div><div class="line">    <span class="comment">// 车票如果是-1说明车票没了，载完了，动车就去保养了。</span></div><div class="line">    <span class="keyword">while</span>(bytesRead!=-<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 座位的保险带绑上，人不能下座位或者上座位了，只能被车站人员检查</span></div><div class="line">        buf.flip();</div><div class="line">        <span class="comment">// 车站人员检查座位是否有对应的人的信息</span></div><div class="line">        <span class="keyword">while</span>(buf.hasRemaining())</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 打印出以两个字节为单位的座位的人的信息</span></div><div class="line">            System.out.print((<span class="keyword">char</span>)buf.get());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 座位保险带放开，人下车，座位就被清空</span></div><div class="line">        buf.clear();</div><div class="line">        <span class="comment">// 动车继续拉两个字节座位的人，又得到了座位的车票信息</span></div><div class="line">        bytesRead=inChannel.read(buf);</div><div class="line">    &#125;</div><div class="line">    aFile.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的Buffer作为一个顶层抽象类，下面有不止八个子类，对应八种数据类型以及其他一些类型。<br>当Buffer，即座位在调用flip()方法之前，是写模式，即保险带是放开的，想上就上想下就下。<br>切记：Buffer只是在一个改变capacity、position、limit三个值的方法（还有mark，用于临时标记position，通常用于<br>发送某个指定位置之后，返回到发送指定位置之前的position，因为内部提供了方法用于这个需求）。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/5.png?raw=true" alt="Buffer">  </p>
<h2 id="1-写模式"><a href="#1-写模式" class="headerlink" title="1. 写模式"></a>1. 写模式</h2><ul>
<li>capacity：固定的大小。</li>
<li>position：初始值为0，写一单位数据就移动下一个可插入数据的单位，最大为capacity-1。</li>
<li>limit：额外的变量，用于读写分离。此时limit=capacity，写入的最大值。  </li>
</ul>
<h2 id="2-读模式"><a href="#2-读模式" class="headerlink" title="2. 读模式"></a>2. 读模式</h2><ul>
<li>capacity：固定的大小。</li>
<li>position：重置为0，读一单位数据就移动下一个可插入数据的单位。</li>
<li>limit：重置为position，你只能读你写了多少单位的数据。（flip()方法其实，就是将limit重置为position，position重置为0）</li>
</ul>
<h1 id="2-Buffer读写数据以及常用方法"><a href="#2-Buffer读写数据以及常用方法" class="headerlink" title="2. Buffer读写数据以及常用方法"></a>2. Buffer读写数据以及常用方法</h1><p>除了通过Channel写入数据，还可以使用Buffer.put()，写入执行某个位置。<br>也可以通过Buffer.get()，读取某个位置的数据。  </p>
<h2 id="1-Buffer-clear"><a href="#1-Buffer-clear" class="headerlink" title="1. Buffer.clear()"></a>1. Buffer.clear()</h2><p>limit设置为capacity，position重置为0。  </p>
<h2 id="2-Buffer-compact"><a href="#2-Buffer-compact" class="headerlink" title="2. Buffer.compact()"></a>2. <a href="http://zachary-guo.iteye.com/blog/1457542" target="_blank" rel="external">Buffer.compact()</a></h2><p>释放缓存区无用数据。当源目标为Mellow，我们已经读取了Me，现在缓存区还是Mellow，但是Me是无用的，这时候就可以调用该方法。  你可以使用<br>Buffer.put()以及Buffer.get()方法达到这个效果。<br>底层其实是将position-limit数据复制到开始的位置，并重置position = limit - position。<br>WHY？这个position是什么意思？其实原因在于这个方法用于：我读了Me，position为2，此时我想开始写数据，但是我以后会在某个时间点回来继续读，<br>则position就变成4，以后不管你写了多少，都正好不会覆盖未读数据。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/6.png?raw=true" alt="Buffer.compact()"></p>
<h2 id="3-Buffer-rewind"><a href="#3-Buffer-rewind" class="headerlink" title="3. Buffer.rewind()"></a>3. Buffer.rewind()</h2><p>用于position重置为0，即重新开始写，或者读。</p>
<h2 id="4-Buffer-mark-和Buffer-reset"><a href="#4-Buffer-mark-和Buffer-reset" class="headerlink" title="4. Buffer.mark()和Buffer.reset()"></a>4. Buffer.mark()和Buffer.reset()</h2><p>mark默认为-1。<br>mark()：将当前position赋值给mark变量。<br>reset()：将mark赋值给position变量。</p>
<h2 id="5-Buffer-equals-和Buffer-compareTo"><a href="#5-Buffer-equals-和Buffer-compareTo" class="headerlink" title="5. Buffer.equals()和Buffer.compareTo()"></a>5. Buffer.equals()和Buffer.compareTo()</h2><p>相等的条件：类型相同、剩余的单位数量相同、剩余的单位类型相同。<br>比较的条件：第一个不相同的元素的大小，如果都相同，则看数量的多少。</p>
<h1 id="3-scatter与gather"><a href="#3-scatter与gather" class="headerlink" title="3. scatter与gather"></a>3. scatter与gather</h1><h2 id="1-scatter"><a href="#1-scatter" class="headerlink" title="1. scatter"></a>1. scatter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">ByteBuffer[] byteBuffers = &#123;header, body&#125;;</div><div class="line">FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>).getChannel();</div><div class="line">channel.read(byteBuffers);</div></pre></td></tr></table></figure>
<p>不适用与动态消息，第一个Buffer被填充完毕之后才会填充第二个。</p>
<h2 id="2-gather"><a href="#2-gather" class="headerlink" title="2. gather"></a>2. gather</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">ByteBuffer[] buffers = &#123;header, body&#125;;</div><div class="line">FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>).getChannel();</div><div class="line">channel.write(buffers);</div></pre></td></tr></table></figure>
<p>只会有position-limit的数据会被写入。</p>
<h1 id="4-Channel之间进行数据传输"><a href="#4-Channel之间进行数据传输" class="headerlink" title="4. Channel之间进行数据传输"></a>4. Channel之间进行数据传输</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RandomAccessFile sourceFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"SourceData.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel sourceChannel = sourceFile.getChannel();</div><div class="line">RandomAccessFile targetFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"TargetData.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel targetChannel = targetFile.getChannel();</div><div class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</div><div class="line"><span class="keyword">long</span> count = sourceChannel.size();</div><div class="line">targetChannel.transferFrom(sourceChannel, position, count);</div></pre></td></tr></table></figure>
<p>还有一个Channel.transferTo()方法，和上面的方法相反的作用。<br>注意：目标文件如果本来大于源文件，目标文件只会被覆盖源文件要传输的数据，剩余的数据还会存在。<br>如果count传入的时候实际大于size，则被当做count，如果小于size，则会按小于的值覆盖。查看源码即可知。</p>
<h1 id="5-Selector"><a href="#5-Selector" class="headerlink" title="5. Selector"></a>5. Selector</h1><h2 id="1-为什么使用Selector？"><a href="#1-为什么使用Selector？" class="headerlink" title="1. 为什么使用Selector？"></a>1. 为什么使用Selector？</h2><p>Selector是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。<br>这样一个单独的线程可以管理多个Channel，从而管理多个网络连接。<br>可以使用一个线程处理所有的通道，而对于操作系统来说，线程之间上下文切换的开销很大，Selector则是<br>可以处理多个Channel。</p>
<h2 id="2-Selector使用"><a href="#2-Selector使用" class="headerlink" title="2. Selector使用"></a>2. Selector使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建Seletor</span></div><div class="line">Selector selector = Selector.open();</div><div class="line"><span class="comment">// channel注册到selector</span></div><div class="line"><span class="comment">// 继承自AbstractSelectableChannel的方法</span></div><div class="line">ServerSocketChannel channel = ServerSocketChannel.open();</div><div class="line">channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</div></pre></td></tr></table></figure>
<p>与Selector一起使用时，Channel必须处于费阻塞模式下，而FileChannel只能是阻塞模式，套接字可以切换。<br>监听的第二个参数是不同类型的事件：</p>
<ul>
<li>Connect：SelectionKey.OP_CONNECT</li>
<li>Accept：SelectionKey.OP_ACCEPT</li>
<li>Read：SelectionKey.OP_READ</li>
<li>Write：SelectionKey.OP_WRITE<br>监听多个事件：<code>第二个参数输入：SelectionKey.OP_CONNECT | SelectionKey.OP_CONNECT</code></li>
</ul>
<h2 id="3-SelectionKey"><a href="#3-SelectionKey" class="headerlink" title="3. SelectionKey"></a>3. SelectionKey</h2><h3 id="1-interset属性"><a href="#1-interset属性" class="headerlink" title="1. interset属性"></a>1. interset属性</h3><p>其中包含了一些你感兴趣的属性，即注册的事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</div><div class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;</div><div class="line"><span class="keyword">boolean</span> isInterestedInConnect = (interestSet &amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;</div><div class="line"><span class="keyword">boolean</span> isInterestedInRead    = (interestSet &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;</div><div class="line"><span class="keyword">boolean</span> isInterestedInWrite   = (interestSet &amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE;</div></pre></td></tr></table></figure></p>
<h3 id="2-ready属性"><a href="#2-ready属性" class="headerlink" title="2. ready属性"></a>2. ready属性</h3><p>ready集合是通道已经准备九局的操作的集合，你可以通过<code>int readySet = selectionKey.readyOps()</code>进行分别的访问，<br>也可以使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">selectionKey.isAcceptable();</div><div class="line">selectionKey.isConnectable();</div><div class="line">selectionKey.isReadable();</div><div class="line">selectionKey.isWritable();</div></pre></td></tr></table></figure></p>
<h3 id="3-Selector获得Channel"><a href="#3-Selector获得Channel" class="headerlink" title="3. Selector获得Channel"></a>3. Selector获得Channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Channel  channel  = selectionKey.channel();</div><div class="line">Selector selector = selectionKey.selector();</div></pre></td></tr></table></figure>
<h3 id="4-附加的对象（可选）"><a href="#4-附加的对象（可选）" class="headerlink" title="4. 附加的对象（可选）"></a>4. 附加的对象（可选）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">selectionKey.attach(theObject);</div><div class="line">Object attachedObj = selectionKey.attachment();</div></pre></td></tr></table></figure>
<h3 id="5-通过Selector选择通道"><a href="#5-通过Selector选择通道" class="headerlink" title="5. 通过Selector选择通道"></a>5. 通过Selector选择通道</h3><ul>
<li>int select()<br>该方法会让Selector阻塞，直到至少有一个Channel在你注册的事件上就绪。</li>
<li>int select(long timeout)<br>设置最长阻塞的毫秒数</li>
<li>int selectNow()<br>直接返回，无论什么Channel。  </li>
</ul>
<p>返回值表示从上次select()方法调用之后，又有多少符合要求的Channel，不叠加。</p>
<h3 id="6-wakeUp"><a href="#6-wakeUp" class="headerlink" title="6. wakeUp()"></a>6. wakeUp()</h3><p>某个线程调用select()让某个Selector阻塞后，使用该方法可以立马返回，如果没有阻塞，但是提前调用了wakeUp方法，<br>那么下个调用select方法的线程会立即wake up。</p>
<h3 id="7-遍历SelectorKeys"><a href="#7-遍历SelectorKeys" class="headerlink" title="7. 遍历SelectorKeys"></a>7. 遍历SelectorKeys</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Selector selector = Selector.open();</div><div class="line">Set selectionKeys = selector.selectedKeys();</div><div class="line">Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</div><div class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">    SelectionKey key = iterator.next();</div><div class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    iterator.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要手动将事件给移除。</p>
<h2 id="4-完整的示例"><a href="#4-完整的示例" class="headerlink" title="4. 完整的示例"></a>4. 完整的示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> port = <span class="number">9999</span>; </div><div class="line"></div><div class="line">ServerSocketChannel channel = ServerSocketChannel.open();</div><div class="line">channel.configureBlocking(<span class="keyword">false</span>); </div><div class="line"></div><div class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port)); </div><div class="line">Selector selector = Selector.open(); </div><div class="line">SelectionKey selKey = channel.register(selector, SelectionKey.OP_ACCEPT); </div><div class="line"></div><div class="line"><span class="keyword">int</span> interestSet = selKey.interestOps(); </div><div class="line"></div><div class="line"><span class="keyword">boolean</span> is_accept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;</div><div class="line"></div><div class="line">System.out.print(<span class="string">"isAccept:"</span>+ is_accept);</div></pre></td></tr></table></figure>
<h1 id="6-FileChannel"><a href="#6-FileChannel" class="headerlink" title="6. FileChannel"></a>6. FileChannel</h1><p>文件通道，用于文件的读写，常用，由于FileChannel无法设置非阻塞模式，它总是运行在阻塞模式下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> String str = <span class="string">"112中国"</span>;</div><div class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(</div><div class="line">        <span class="string">"D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel channel = file.getChannel();</div><div class="line">channel.position(channel.position() + file.length());  <span class="comment">//这行代码设置写入文件的最后</span></div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buffer.put(str.getBytes());</div><div class="line">buffer.flip();</div><div class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">    channel.write(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有用于截取通道的方法：truncate()，以字节为单位。还有一个force()方法，用于强行将数据写入磁盘，<br>操作系统一般先将数据写入内存，再从内存写入磁盘，设置为True即可。</p>
<h1 id="7-SocketChannel"><a href="#7-SocketChannel" class="headerlink" title="7. SocketChannel"></a>7. SocketChannel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端连接，最后使用close关闭。</span></div><div class="line">SocketChannel channel = SocketChannel.open();</div><div class="line">channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="number">8989</span>));</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">channel.read(buffer);</div><div class="line"><span class="comment">// 从buffer中写入数据到channel</span></div><div class="line">String data = <span class="string">"what ? "</span>;</div><div class="line">buffer.clear();</div><div class="line">buffer.put(data.getBytes());</div><div class="line">buffer.flip();</div><div class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">    channel.write(buffer);</div><div class="line">&#125;</div><div class="line">channel.close();</div></pre></td></tr></table></figure>
<h1 id="8-ServerSocketChannel"><a href="#8-ServerSocketChannel" class="headerlink" title="8. ServerSocketChannel"></a>8. ServerSocketChannel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 服务端开启监听：</span></div><div class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8777</span>));</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">    SocketChannel channel = serverSocketChannel.accept();</div><div class="line">    <span class="comment">// 如果设置为非阻塞，则上面的代码会立马返回，需要判空，是否有连接。</span></div><div class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>)&#123;</div><div class="line">        String ip = serverSocketChannel.socket().getInetAddress().getHostAddress();</div><div class="line">        System.out.println(ip);</div><div class="line">        <span class="comment">// 此时你得到了channel，就可以使用Buffer对数据进行读取操作了。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="9-DatagramChannel"><a href="#9-DatagramChannel" class="headerlink" title="9. DatagramChannel"></a>9. DatagramChannel</h1><p>用于UDP数据的发送和接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 服务端</span></div><div class="line">DatagramChannel channel = DatagramChannel.open();</div><div class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">channel.receive(buffer); <span class="comment">//将得到的UDP数据写入buffer中</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端</span></div><div class="line">DatagramChannel channel = DatagramChannel.open();</div><div class="line">String data = <span class="string">"中国"</span>;</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buffer.put(data.getBytes());</div><div class="line">buffer.flip();</div><div class="line">channel.send(buffer, <span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</div><div class="line">channel.close();</div></pre></td></tr></table></figure>
<h1 id="10-Pipe"><a href="#10-Pipe" class="headerlink" title="10. Pipe"></a>10. Pipe</h1><p>作为两个线程之间的单向数据连接连接（Channel本身是双向，但是通过两个双向的管道一起组合实现成一个单向的，即Sink-&gt;Source）。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/7.png?raw=true" alt="Pipe"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向管道写数据</span></div><div class="line">Pipe pipe = Pipe.open();</div><div class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buffer.put(<span class="string">"中国人"</span>.getBytes());</div><div class="line">buffer.flip();</div><div class="line"><span class="keyword">while</span> (buffer.hasRemaining())&#123;</div><div class="line">    sinkChannel.write(buffer);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 从管道读数据</span></div><div class="line">Pipe.SourceChannel sourceChannel = pipe.source();</div><div class="line">buffer.clear();</div><div class="line">sourceChannel.read(buffer);</div></pre></td></tr></table></figure></p>
<h1 id="11-NIO和IO"><a href="#11-NIO和IO" class="headerlink" title="11. NIO和IO"></a>11. NIO和IO</h1><h2 id="1-面向流和面向缓冲"><a href="#1-面向流和面向缓冲" class="headerlink" title="1. 面向流和面向缓冲"></a>1. 面向流和面向缓冲</h2><p>IO面向流，每次从流中读取一个或多个字节，直至读取所有的字节，没有被缓存再任何地方，另外，也不能移动流中的数据，<br>如果想移动，需要手动将流中的数据缓存在一个第三方缓冲区变量中。而NIO则本身就将数据放入到缓冲区中，可以在缓冲区<br>中前后移动，只是加多了对缓冲区的判断以及更多数据进入缓冲区时，不能覆盖原来的数据。</p>
<h2 id="2-阻塞和非阻塞"><a href="#2-阻塞和非阻塞" class="headerlink" title="2. 阻塞和非阻塞"></a>2. 阻塞和非阻塞</h2><p>本质区别，IO在读写直接阻塞。而NIO的读写的操作会直接返回值，进入下一步操作不会阻塞，并通过Selector来实现一个线程<br>对多个Channel，即多个读写进行管理。</p>
<h2 id="3-数据的处理"><a href="#3-数据的处理" class="headerlink" title="3. 数据的处理"></a>3. 数据的处理</h2><ul>
<li><p>IO的设计逐字节读取数据。例如你正在处理基于行的文本数据流：<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/8.png?raw=true" alt="">  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**data.txt</span></div><div class="line"><span class="comment"> * Name: xxx</span></div><div class="line"><span class="comment"> * Age: 18</span></div><div class="line"><span class="comment"> * Email: xxx@gmail.com</span></div><div class="line"><span class="comment"> * Phone: 135xxxxx</span></div><div class="line"><span class="comment"> */</span></div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>)));</div><div class="line">String nameLine   = reader.readLine();</div><div class="line">String ageLine    = reader.readLine();</div><div class="line">String emailLine  = reader.readLine();</div><div class="line">String phoneLine  = reader.readLine();</div></pre></td></tr></table></figure>
</li>
<li><p>NIO直接读写：<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/9.png?raw=true" alt="">  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>).getChannel();</div><div class="line"><span class="keyword">int</span> bytesRead = channel.read(buffer);</div><div class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</div><div class="line">    channel.read(buffer);</div><div class="line"></div><div class="line">&#125;</div><div class="line">channel.close();</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul>
<li>NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。<br>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，<br>如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/10.png?raw=true" alt=""></li>
<li>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/11.png?raw=true" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-跑个Channel实例&quot;&gt;&lt;a href=&quot;#1-跑个Channel实例&quot; class=&quot;headerlink&quot; title=&quot;1.跑个Channel实例&quot;&gt;&lt;/a&gt;1.跑个Channel实例&lt;/h1&gt;&lt;figure class=&quot;highlight java
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>二、深入分析Java IO的工作机制</title>
    <link href="http://yoursite.com/2017/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20IO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/08/03/读书笔记/深入分析Java_Web技术/第二章：深入分析Java IO的工作机制/</id>
    <published>2017-08-03T04:08:20.000Z</published>
    <updated>2017-08-07T14:15:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JAVA的I-O类库的基本架构"><a href="#1-JAVA的I-O类库的基本架构" class="headerlink" title="1. JAVA的I/O类库的基本架构"></a>1. JAVA的I/O类库的基本架构</h1><ul>
<li>基于字节操作的I/O接口：InputStream和OutputStream。</li>
<li>基于字符操作的I/O操作：Writer和Reader。</li>
<li>基于磁盘操作的I/O操作：File。</li>
<li>基于网络操作的I/O操作：Socket。</li>
</ul>
<h1 id="2-字节字符的转换"><a href="#2-字节字符的转换" class="headerlink" title="2. 字节字符的转换"></a>2. 字节字符的转换</h1><p>低级的字节转字符，有InputStreamReader，以及OutputStreamWriter。<br>而字符转字节一般直接用new String(byte[])。<br>注意：字符字节的转换在开发中一定要显示指明编码。<br>在OutputStreamWriter的官方注释中，错误的理解为从字符到字节，其实应该理解成字符与字节之间的桥梁。</p>
<h1 id="3-访问文件的几种方式"><a href="#3-访问文件的几种方式" class="headerlink" title="3. 访问文件的几种方式"></a>3. 访问文件的几种方式</h1><p>前言：读取和写入都是调用操作系统的提供的接口，而操作系统调用就会存在内核空间地址和用户空间地址切换的问题，一般的IO都是数据从<br>磁盘复制到内核空间，然后再从内核空间复制到用户空间，操作系统为了加速IO访问，在内核空间使用了缓存，即如果是第二次访问同一段<br>的磁盘地址，直接从内核缓存中取出。  </p>
<h2 id="1-标准访问文件的方式"><a href="#1-标准访问文件的方式" class="headerlink" title="1. 标准访问文件的方式"></a>1. 标准访问文件的方式</h2><p>读取：调用操作系统的Read接口，操作系统先检查内核的高速缓存，如果有缓存则直接返回，如果没有则从磁盘中读取，缓存，返回。<br>写入：调用操作系统的Writer接口，写入到高速缓存中，则通知应用程序完成，什么时候写入磁盘由操作系统决定。当然你可以使用sync强制刷新。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-1.png?raw=true" alt="">  </p>
<h2 id="2-直接I-O的方式"><a href="#2-直接I-O的方式" class="headerlink" title="2. 直接I/O的方式"></a>2. 直接I/O的方式</h2><p>即应用程序直接访问磁盘数据，减少一次从内核缓冲区到用户空间的数据复制，例如数据库管理系统，数据库明确的知道哪些数据需要缓存<br>哪些不需要，以及哪些数据需要先放到内存中预热，但是不好的地方在于，你接管了数据缓存，如果你没有命中，则每次都是IO磁盘，比较<br>耗时，通常结合直接IO与异步IO。</p>
<h2 id="3-同步访问文件的方式"><a href="#3-同步访问文件的方式" class="headerlink" title="3. 同步访问文件的方式"></a>3. 同步访问文件的方式</h2><p>与标准访问文件不同点在于，写入了磁盘，操作系统才会应用程序返回成功的标志，用于安全性高的场景。  </p>
<h2 id="4-异步访问文件的方式"><a href="#4-异步访问文件的方式" class="headerlink" title="4. 异步访问文件的方式"></a>4. 异步访问文件的方式</h2><p>访问文件的请求线程发出后，不会阻塞等待，继续做别的事，完成文件访问后回调某个方法，提高应用程序的效率而不是访问文件的效率。  </p>
<h2 id="5-内存映射的方式"><a href="#5-内存映射的方式" class="headerlink" title="5. 内存映射的方式"></a>5. 内存映射的方式</h2><p>操作系统将内存中的某一块区域与磁盘中的文件关联，理解为快捷方式。这样中间加了一层地址映射，空间换时间，在实际开发中，多台业务<br>服务器对一个统一的路径下进行共享，方便数据的存储。例如A服务器下的data和B服务器下的data进行共享，便于文件的统一上传下载路径管理。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-2.png?raw=true" alt=""></p>
<h1 id="4-访问磁盘文件"><a href="#4-访问磁盘文件" class="headerlink" title="4. 访问磁盘文件"></a>4. 访问磁盘文件</h1><p>前面介绍了操作数据，接着这里介绍数据写向何处，例如持久化到物理磁盘。<br>FileInputStream对象是操作一个文件的接口，创建的同时会创建该文件的描述对象FileDescriptor。操作文件对象的时候可以通过getFD()<br>方法获取真正与底层操作系统相关联的文件描述。例如调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。<br>byte-&gt;char是解码过程，因此读取文件都是需要StreamDecoder类帮助。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-3.png?raw=true" alt=""></p>
<h2 id="1-Java序列化技术"><a href="#1-Java序列化技术" class="headerlink" title="1. Java序列化技术"></a>1. Java序列化技术</h2><p>将对象转化成一串二进制表示的字符数组，反序列化时需要原始类作为模板，原因在于序列化之后的文件不保存类的完整结构信息。建议保存为<br>通用的json/xml格式，比较耗的序列化工具：protobuf。序列化以及反序列需要注意一些常见的问题，例如serialVersionUID被修改，序列化<br>对象中有属性为对象但是该属性对象没有实现Serializable等。</p>
<h1 id="5-网络I-O工作机制"><a href="#5-网络I-O工作机制" class="headerlink" title="5. 网络I/O工作机制"></a>5. 网络I/O工作机制</h1><h2 id="1-TCP状态"><a href="#1-TCP状态" class="headerlink" title="1. TCP状态"></a>1. TCP状态</h2><p><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-4.png?raw=true" alt="">  </p>
<ol>
<li>三次握手<br>客户端CLOSED、SYN-SEND、ESTABLISHED。<br>服务端LISTEN、SYN-RCVD、ESTABLISHED。  </li>
<li>四次挥手<br>客户端ESTABLISHED、FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT。<br>服务端ESTABLISHED、CLOSE_WAIT、LAST_ACK、CLOSE。</li>
</ol>
<h2 id="2-影响网络传输的因素"><a href="#2-影响网络传输的因素" class="headerlink" title="2. 影响网络传输的因素"></a>2. 影响网络传输的因素</h2><ul>
<li>网络带宽：物理链路在1s内传输的最大比特值，一般都是1.7Mb/s。</li>
<li>传输距离。</li>
<li>TCP拥塞控制：TCP传输是一个“停等停等”的过程，要步调一致则需要通过拥塞控制来调节。TCP在传输时会设定一个“窗口”，窗口大小由带宽和数据<br>在两端的来回时间，即响应时间决定的。</li>
</ul>
<h2 id="3-Java-Socket的工作机制"><a href="#3-Java-Socket的工作机制" class="headerlink" title="3. Java Socket的工作机制"></a>3. Java Socket的工作机制</h2><p>![][1-5)]<br>客户端开始建立一个Socket实例时，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、远程地址和<br>端口号的套接字数据结构，这个数据结构一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将进行TCP的三次握手协议，<br>三次握手，完成之后，Socket实例创建完成。<br>服务端将创建一个ServerSocket实例，只要指定的端口号没有被占用，一般实例都会创建成功，操作系统底层也会为ServerSocket实例创建一个底层<br>数据结构，这个数据结构中包含指定的端口号和包含监听地址的通配符，通常都是“*”，即监听所有地址。之后调用accept()方法，进入阻塞状态，等待<br>客户端的请求。当一个新的请求到达时，为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址<br>和端口，同时这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，此时服务端的与之对应的Socket实例<br>并没有完成创建，而是要等待与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并从未连接数据结构列表移到已完成列表。所以与ServerSocket<br>所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。</p>
<h2 id="4-数据传输"><a href="#4-数据传输" class="headerlink" title="4. 数据传输"></a>4. 数据传输</h2><p>服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream，通过这两个对象来交换数据，同时操作系统会为<br>这两个对象分配一定大小的缓存区。  </p>
<ul>
<li>写入：数据-&gt;OutputStream对应的SendQ队列，队列填满时，数据将会转移到另一端的InputStream的RecvQ队列中，如果RecvQ已经满了，那么<br>OuptStream的write方法将会阻塞，直到RecvQ队列可以容纳SendQ队列的数据。因此网络IO还需要一个协调的过程，如果两边同时传输数据则会产生死锁。</li>
</ul>
<h1 id="6-NIO的工作方式-建议先阅读课外学习：关于NIO"><a href="#6-NIO的工作方式-建议先阅读课外学习：关于NIO" class="headerlink" title="6. NIO的工作方式(建议先阅读课外学习：关于NIO)"></a>6. NIO的工作方式(建议先阅读<a href="http://www.liwenguang.website/2017/08/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%85%B3%E4%BA%8ENIO/" target="_blank" rel="external">课外学习：关于NIO</a>)</h1><h2 id="1-BIO的缺点"><a href="#1-BIO的缺点" class="headerlink" title="1. BIO的缺点"></a>1. BIO的缺点</h2><p>阻塞IO，即BIO，在读取和写入时（InputStream、OutputStream）都有可能堵塞，一旦有堵塞，线程将会失去CPU的使用权，一些方法，例如：一个客户端<br>一个处理线程、线程池用来减少线程创建和回收的成本。但是，当需要大量的HTTP长连接，例如Web旺旺，虽然并不是每个连接都一直在传输数据，但是如果要<br>对某个客户端（VIP）提供更高的服务优先，很难通过线程本省的优先级完成，同时访问一些竞争资源时，也会有问题，因此需要同步。因此NIO应运而生。</p>
<h2 id="2-NIO的工作机制"><a href="#2-NIO的工作机制" class="headerlink" title="2. NIO的工作机制"></a>2. NIO的工作机制</h2><p>通过等待读以及等待写的轮询，在真正进行IO的时候才是使用CPU阻塞，但是由于是memory copy，<a href="https://zhuanlan.zhihu.com/p/23488863" target="_blank" rel="external">在带宽足够大的1GB/s基本可以忽略</a>。</p>
<h2 id="3-Buffer的工作方式"><a href="#3-Buffer的工作方式" class="headerlink" title="3. Buffer的工作方式"></a>3. Buffer的工作方式</h2><p>可以简单理解为操作一组基本数据类型的元素列表：capacity、position、limit、mark。<br>注意，通过Channel获取的IO数据首先经过操作系统的Socket缓冲区，再将数据复制到Buffer中，这个操作系统缓冲区就是底层的TCP所关联的RecvQ或者<br>SendQ队列。<br>Buffer提供了另一种直接操作操作系统缓冲区的方式，即<code>ByteBuffer.allocateDirector()</code>，这个方法直接返回底层存储空间关联的缓冲区，它通过<br>Native代码操作非JVM堆的内存空间，每次创建或者释放都要手动调用一次System.gc()。<br>注意：使用该方法直接操作非JVM堆空间会引起JVM内存泄漏问题。适用于数据量比较大，生命周期比较长的情况下，而普通的allocate()方法<br>适用并发连接少于1000。</p>
<h2 id="4-FileChannel的数据访问"><a href="#4-FileChannel的数据访问" class="headerlink" title="4. FileChannel的数据访问"></a>4. FileChannel的数据访问</h2><h3 id="1-FileChannel-transferXXX"><a href="#1-FileChannel-transferXXX" class="headerlink" title="1. FileChannel.transferXXX"></a>1. FileChannel.transferXXX</h3><p>传统的数据访问方式：<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-6.png?raw=true" alt=""><br>FileChannel.transferXXX方式：<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-7.png?raw=true" alt=""></p>
<h3 id="2-FileChannel-map"><a href="#2-FileChannel-map" class="headerlink" title="2. FileChannel.map"></a>2. FileChannel.map</h3><p>将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，省去了数据从内核空间向用户空间复制的损耗。<br>适用于对大文件的只读性操作，如大文件的MD5校验。</p>
<h1 id="7-IO调优"><a href="#7-IO调优" class="headerlink" title="7. IO调优"></a>7. IO调优</h1><h2 id="1-磁盘I-O优化"><a href="#1-磁盘I-O优化" class="headerlink" title="1. 磁盘I/O优化"></a>1. 磁盘I/O优化</h2><h3 id="1-性能检测"><a href="#1-性能检测" class="headerlink" title="1. 性能检测"></a>1. 性能检测</h3><p>在Linux下的iostat命令，查看I/O wait指标是否正常，即CPU等待I/O指标，如果是4核CPU，那么I、O wait参数不应该超过25%。</p>
<h3 id="2-提升I-O性能"><a href="#2-提升I-O性能" class="headerlink" title="2. 提升I/O性能"></a>2. 提升I/O性能</h3><ul>
<li>增加缓存，减少磁盘访问次数。</li>
<li>优化磁盘的管理系统</li>
<li>设计合理的磁盘存储数据块。</li>
</ul>
<h2 id="2-TCP网络参数调优"><a href="#2-TCP网络参数调优" class="headerlink" title="2. TCP网络参数调优"></a>2. TCP网络参数调优</h2><p>操作系统的端口号：2^16 = 65535个。<br>通过查看<code>cat /proc/sys/net/ipv4/ip_local_port_range</code>查看端口范围<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-8.png?raw=true" alt="port"><br>大量并发，端口号的数量就变成瓶颈，还有TIME_WAIT的数量，如果过多，需要将参数设小，提前释放。</p>
<h2 id="3-网络I-O优化"><a href="#3-网络I-O优化" class="headerlink" title="3. 网络I/O优化"></a>3. 网络I/O优化</h2><ul>
<li>减少网络交互的次数<br>SQL在客户端和数据库端设置缓存，请求css、js等可以合并为一个http链接，每个文件通过逗号隔开，服务端一次请求全部返回。</li>
<li>减少网络传输数据量的大小<br>通常Web服务器将请求的Web页面gzip压缩后再传输给浏览器。以及通过简单的协议，读取协议头来获取有用的价值信息。尽量<br>避免读取整个通信数据，例如<a href="https://baijiahao.baidu.com/s?id=1571237015697755" target="_blank" rel="external">4层代理和7层代理，都是精良避免要读取整个通信数据</a>。<br><img src="https://github.com/LiWenGu/static_resource/blob/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E7%AB%A0/1-9.png?raw=true" alt="TCP"></li>
<li>尽量减少编码<br>尽量以字节形式发送。</li>
</ul>
<h3 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1. 同步与异步"></a>1. 同步与异步</h3><ul>
<li>同步<br>一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列，同生同死。<br>同步能保证程序的可靠性。</li>
<li>异步<br>不需要等待被依赖的任务完成只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行。<br>异步可以提高程序的性能，需要在同步与异步中保持平衡</li>
</ul>
<h3 id="2-阻塞和非阻塞"><a href="#2-阻塞和非阻塞" class="headerlink" title="2. 阻塞和非阻塞"></a>2. 阻塞和非阻塞</h3><p>阻塞和非阻塞主要从CPU的消耗上来说。</p>
<ul>
<li>阻塞<br>CPU停下等待一个慢的操作完成之后，CPU才接着完成其他的工作。</li>
<li>非阻塞<br>这个慢操作执行时，CPU去做其他工作，这个慢操作完成时，CPU收到通知继续完成这个慢操作之后的事。</li>
</ul>
<h3 id="3-两种方式的组合"><a href="#3-两种方式的组合" class="headerlink" title="3. 两种方式的组合"></a>3. 两种方式的组合</h3><ul>
<li>同步阻塞<br>常用，简单，但是IO性能差，CPU大部分处于空闲状态。</li>
<li>同步非阻塞<br>常用于网络IO是长连接同时传输数据不多的情况。提升IO性能的常用手段，会增加CPU消耗，要考虑增加的IO性能能不能补偿CPU的消耗，也就是系统的瓶颈是在IO还是CPU上。</li>
<li>异步阻塞<br>常用于分布式数据库中。例如一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2~3份备份记录会写到<br>其他机器上，这些备份记录通常都采用异步阻塞的方式写IO，异步阻塞对网络IO能够提升效率，尤其像上面这种同时写多份<br>相同数据的情况。</li>
<li>异步非阻塞<br>比较复杂，只有在非常负载的分布式情况下使用，集群之间的消息同步机制一般使用这种IO组合方式。如Cassandra的Gossip通信机制就采用<br>异步非阻塞的方式。<br>适用于同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大但非常频繁的情况。  </li>
</ul>
<p>虽然异步和非阻塞能够提高IO整体性能，但是会增加性能成本，以及程序设计复杂的上升，需要经验丰富的人去设计，如果<br>设计的不合理反而会导致性能下降。<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
<h1 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8. 适配器模式"></a>8. 适配器模式</h1><p>博主做一个Integer转化为String的例子，仿造InputStream转化Reader的简单例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputInteger_</span> <span class="keyword">implements</span> <span class="title">Integer_</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Integer a;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputInteger_</span><span class="params">(Integer a)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Integer_</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_</span> <span class="keyword">implements</span> <span class="title">InputString_</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readString</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputString_</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readString</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputInteger2String</span> <span class="keyword">implements</span> <span class="title">InputString_</span> </span>&#123;</div><div class="line"></div><div class="line">    Integer_ s;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputInteger2String</span><span class="params">(Integer_ s)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.s = s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// StreamDecoder</span></div><div class="line">        Integer r = Integer.valueOf(s.getInteger());</div><div class="line">        System.out.println(r);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        InputInteger2String s = <span class="keyword">new</span> InputInteger2String(<span class="keyword">new</span> InputInteger_(<span class="number">4</span>));</div><div class="line">        s.readString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="9-装饰器模式"><a href="#9-装饰器模式" class="headerlink" title="9. 装饰器模式"></a>9. 装饰器模式</h1><p>赋予被装饰的类更多的功能，就像IO中的BufferedInputStream有缓冲的功能，LineNumberInputStream有提高按行读取数据的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream_</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream_</span> <span class="keyword">extends</span> <span class="title">InputStream_</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream_</span> <span class="keyword">extends</span> <span class="title">InputStream_</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">protected</span> InputStream_ inputStream_;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterInputStream_</span><span class="params">(InputStream_ inputStream_)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.inputStream_ = inputStream_;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">        inputStream_.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferInputStream_</span> <span class="keyword">extends</span> <span class="title">FilterInputStream_</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferInputStream_</span><span class="params">(InputStream_ inputStream_)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(inputStream_);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bufferFirst</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bufferEnd</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">        bufferFirst();</div><div class="line">        <span class="keyword">super</span>.read();</div><div class="line">        bufferEnd();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">        InputStream_ inputStream_ = <span class="keyword">new</span> FileInputStream_();</div><div class="line">        BufferInputStream_ bufferInputStream_ = <span class="keyword">new</span> BufferInputStream_(inputStream_);</div><div class="line">        bufferInputStream_.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="10-适配器模式与装饰器模式区别"><a href="#10-适配器模式与装饰器模式区别" class="headerlink" title="10. 适配器模式与装饰器模式区别"></a>10. 适配器模式与装饰器模式区别</h1><p>它们有个别名，叫包装模式，都起到了包装一个类或对象的作用，但是作用不同。适配器通过改变接口来达到重复使用的目的（如果系统在设计初期，就尽量不要用<br>适配器模式），而装饰器模式保持原有的接口，增强原有对象的功能。</p>
<h1 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h1><p>Java中IO的基本库结构，磁盘IO和网络IO的工作方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JAVA的I-O类库的基本架构&quot;&gt;&lt;a href=&quot;#1-JAVA的I-O类库的基本架构&quot; class=&quot;headerlink&quot; title=&quot;1. JAVA的I/O类库的基本架构&quot;&gt;&lt;/a&gt;1. JAVA的I/O类库的基本架构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基于
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一、深入Web请求过程</title>
    <link href="http://yoursite.com/2017/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5Web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/08/03/读书笔记/深入分析Java_Web技术/第一章：深入Web请求过程/</id>
    <published>2017-08-03T04:08:20.000Z</published>
    <updated>2017-08-04T08:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-DNS域名解析"><a href="#1-DNS域名解析" class="headerlink" title="1. DNS域名解析"></a>1. DNS域名解析</h1><p>使用浏览器输入网址后，浏览器会检查缓存对应的IP地址，如果没有，浏览器会查找操作系统，即host文件。<br>所以很多墙外比较慢的网址，可以手动编写host文件对应的IP地址以及对应的网址，可以加快访问速度。<br>如果实在没有就发送给LDNS，这个LDNS在不同的情况是不一样的，在学校，大部分都是学校的DNS服务器，<br>家庭的一般都是联通或者电信的DNS服务器，最最最后实在解析不出来，就抛给Root Server域名服务器，<br>它会返回给本地域名服务器的主域名服务器的地址，即域名空间提供商的域名解析服务器，就像阿里域名解析加速。</p>
<h1 id="2-清除缓存的域名"><a href="#2-清除缓存的域名" class="headerlink" title="2. 清除缓存的域名"></a>2. 清除缓存的域名</h1><p>主要在两个地方缓存：Local DNS Server, 另一个是用户的本机，当然，重启也是更好的方法。</p>
<blockquote>
<p><code>ipconfig /flushdns</code></p>
</blockquote>
<p>在java中，JVM也会缓存DNS的解析结果，分两种，即正确的解析结果，以及错误的解析结果，<code>InetAddress</code>，实际中<code>InetAddress</code>使用必须是单例模式，因为每次创建<code>InetAddress</code>实例都要进行一次完整的域名解析。</p>
<h1 id="3-CDN工作机制"><a href="#3-CDN工作机制" class="headerlink" title="3. CDN工作机制"></a>3. CDN工作机制</h1><p>CDN也就是内容分布网络(Content Delivery Network)。通过在现有的Internet中增加一层新的网络架构，比镜像更智能。<br>比喻：CDN=镜像Mirror+缓存Cache+整体负载均衡GSLB。<br>目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态页面等，用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据。<br><img src="https://raw.githubusercontent.com/LiWenGu/static_resource/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%80%E7%AB%A0/1.png" alt="Web请求过程"></p>
<h1 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h1><p>负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，提高服务器响应速度，实现地理位置无关性。<br>通常有三种负载均衡架构：链路负载均衡、集群负载均衡、操作系统负载均衡。</p>
<ul>
<li>链路：用户最终访问哪个Web Server是由DNS Server来控制的，优点在于用户直接访问目标服务器，不需要经过其它的代理服务器，通常访问速度更快，缺点在于DNS在用户本地和LDNS都有缓存，一旦某台Web Server挂掉，就难及时更新用户的域名解析结构。</li>
<li>集群：硬件负载以及软件负载均衡，前者需要贵的硬件作为中心，而软件则是成本低，但是需要多次代理服务器转发，从而增加了网络延时。<br><img src="https://raw.githubusercontent.com/LiWenGu/static_resource/master/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%80%E7%AB%A0/2.png" alt="集群负载均衡"></li>
<li>操作系统：如设置多队列网卡。</li>
</ul>
<h1 id="5-CDN动态加速"><a href="#5-CDN动态加速" class="headerlink" title="5. CDN动态加速"></a>5. CDN动态加速</h1><p>原理在于CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，通过DNS的调度将所有请求到选定的路径上回源，一个简单的原则就是在每个CDN节点上从源站下载一个一定大小文件，看哪个链路的总耗时最短，这样可以构成一个链路列表，然后绑定到DNS解析上，更新到CDN的Local DNS。以及网络成本等。</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>主要介绍域名的请求，哪些处理，对CDN以及负载均衡有了解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-DNS域名解析&quot;&gt;&lt;a href=&quot;#1-DNS域名解析&quot; class=&quot;headerlink&quot; title=&quot;1. DNS域名解析&quot;&gt;&lt;/a&gt;1. DNS域名解析&lt;/h1&gt;&lt;p&gt;使用浏览器输入网址后，浏览器会检查缓存对应的IP地址，如果没有，浏览器会查找操作
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-Web%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
