<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello</title>
  <subtitle>严律己，宽待人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.liwenguang.cn/"/>
  <updated>2017-09-25T16:18:00.000Z</updated>
  <id>http://www.liwenguang.cn/</id>
  
  <author>
    <name>TheOthers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二、Java并发机制的底层实现原理</title>
    <link href="http://www.liwenguang.cn/2017/09/26/concurrent_art/2_Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html/"/>
    <id>http://www.liwenguang.cn/2017/09/26/concurrent_art/2_Java并发机制的底层实现原理.html/</id>
    <published>2017-09-25T16:18:00.000Z</published>
    <updated>2017-09-25T16:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-volatile-的应用"><a href="#1-volatile-的应用" class="headerlink" title="1 volatile 的应用"></a>1 volatile 的应用</h1><h2 id="1-1-volatile-的定义与实现原理"><a href="#1-1-volatile-的定义与实现原理" class="headerlink" title="1.1 volatile 的定义与实现原理"></a>1.1 volatile 的定义与实现原理</h2><p><code>volatile</code> 变量修饰的共享变量进行写操作的时候，会引发两件事情：</p>
<ol>
<li>将当前处理器缓存行（ <code>cache line</code> ）的数据写回到系统内存。</li>
<li>这个写回内存的操作会使其它 <code>CPU</code> 里缓存了该内存地址的数据无效。</li>
</ol>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其它，即一级缓存、二级缓存等）后再进行操作，
但操作完全不知道何时会真正写到内存。而声明了 <code>volatile</code> 的变量进行写操作， <code>JVM</code> 就会向处理器发送一条 <code>Lock</code> 前缀的指令，
将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其它处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，
<strong>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，
当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，
会重新从系统内存中把数据读到处理器缓存里</strong>。</p>
<h2 id="1-2-volatile-的使用优化"><a href="#1-2-volatile-的使用优化" class="headerlink" title="1.2 volatile 的使用优化"></a>1.2 volatile 的使用优化</h2><p>在 <code>JDK 1.7</code> 中的 <code>LinkedTransferQueue</code> 使用 <code>volatile</code> 变量时，用一种追加字节的方式来优化队列出队和入队的性能，即将共享变量追加到 64 字节。
一个对象的引用占用 4 个字节，追加 15 个变量（共占 60 个字节），一共 64 个字节。<strong>这样 <code>CPU</code> 中缓存行中，最多只有一个队列，
而不会导致有两个队列，操作其中一个队列的时候由于和另一个队列在同一个缓存行中锁住了另一个队列</strong>。但是有两种场景下不应该使用这种方式：</p>
<ol>
<li>缓存行非 64 字节宽的处理。</li>
<li>共享变量不会被频繁的写。</li>
</ol>
<p>但是在 <code>java7</code> 中，它会淘汰或重新排列无用字段，因此需要使用其它追加字节的方式。</p>
<h1 id="2-synchronized-的实现原理与应用"><a href="#2-synchronized-的实现原理与应用" class="headerlink" title="2 synchronized 的实现原理与应用"></a>2 synchronized 的实现原理与应用</h1><p>作为一个重量级锁，虽然 <code>Java SE 1.6</code> 对 <code>synchronized</code> 进行了各种优化，有些情况下它就不那么重了。<br><code>Java</code> 中的每一个对象都可以作为锁：</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的 <code>Class</code> 对象。</li>
<li>对于同步方法块，锁是 <code>Synchronized</code> 括号里配置的对象。</li>
</ol>
<p><code>JVM</code> 基于进入和退出 <code>Monitor</code> 对象来实现方法同步和代码块同步，但两者的实现细节不同。<br>代码块同步是使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的，而方法同步使用另外一种方法实现，细节在 <code>JVM</code> 规范里并没有详细说明。但是，
方法的同步同样可以使用这两个指令来实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-volatile-的应用&quot;&gt;&lt;a href=&quot;#1-volatile-的应用&quot; class=&quot;headerlink&quot; title=&quot;1 volatile 的应用&quot;&gt;&lt;/a&gt;1 volatile 的应用&lt;/h1&gt;&lt;h2 id=&quot;1-1-volatile-的定义与
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="Java并发编程的艺术" scheme="http://www.liwenguang.cn/categories/readNote/concurrent-art/"/>
    
    
  </entry>
  
  <entry>
    <title>一、并发编程的挑战</title>
    <link href="http://www.liwenguang.cn/2017/09/25/concurrent_art/1_%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98.html/"/>
    <id>http://www.liwenguang.cn/2017/09/25/concurrent_art/1_并发编程的挑战.html/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2017-09-25T16:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1 上下文切换"></a>1 上下文切换</h1><p>并发是单核处理器支持多线程执行代码。则 <code>CPU</code> 通过给每个线程分配时间片来实现，线程任务执行的切换，由于在切换
前要保存当前任务的状态，因此从保存再到加载的过程就是一次上下文切换。</p>
<h2 id="1-1-多线程一定快吗？"><a href="#1-1-多线程一定快吗？" class="headerlink" title="1.1 多线程一定快吗？"></a>1.1 多线程一定快吗？</h2><p>以下为对比：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">100000001</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        concurrenct();</div><div class="line">        serial();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrenct</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                    a += <span class="number">5</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        thread.start();</div><div class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            b--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</div><div class="line">        thread.join();</div><div class="line">        System.out.println(<span class="string">"concurrency: "</span> + time + <span class="string">"ms, b = "</span> + b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            a += <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            b--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</div><div class="line">        System.out.println(<span class="string">"serial: "</span> + time + <span class="string">"ms, b = "</span> + b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">循环次数</th>
<th style="text-align:center">serial/ms</th>
<th style="text-align:center">concurrent/ms</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一亿</td>
<td style="text-align:center">91</td>
<td style="text-align:center">51</td>
</tr>
<tr>
<td style="text-align:center">一千万</td>
<td style="text-align:center">14</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">一百万</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">十万</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">一万</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h2 id="1-2-如何减少上下文切换"><a href="#1-2-如何减少上下文切换" class="headerlink" title="1.2 如何减少上下文切换"></a>1.2 如何减少上下文切换</h2><ol>
<li>无锁并发编程：多线程竞争锁时，会引起上下文切换。因此 <code>Hash</code> 算法通过取模分段，不同的线程处理不同段的数据。</li>
<li><code>CAS</code> 算法： <code>Atomic</code> 包使用 <code>CAS</code> 算法来更新数据，而不需要加锁。 </li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ol>
<h1 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2. 死锁"></a>2. 死锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (A) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (B) &#123;</div><div class="line">                        System.out.println(<span class="string">"1"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (B) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (A) &#123;</div><div class="line">                        System.out.println(<span class="string">"2"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的死锁在于，t1拿到锁之后，因为一些异常没有释放锁（或者死循环）。又或者是t1拿到一个数据库锁，释放锁的时候抛出了异常，没有释放掉。
导致t2一直等待t1释放锁。<br>而避免死锁常见方法有：</p>
<ol>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用 <code>lock.tryLock(timeout)</code> 来替代使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ol>
<h1 id="3-资源限制的挑战"><a href="#3-资源限制的挑战" class="headerlink" title="3 资源限制的挑战"></a>3 资源限制的挑战</h1><h2 id="3-1-什么是资源限制"><a href="#3-1-什么是资源限制" class="headerlink" title="3.1 什么是资源限制"></a>3.1 什么是资源限制</h2><p>资源限制是指，程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的宽带只有 2MB/s ，某个资源的下载速度是 1MB/s ，
系统启动 10 个线程下载资源，下载速度会不会变成 10MB/s ，所以在进行并发编程时，要考虑资源的限制。而硬件资源限制有带宽的上传/下载速度、
硬盘读写速度和 <code>CPU</code> 的处理速度，软件资源限制有数据库的连接数和 <code>socket</code> 连接数等。</p>
<h2 id="3-2-资源限制引发的问题"><a href="#3-2-资源限制引发的问题" class="headerlink" title="3.2 资源限制引发的问题"></a>3.2 资源限制引发的问题</h2><p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分编程并发执行，但是受限于资源，仍然在串行执行，这时候执行的会更慢，
因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发的下载和处理数据，导致 <code>CPU</code> 使用率达到 100% ，
几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。</p>
<h2 id="3-3-如何解决资源限制的问题"><a href="#3-3-如何解决资源限制的问题" class="headerlink" title="3.3 如何解决资源限制的问题"></a>3.3 如何解决资源限制的问题</h2><p>对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机运行。不同的机器处理不同的数据。  </p>
<p>对于软件资源限制，可以考虑使用资源池将资源复用。例如使用连接池数据库和 <code>Socket</code> 连接复用，或者在调用对方 <code>webservice</code> 接口获取数据时，
只建立一个连接。</p>
<h1 id="4-本章小结"><a href="#4-本章小结" class="headerlink" title="4 本章小结"></a>4 本章小结</h1><p>本章的并发程序不够严谨，但是够入门，笔者建议多实用 <code>JDK</code> 并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-上下文切换&quot;&gt;&lt;a href=&quot;#1-上下文切换&quot; class=&quot;headerlink&quot; title=&quot;1 上下文切换&quot;&gt;&lt;/a&gt;1 上下文切换&lt;/h1&gt;&lt;p&gt;并发是单核处理器支持多线程执行代码。则 &lt;code&gt;CPU&lt;/code&gt; 通过给每个线程分配时间片来
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="Java并发编程的艺术" scheme="http://www.liwenguang.cn/categories/readNote/concurrent-art/"/>
    
    
  </entry>
  
  <entry>
    <title>六、Zookeeper的典型应用场景续</title>
    <link href="http://www.liwenguang.cn/2017/08/30/zookeeper/6_Zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%BB%AD.html/"/>
    <id>http://www.liwenguang.cn/2017/08/30/zookeeper/6_Zookeeper的典型应用场景续.html/</id>
    <published>2017-08-29T16:30:20.000Z</published>
    <updated>2017-09-05T15:51:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>六、Zookeeper的典型应用场景</title>
    <link href="http://www.liwenguang.cn/2017/08/30/zookeeper/6_Zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html/"/>
    <id>http://www.liwenguang.cn/2017/08/30/zookeeper/6_Zookeeper的典型应用场景.html/</id>
    <published>2017-08-29T16:30:20.000Z</published>
    <updated>2017-09-05T15:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-典型应用场景及实现"><a href="#1-典型应用场景及实现" class="headerlink" title="1 典型应用场景及实现"></a>1 典型应用场景及实现</h1><h2 id="1-1-数据发布-订阅"><a href="#1-1-数据发布-订阅" class="headerlink" title="1.1 数据发布/订阅"></a>1.1 数据发布/订阅</h2><p>数据发布/订阅（Pulish/Subscribe）系统，即所谓的配置中心，顾名思义就是发布者将数据发布到ZooKeeper的一个或一系列节点上，供订阅者进行数据订阅，
进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。  </p>
<p>发布/订阅系统一般有两种设计模式，分别是推（Push）模式和拉（Pull）模式。在推模式中，服务端主动将数据更新发送给所有订阅的客户端；而拉模式则是由
客户端主动发起请求获取最新数据，通常客户端都采用定时进行轮询拉取的方式。ZooKeeper采用的是推拉结合的方式：客户端向服务端注册自己需要关注的
节点，一旦该节点的数据发生变更，那么服务端就会向相应的客户端发送Watcher事件通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。  </p>
<p>如果将配置信息存放到ZooKeeper上进行集中管理，那么通常情况下，应用在启动的时候都会主动到ZooKeeper服务端上进行一次配置信息的获取，同时，
在指定节点上注册一个Watcher监听，这样一来，但凡配置信息发生变更，服务端都会实时通知到所有订阅的客户端，从而达到实时获取最新配置信息的目的。  </p>
<p>实例：在我们平常的应用系统开发中，经常会碰到这样的需求：系统中需要使用一些通用的配置信息，例如机器列表信息、运行时的开关配置、数据库配置信息等。
这些全局配置信息通畅具备以下3个特性：</p>
<ul>
<li>数据量通常比较小。</li>
<li>数据内容在运行时会发生动态变化。</li>
<li>集群中各机器共享，配置一致。</li>
</ul>
<p>对于这类配置信息，一般的做法通常可以选择将其存储在本地配置文件或是内存变量中。本地配置可以采用JMX方式来实时对系统运行时内存变量的更新。  </p>
<p>但是一旦机器规模变大，且配置信息变更频繁后，就需要寻找一种更为分布式化的解决方案。  </p>
<p>下面以“数据库切换”的应用场景展开，看看如何使用ZooKeeper实现配置管理。</p>
<h3 id="1-1-1-配置存储"><a href="#1-1-1-配置存储" class="headerlink" title="1.1.1 配置存储"></a>1.1.1 配置存储</h3><p>进行配置之前，首先初始化配置存储到ZooKeeper上去，例如<code>/app1/databse_config/</code>（以下简称“配置节点”），写入数据节点中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dbcp.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dbcp.dbJDBCUrl=jdbc:mysql://localhost:3306/taokeeper</div><div class="line">dbcp.characterEncoding=GBK</div><div class="line">dbcp.username=admin</div><div class="line">dbcp.password=root</div><div class="line">dbcp.maxActive=30</div><div class="line">dbcp.maxIdle=10</div><div class="line">dbcp.maxWait=10000</div></pre></td></tr></table></figure></p>
<h3 id="1-1-2-配置获取"><a href="#1-1-2-配置获取" class="headerlink" title="1.1.2 配置获取"></a>1.1.2 配置获取</h3><p>集群中每台机器在启动初始化阶段，首先会从上面提到的ZooKeeper配置节点上读取数据库信息，同时，客户端还需要在该配置节点上注册一个数据变更的
Water监听，一旦发生节点数据变更，所有订阅的客户端都能够获取到数据变更通知。</p>
<h3 id="1-1-3-配置变更"><a href="#1-1-3-配置变更" class="headerlink" title="1.1.3 配置变更"></a>1.1.3 配置变更</h3><p>在系统运行过程中，可能会出现需要机型数据库切换的情况，借助ZooKeeper的Watcher机制，帮我们将数据变更的通知发送到各个客户端，每个客户端在
接收到这个变更通知后，就可以重新进行最新数据的获取。</p>
<h2 id="1-2-负载均衡"><a href="#1-2-负载均衡" class="headerlink" title="1.2 负载均衡"></a>1.2 负载均衡</h2><p>根据维基百科上的定义，负载均衡（Load Balance）是一种相当常见的计算机网络技术，用来对多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或是
其它资源进行分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间和避免过载的目的。通常负载均衡可以分为硬件和软件负载均衡两种，本节
主要探讨的是ZooKeeper在“软”负载均衡中的应用场景。  </p>
<p>在分布式系统中，负载均衡更是一种普遍的技术，基本上每一个分布式系统都需要使用负载均衡。在本书第一章讲解分布式系统特征的时候，我们提到，分布式系统具有
对等性，为了保证系统的高可用性，通常采用副本的方式来对数据和服务进行部署。而对于消费者而言，则需要在这些对等的服务提供方中选择一个来执行相关的业务
逻辑，其中比较典型的就是DNS服务。在本节中，我们将详细介绍如何使用ZooKeeper来解决负载均衡问题（<a href="../../../03/deepknowjavaweb/1_深入Web请求过程.html">请看深入分析Java_Web技术的第一章</a>）。</p>
<h3 id="1-2-1-一种动态的DNS服务"><a href="#1-2-1-一种动态的DNS服务" class="headerlink" title="1.2.1 一种动态的DNS服务"></a>1.2.1 一种动态的DNS服务</h3><p>DNS是域名系统（Domain Name System）的缩写。DNS系统可以看作是一个超大规模的分布式映射表，用于将域名和IP地址进行一一映射，进而方便人们
通过域名来访问互联网站点。  </p>
<p>通常情况下，我们可以向域名注册服务商申请域名注册，但是这种方式最大的缺陷在于只能注册有限的域名：</p>
<blockquote>
<p>日常开发过程中，经常会碰到这样的情况，在一个Company1公司内部，需要给一个App1应用的服务器集群机器配置一个域名解析。相信有过一线开发
经验的读者一定知道，这个时候通常需要由类似于app1.company1.com的一个域名，其对应的就是一个服务器地址。如果系统数量不多，那么通过
这种传统的DNS配置方式还可以应付，但是，一旦公司规模变大，各类应用层出不穷，那么就很难再通过这种方式来进行统一的管理了。</p>
</blockquote>
<p>因此，在实际开发中，往往使用本地HOST绑定来实现域名解析的工作。具体如何进行本地HOST绑定，因为不是本书的重点，并且互联网上有大量额资料，
因此这里不再多说明。使用本地HOST绑定的方法，可以很容易解决域名紧张的问题，基本上每一个系统都可以自行确定系统的域名与目标IO地址。大大提高了
开发调试效率。（就是修改HOST文件，让域名与IP直接映射，减去解析时间）然而，这种看上去完美的方案，也有其致命的缺陷：</p>
<blockquote>
<p>当应用的机器规模在一定范围内，并且域名的变更不是特别频繁时，本地HOST绑定是非常高效且简单的方式。然而一旦机器规模变大后，就常常
会碰到这样的情况：我们在应用上线的时候，需要在应用的每台机器上去绑定域名，但是在机器规模相当庞大的情况下，这种做法就相当不方便。
另外，如果想要临时更新域名，还需要到每个机器上去逐个进行变更，更消耗大量时间，因此完全无法保证实时性。</p>
</blockquote>
<p>现在，我们来介绍一种基于ZoKeeper实现的动态DNS方案（简称“DDNS”，Dynamic DNS）。</p>
<h3 id="1-2-2-域名配置"><a href="#1-2-2-域名配置" class="headerlink" title="1.2.2 域名配置"></a>1.2.2 域名配置</h3><p>首先需要在ZooKeeper上创建一个节点来进行域名配置。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-1.png" alt=""><br>这样，在<code>/DDNS/app1</code>的节点上，将自己的域名配置上去，并支持多个IP
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.0.1:8080, 192.168.0.2:8080</div></pre></td></tr></table></figure></p>
<h3 id="1-2-3-域名解析"><a href="#1-2-3-域名解析" class="headerlink" title="1.2.3 域名解析"></a>1.2.3 域名解析</h3><p>在传统的DNS解析中，我们都不需要关系域名的解析过程，所有这些工作都交给了操作系统的域名和IP地址映射机制（本地HOST绑定）或是专门的域名解析
服务器（由域名注册服务商提供）。因此，在这点上，DDNS方案和传统的域名解析有很大的区别————在DDNS中，域名的解析过程都是由每一个应用自己负责的。
通常应用都会首先从域名节点中获取一份IP地址和端口的配置，进行自行解析。同时，每个应用还会在域名节点上注册一个数据变更Watcher监听，以便及时
收到域名变更的通知。</p>
<h3 id="1-2-4-域名变更"><a href="#1-2-4-域名变更" class="headerlink" title="1.2.4 域名变更"></a>1.2.4 域名变更</h3><p>在运行过程中，难免会碰上域名对应的IP地址或是端口变更，这个时候就需要进行域名变更操作。在DDNS中，我们只需要对指定的域名节点进行更新操作，
ZooKeeper就会向订阅的客户端发送这个事件通知，应用在接收到这个事件通知后，就会再次进行域名配置的获取。  </p>
<p>上面我们介绍了如何使用ZooKeeper来实现一种动态的DNS系统。通过ZooKeeper来实现动态DNS服务，一方面，可以避免域名数量无限增长带来的集中式维护
的成本；另一方面，在域名变更的情况下，也能够避免因逐台机器更新本地HOST而带来的繁琐工作。</p>
<h3 id="1-2-5-自动化的DNS服务"><a href="#1-2-5-自动化的DNS服务" class="headerlink" title="1.2.5 自动化的DNS服务"></a>1.2.5 自动化的DNS服务</h3><p>根据上面的讲解，相信读者基本上已经能够使用ZooKeeper来实现一个动态的DNS服务了。但是我们仔细看一下上面的实现就会发现，在域名变更环节中，当
域名对应的I地址发生变更的时候，我们还是需要人为地介入去修改域名节点上的IP地址和端口。接下来我们看看下面这种使用ZooKeeper实现的更为自动化
的DNS服务。自动化的DNS服务系统主要是为了实现服务的自动化定位。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-2.png" alt=""><br>首先来介绍整个动态DNS系统的架构体系中比较重要的组件及其职责。</p>
<ul>
<li>Register Cluster：负责域名的动态注册。</li>
<li>Dispatcher Cluster：负责域名解析。</li>
<li>Scanner Cluster：负责检测以及维护服务状态（探测服务的可用性、屏蔽异常服务节点等）。</li>
<li>SDK：提供各种语言的系统接入协议，提供服务注册以及查询接口。</li>
<li>Monitor：负责收集服务信息以及对DDNS自身状态的监控。</li>
<li>Controller：后台管理的Console，负责授权管理、流量控制、静态配置服务和手动屏蔽服务等功能，运维人员在上面管理Register、Dispatcher和Scanner等Cluster。</li>
</ul>
<p>整个系统的核心当然是ZooKeeper集群，负责数据的存储以及一系列分布式协调。下面我们再来详细地看下整个系统是如何运行的。在这个架构模型中，我们
将那些目标IP地址和端口抽象为服务的提供者，而那些需要使用域名解析的客户端则被抽象成服务的消费者。</p>
<h4 id="1-域名注册"><a href="#1-域名注册" class="headerlink" title=".1 域名注册"></a>.1 域名注册</h4><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-3.png" alt=""><br>域名注册主要是针对服务提供者来说的。域名注册过程可以简单地概括为：每个服务提供者在启动的过程中，都会把自己的域名信息注册到Register Cluster中去。</p>
<ol>
<li>服务提供者通过SDK提供的API接口，将域名、IP地址和端口发送给Register Cluster。例如，A机器用于提供serverA.xxx.com，于是它就向Register
发送一个“域名-&gt;IP:PORT”的映射：“serverA.xxx.com-&gt;192.168.0.1:8080”。</li>
<li>Register获取到域名、IP地址和端口配置后，根据域名将信息写入相对应的ZooKeeper域名节点中。</li>
</ol>
<h4 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title=".2 域名解析"></a>.2 域名解析</h4><p>域名解析是针对服务消费者来说的，正好和域名注册过程相反：服务消费者在使用域名的时候，会向Dispatcher发出域名解析请求。Dispatcher收到请求后，
会从ZooKeeper上的指定域名节点读取相应的IP:PORT列表，通过一定的策略选取其中一个返回给前端应用。</p>
<h4 id="3-域名探测"><a href="#3-域名探测" class="headerlink" title=".3 域名探测"></a>.3 域名探测</h4><p>域名探测是指DDNS系统需要对域名下所有注册的IP地址和端口的可用性进行检测，俗称“健康度检测”。健康度检测一般有两种方式，第一种是服务端主动发起健康度心跳
检测，这种方式一般需要在服务端和客户端之间建立起一个TCP长链接；第二种则是客户端主动向服务端发起健康度心跳检测。在DDNS架构中的域名探测，使用
的是服务提供者都会定时向Scanner进行状态汇报（即第二种健康度检测方式）的模式，即每个服务提供者后都会定时向Scanner汇报自己的状态。  </p>
<p>Scanner会负责记录每个服务提供者最近一次的状态汇报时间，一旦超过5秒没有收到状态汇报，那么就认为该IP地址和端口已经不可用，于是开始进行域名
清理过程。在域名清理过程中，Scanner会在ZooKeeper中找到该域名对应的域名节点，然后将该IP地址和端口配置从节点内容中移除。</p>
<h2 id="3-1-命名服务"><a href="#3-1-命名服务" class="headerlink" title="3.1 命名服务"></a>3.1 命名服务</h2><p>命名服务（Name Service）也是分布式系统中比较常见的一类场景。在分布式系统中，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象等————
这些我们都可以统称它们为名字（Name），其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表，通过使用命名服务，
客户端应用能够根据指定名字来获取资源的实体、服务地址和提供者的信息等。  </p>
<p>Java语言中的JNDI便是一种典型的命名服务。JNDI是Java命名与目录接口（Java Naming and Directory Interface）的缩写，是J2EE体系中重要的规范之一，
标准的J2EE容器都提供了对JNDI规范的实现。因此，在实际开发中，开发人员常常使用应用服务器自带的JNDI实现来数据源的配置与管理————使用JNDI方式后，
开发人员可以完成不需要关心与数据库相关的任何信息，包括数据库类型、JDBC驱动类型以及数据库账号等。  </p>
<p>ZooKeeper提供的命名服务功能与JNDI技术有相似的地方，都能够帮助应用系统通过一个资源引用的方式来实现对资源的定位与使用。另外，广义上命名服务
的资源定位都不是真正意义的实体资源————在分布式环境中，上层应用仅仅需要一个全局唯一的名字，类似于数据库中的唯一主键。下面我们来看看如何使用
ZooKeeper来实现一套分布式全局唯一ID的分配机制。  </p>
<p>所谓ID，就是一个能够唯一标识某个对象的标识符。在我们熟悉的关系型数据库中，各个表都需要一个主键来唯一标识每条数据库记录，这个主键就是这样的唯一ID。
在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_increment属性来自动为每条数据库记录生成一个唯一的ID，数据库会保证生成的这个ID
在全局唯一。但是随着数据库数据规模的不断增大，分库分表随之出现，而auto_increment属性仅能针对单一表中的记录自动生成ID，因此在这种情况下，
就无法再依靠数据库的auto_increment属性来唯一标识一条记录了。于是，我们必须寻求一种能够在分布式环境下生成全局唯一ID的方法。  </p>
<p>一说起全局唯一ID，相信读者都会联想到UUID。没错，UUID是通用唯一识别码（Universally Unique Identifier）的简称，是一种在分布式系统中广泛
使用的用于唯一标识元素的标准，最典型的实现是GUID（Globally Unique Identifier，全局唯一标识符），主流ORM框架Hibernate有对UUID的直接支持。  </p>
<p>确实，UUID是一个非常不错的全局唯一ID生成方式，能够非常简便地保证分布式环境中的唯一性。一个标准的UUID是一个包含32位字符和4个短线的字符串，
例如“asd321a-sd-sdwds321d5w4a2-w5e4w51d”。UUID的优势自然不必多说，我们重点来看看它的缺陷。  </p>
<ul>
<li>长度过长：与数据库中的INT类型相比，存储一个UUID需要花费更多得空空间。</li>
<li>含义不明：影响问题排查和开发调试的效率。</li>
</ul>
<p>接下来，我们结合一个分布式任务调度系统来看看如何使用ZooKeeper来实现这类全局唯一ID的生成。  </p>
<p>通过ZooKeeper节点创建的API接口可以创建一个顺序节点，并且在API返回值中会返回这个节点的完整名字。利用这个特性，我们就可以借助ZooKeeper来生成
全局唯一的ID了。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-4.png" alt="">  </p>
<ol>
<li>所有客户端都会根据自己的任务类型，在指定类型的任务下面通过调用create()接口创建一个顺序节点，例如创建“job-”节点。</li>
<li>节点创建完毕后，create()接口会返回一个完整的节点名，例如“job-0000000003”。</li>
<li>客户端拿到这个返回值后，拼接上type类型，例如“type2-job-0000000003”，这就可以作为一个全局唯一的ID了。  </li>
</ol>
<p>在ZooKeeper中，每一个数据节点都能够维护一份子节点的顺序顺列，当客户单对其创建一个顺序子节点的时候ZooKeeper会自动以后缀的形式在其子节点上
添加一个序号，在这个场景中就是利用了ZooKeeper的这个特性。以下为博主测试：
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-5.png" alt=""><br>另外如果子节点过多，导致连接读取超时，可以适当提高配置中的initLimit以及syncLimit的数值（10倍也是可以的）。</p>
<h2 id="4-1-分布式协调-通知"><a href="#4-1-分布式协调-通知" class="headerlink" title="4.1 分布式协调/通知"></a>4.1 分布式协调/通知</h2><p>分布式协调/通知服务是分布系统不可缺少的环节，是将不同的分布式组件有机结合起来的关键所在。对于一个在多台机器上部署运行的应用而言，通常
需要一个协调者（Coordinator）来控制整个系统的运行流程，例如分布式事务的处理、机器间的互相协调等。同时，引入这样一个协调者，便于将分布式协调的职责从
应用中分离出来，从而可以大大减少系统之间的耦合性，而且能够显著提高系统的可扩展性。  </p>
<p>ZooKeeper中特有的Watcher注册与异步通知机制，能够很好地实现分布式环境下不同机器，甚至是不同系统之间的协调与通知，从而实现对数据变更的实时处理。
基于ZooKeeper实现分布式协调与通知功能，通常的做法是不同的客户端都对ZooKeeper上同一个数据节点进行Watcher注册，监听数据节点的变化（包括
数据节点本身及其子节点），如果数据节点发生变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。  </p>
<h3 id="4-1-1-MySQL数据复制总线：MySQL-Replicator"><a href="#4-1-1-MySQL数据复制总线：MySQL-Replicator" class="headerlink" title="4.1.1 MySQL数据复制总线：MySQL_Replicator"></a>4.1.1 MySQL数据复制总线：MySQL_Replicator</h3><p>MySQL数据复制总线（以下简称“复制总线”）是一个实时数据复制框架，用于在不同的MySQL数据库实例之间进行异步数据复制和数据变化通知。整个系统是一个由
MySQL数据库集群、消息队列系统、任务管理监控平台以及ZooKeeper集群等组件共同构成的一个包含数据生产者、复制管道和数据消息者等部分的数据总线系统。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-6.png" alt=""><br>在该系统中，ZooKeeper主要负责进行一系列的分布式协调工作，在具体的实现上，根据功能将数据复制组件划分为三个核心子模块：Core、Server和Monitor，
每个模块分别为一个单独的进程，通过ZooKeeper进行数据交换。</p>
<ul>
<li>Core实现了数据复制的核心逻辑，其将数据复制封装成管道，并抽象出生产者和消费者两个概念，其中生产者通常是MySQL数据库的Binlog日志。</li>
<li>Server负责启动和停止复制任务。</li>
<li>Monitor负责监控任务的运行状态，如果在数据复制期间发生异常或出现故障会进行告警。</li>
</ul>
<p>三个子模块之间的关系如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-7.png" alt=""><br>每个模块作为独立的进程运行在服务端，运行时的数据和配置信息均保存在ZooKeeper上，Web控制台通过ZooKeeper上的数据获取到后台进程的数据，同时发布控制信息。</p>
<h3 id="4-1-2-任务注册"><a href="#4-1-2-任务注册" class="headerlink" title="4.1.2 任务注册"></a>4.1.2 任务注册</h3><p>Core进程启动的时候，首先会向<code>/mysql_replicator/tasks</code>节点（以下简称“任务列表节点”）注册任务。例如，对于一个“复制热门商品”的任务，Task
所在机器在启动的时候，会首先在任务列表节点上创建一个子节点，例如<code>/mysql_replicator/tasks/copy_hot_time</code>（以下简称“任务节点”），如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-8.png" alt="" title="热备份ZK节点示意图"><br>如果在注册过程中发现该子节点已经存在，说明已经有其他Task机器注册了该任务，因此自己不需要再创建该节点了。</p>
<h3 id="4-1-3-任务热备份"><a href="#4-1-3-任务热备份" class="headerlink" title="4.1.3 任务热备份"></a>4.1.3 任务热备份</h3><p>为了应对复制任务故障或者复制任务所在主机故障，复制组件采用“热备份”的容灾方式，即将同一个复制任务部署在不同的主机上，我们称这样的机器为“任务机器”，
主、备任务机器通过ZooKeeper互相检测运行健康状况。  </p>
<p>为了实现上述热备方案，无论在第一步中是否创建了任务节点，每台任务机器都需要在<code>/mysql_replicator/tasks/copy_hot_item/instances</code>节点上
将自己的主机名注册上去。注意，这里注册的节点类型很特殊，是一个临时的顺序节点。在注册完这个子节点后，通常一个完整的节点名如下：
<code>/mysql_replicator/tasks/copy_hot_item/instances/[Hostname]-1</code>，其中最后的序列号就是临时顺序节点的精华所在。  </p>
<p>在完成该子节点的创建后，每台任务机器都可以获取到自己创建的节点的完成节点名以及所有子节点的列表，然后通过对比判断自己是否是所有子节点中序号最小的。
如果自己是序号最小的子节点，那么就将自己的运行状态设置为RUNNING，其余的任务机器则将自己设置为STANDBY————我们将这样的热备份策略称为“小序号优先”策略。</p>
<h3 id="4-1-4-热备切换"><a href="#4-1-4-热备切换" class="headerlink" title="4.1.4 热备切换"></a>4.1.4 热备切换</h3><p>完成运行状态的标识后，任务的客户端机器就能够正常工作了，其中标记为RUNNING的客户端机器进行正常的数据复制，而标记为STANDBY的客户端机器则进入待命状态。
这里所谓待命状态，就是说一旦标记为RUNNING的机器出现故障停止了任务执行，那么就需要在所有标记为STANDBY的客户端机器再次按照“小序号优先”策略来
选出RUNNING机器来执行，具体的做法就是标记为STANDBY的机器都需要在<code>/mysql_replicator/tasks/copy_hot_item/instances</code>节点上注册一个
“子节点列表变更”的Watcher监听，用来订阅所有任务执行机器的变化情况————一旦RUNNING机器宕机与ZooKeeper断开连接后，对应的节点就会消失，
于是其他机器也就接收到了这个变更通知，从而开始新一轮的RUNNING选举。</p>
<h3 id="4-1-5-记录执行状态"><a href="#4-1-5-记录执行状态" class="headerlink" title="4.1.5 记录执行状态"></a>4.1.5 记录执行状态</h3><p>既然使用了热备份，那么RUNNING任务机器就需要将运行时的上下文状态保留给STANDBY任务机器。在这个场景中，最主要的上下文状态就是数据复制过程中的
一些进度信息，例如Binlog日志的消费位点，因此需要将这些信息保存到ZooKeeper上以便共享。在Mysql_Replicator的设计中，选择了
<code>/mysql_replicator/tasks/copy_hot_item/lastCommit</code>作为Binlog日志消费位点的存储节点，RUNNING任务机器会定时向这个节点写入当前的Binlog日志消费位点。</p>
<h3 id="4-1-6-控制台协调"><a href="#4-1-6-控制台协调" class="headerlink" title="4.1.6 控制台协调"></a>4.1.6 控制台协调</h3><p>在上文中我们主要讲解了Core组件是如何进行分布式任务协调的，接下来我们再看看Server是如何来管理Core组件的。在Mysql_Replicator中，Server主要的
工作就是进行任务的控制，通过ZooKeeper来对不同的任务进行控制与协调。Server会将每个复制任务对应生产者的元数据，即库名、表名、用户名与密码等数据库信息以及
消费者的相关信息以配置的形式写入任务节点<code>/mysql_replicator/tasks/copy_hot_item</code>中去的，以便该任务的所有任务机器都能够共享该复制任务的配置。</p>
<h3 id="4-1-7-冷备切换"><a href="#4-1-7-冷备切换" class="headerlink" title="4.1.7 冷备切换"></a>4.1.7 冷备切换</h3><p>到目前为止我们已经基本了解了Mysql_Replicator的工作原理，现在再回过头来看上面提到的热备份。在该热备份方案中，针对一个任务，都会至少分配两台
任务机器来进行热备份，但是在一定规模的大型互联网公司中，往往有许多MySQL实例需要进行数据复制，每个数据库实例都会对应一个复制任务，
如果每个任务都进行双机热备份的话，那么显然需要消耗太多的机器。  </p>
<p>因此我们同时设计了一种冷备份，它和热备份方案的不同点在于，对所有任务进行分组，如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-9.png" alt="" title="冷备份ZK节点示意图"><br>和热备份中比较大的区别在于，Core进程被配置了所属Group（组）。举个例子来说，假如一个Core进程被标记了group1，那么在Core进程启动后，会到对应
的ZooKeeper group1节点下面获取所有的Task列表，假如找到了任务“copy_hot_item”之后，就会遍历这个Task列表的instances节点，但凡还没有子节点的，
则会创建一个临时的顺序节点：<code>/mysql_replicator/task-groups/group1/copy_hot_item/instances/[Hostname]-1</code>————当然，在这个过程中，其它
Core进程也会在这个instances节点下创建类似的子节点。和热备份中的“小序号优先”策略一样，顺序小的Core进程将自己标记为RUNNING，不同之处在于，其它Core
进程则会自动将自己创建的子节点删除，然后继续遍历下一个Task节点————我们将这样的过程称为“冷备份扫描”。就这样，所有Core进程在一个扫描周期内不断地对相应
的Group下面的Task进行冷备份扫描。整个过程如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-10.png" alt="" title="冷备份流程图"></p>
<h3 id="4-1-8-冷热备份对比"><a href="#4-1-8-冷热备份对比" class="headerlink" title="4.1.8 冷热备份对比"></a>4.1.8 冷热备份对比</h3><p>从上面的讲解中，我们基本对热备份和冷备份两种运行方式都有了一定的了解，现在再来对比下这两种运行方式。在热备份方案中，针对一个任务使用了两台机器进行
热备份，借助ZooKeeper的Watcher通知机制和临时顺序节点的特性，能够非常实时地进行互相协调，但缺陷就是机器资源消耗比较大。而在冷备份方案中，采用了扫描机制，
虽然降低了任务协调的实时性，但是节省了机器资源。（<strong>博主总结冷备份与热备份的区别在于，热备份一个运行多个等待，冷备份在于一个运行，系统轮询判断是否有一个
在运行，只要有一个在运行就遍历下个任务，如果一个都没有在运行这个任务就让自己运行</strong>）。
，</p>
<h3 id="4-1-9-一种通用的分布式系统机器间通信方式"><a href="#4-1-9-一种通用的分布式系统机器间通信方式" class="headerlink" title="4.1.9 一种通用的分布式系统机器间通信方式"></a>4.1.9 一种通用的分布式系统机器间通信方式</h3><p>在绝大部分的分布式系统中，系统机器间的通信无外乎心跳检测、工作进度汇报和系统调度这三种类型。接下来，我们将围绕这三种类型的机器通信讲解
如何基于ZooKeeper去实现一种分布式系统间的通信方式。  </p>
<h4 id="1-心跳监测"><a href="#1-心跳监测" class="headerlink" title=".1 心跳监测"></a>.1 心跳监测</h4><p>机器间的心跳检测机制是指在分布式环境中，不同机器之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们
通常是通过主机之间是否可以互相PING通来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过<strong>TCP连接固有的心跳检测机制来实现上层机器的心跳检测</strong>，
这些确实都是一些非常常见的心跳检测方法。而ZooKeeper基于ZooKeeper的临时节点特性，可以让不同的机器都在ZooKeeper的一个指定节点下创建临时子节点，不同的机器
之间可以根据这个临时节点来判断对应的客户端机器是否存活。通过这种方式，检测系统和被检测系统之间并不需要直接相关联，而是通过ZooKeeper上的
某个节点进行关联，大大减少了系统耦合。</p>
<h4 id="2-工作进度汇报"><a href="#2-工作进度汇报" class="headerlink" title=".2 工作进度汇报"></a>.2 工作进度汇报</h4><p>在一个常见的任务分发系统中，通常任务被分发到不同的机器上执行后，需要实时地将自己的任务执行进度汇报给分发系统。这个时候就可以通过ZooKeeper来实现。
在ZooKeeper上选择一个节点，每个任务客户端都在这个节点下面创建临时子节点，这样便可以实现两个功能：</p>
<ul>
<li>通过判断临时节点是否存在来确定任务机器是否存活；</li>
<li>各个任务机器会实时地将自己的任务执行进度写到这个临时节点上去，以便中心系统能够实时地获取到任务的执行进度。</li>
</ul>
<h4 id="3-系统调度"><a href="#3-系统调度" class="headerlink" title=".3 系统调度"></a>.3 系统调度</h4><p>使用ZooKeeper，能够实现另一种调度模式：一个分布式系统由控制台和一些客户端系统两部分组成，控制台的职责就是需要将一些指令信息发送给所有的
客户端，以控制它们进行相应的业务逻辑。后台管理人员在控制台上做的一些操作，实际上就是修改了ZooKeeper上某些节点的数据，而ZooKeeper进一步
把这些数据变更以事件通知的形式发送给了对应的订阅客户端。  </p>
<p>总之，使用ZooKeeper来实现分布式系统机器间的通信，不仅能省去大量底层网络通信和协议设计上重复的工作，更为重要的一点是大大降低了系统之间的耦合，
能够非常方便地实现异构系统之间的灵活通信。</p>
<h2 id="5-1-集群管理"><a href="#5-1-集群管理" class="headerlink" title="5.1 集群管理"></a>5.1 集群管理</h2><p>随着分布式系统规模的日益扩大，集群中的机器规模也随之变大，因此，如何更好地进行集群管理也显得越来越重要了。  </p>
<p>所谓集群管理，包括<strong>集群监控</strong>与<strong>集群控制</strong>两大块、前者侧重对集群运行时状态的收集，后者则是对集群进行操作与控制。在日常开发和运维过程中，我们经常会有
类似于如下的需求。</p>
<ul>
<li>希望知道当前集群中究竟有多少机器在工作。</li>
<li>对集群中每台机器的运行时状态进行数据收集。</li>
<li>对集群中机器进行上下线操作。</li>
</ul>
<p>在传统的基于Agent的分布式集群管理体系中，都是通过在集群中的每台机器上部署一个Agent，由这个Agent负责主动向指定的一个监控中心系统（监控中心
系统负责将所有数据进行集中处理，形成一系列报表，并负责实时报警，以下简称“监控中心”）汇报自己所在机器的状态。在集群规模适中的场景下，这确实
是一种在生产实践中广泛使用的解决方案，能够快速有效地实现分布式环境集群监控，但是一旦系统的业务场景增多，集群规模变大，该解决方案的弊端也就显现出来了:</p>
<ul>
<li>大规模升级困难：以客户端形式存在的Agent，在大规模使用后，一旦遇到需要大规模升级的情况，就非常麻烦，在升级成本和升级进度的控制上面临巨大的挑战。</li>
<li>统一的Agent无法满足多样的需求：对于机器的CPU使用率、负载（Load）、内存使用率、网络吞吐以及磁盘容量等机器基本的物理状态，使用统一的Agent
来进行监控或许都可以满足。但是，如果需要深入应用内部，对一些业务状态进行监控，例如，在一个分布式消息中间件中，希望监控到每个消费者对消息的消费状态；
或者在一个分布式任务调度系统中，需要对每个机器上任务的执行情况进行监控。很显然，对于这些业务耦合紧密的监控需求，不适合由一个统一的Agent来提供。</li>
<li>编程语言多样性：随着越来越多编程语言的出现，各种异构系统层出不穷。如果使用传统的Agent方式，那么需要提供各种语言的Agent客户端。另一方面，
“监控中心”在对异构系统的数据进行整合上面临巨大挑战。</li>
</ul>
<p>ZooKeeper具有以下两大特性：</p>
<ul>
<li>客户端如果对ZooKeeper的一个数据节点注册Watcher监听，那么当该数据节点的内容或是其子节点列表发生变更时，ZooKeeper服务器就会向订阅的
客户端发送变更通知。</li>
<li>对在ZooKeeper上创建的临时节点，一旦客户端与服务器之间的会话失效，那么该临时节点也就被自动清除。</li>
</ul>
<p>利用ZooKeeper的这两大特性，就可以实现另一种集群机器存活性监控的系统。例如，监控系统在<code>/clusterServers</code>节点上注册一个Watcher监听，
那么但凡进行动态添加机器的操作，就会在<code>/clusterServers</code>节点下创建一个临时节点<code>/clusterServers/[Hostname]</code>。这样一来监控系统就能够实时
检测到机器的变动情况，至于后续处理就是监控系统的业务了。下面我们就通过分布式日志收集系统和在线云主机管理这两个典型例子来看看如何使用ZooKeeper
实现集群管理。</p>
<h3 id="5-1-1-分布式日志收集系统"><a href="#5-1-1-分布式日志收集系统" class="headerlink" title="5.1.1 分布式日志收集系统"></a>5.1.1 分布式日志收集系统</h3><p>分布式日志收集系统的核心工作就是收集分布在不同机器上的系统日志，在这里我们重点来看分布式日志系统的收集器模块。  </p>
<p>在一个典型的日志系统的架构设计中，整个日志系统会把所有需要收集的日志机器（下文以“日志源机器”代表此类机器）分为多个组别，每个组别对应一个收集器，
这个收集器其实就是一个后台机器（下文以“收集器机器”代表此类机器），用于收集日志。对于大规模的分布式日志收集系统场景，通常需要解决如下两个问题。</p>
<ul>
<li>变化的日志源机器：在生产环境中，伴随着机器的变动，每个应用的机器几乎每天都是在变化的（机器硬件问题、扩容、机房迁移或是网络问题都会导致一个应用的机器变化），
也就是说每个组别中的日志源机器通常是在不断变化的。</li>
<li>变化的收集器机器：日志收集系统自身也会有机器的变更或扩容，于是会出现新的收集器加入或是老的收集器机器退出的情况。</li>
</ul>
<p>上面两个问题，无论是日志源机器还是收集器机器的变更，最终都归结为一点：如何快速、合理、动态地为每个收集器分配对应的日志源机器，这也成为了整个
日志系统正确稳定运转的前提，也是日志收集过程中最大的技术挑战。在这种情况下，引入ZooKeeper是个不错的选择，下面我们来看ZooKeeper在这个
场景中的使用。</p>
<h4 id="1-注册收集器机器"><a href="#1-注册收集器机器" class="headerlink" title=".1 注册收集器机器"></a>.1 注册收集器机器</h4><p>使用ZooKeeper来进行日志系统收集器的注册、典型做法是在ZooKeeper上创建一个节点作为收集器的根节点，例如<code>/logs/collector</code>（下文我们以“收集器
节点”代表该数据节点），每个收集器机器在启动的时候，都会在收集器节点下创建自己的节点，例如<code>logs/collector/[Hostname]</code>。</p>
<h4 id="2-任务分发"><a href="#2-任务分发" class="headerlink" title=".2 任务分发"></a>.2 任务分发</h4><p>待所有收集器机器都创建好自己对应的节点后，系统根据收集器节点下子节点的个数，将所有日志源机器分成对应的若干组，然后将分组后的机器列表分别写到
这些收集器机器创建的子节点（例如<code>/logs/collector/host1</code>）上去。这样一来，每个收集器机器都能够从自己对应的收集器节点获取日志源机器列表，
进而开始进行日志收集工作。</p>
<h4 id="3-状态汇报"><a href="#3-状态汇报" class="headerlink" title=".3 状态汇报"></a>.3 状态汇报</h4><p>完成收集器机器的注册以及任务分发后，我们还要考虑到这些机器随时都有挂掉的可能。因此，针对这个问题，我们需要有一个收集器的状态汇报机制：
每个收集器机器在创建完自己的专属节点后，还需要在对应的子节点上创建一个状态子节点，例如<code>/logs/collector/host1/status</code>，每个收集器都需要定期向
该节点写入自己的状态信息。我们可以把这种策略看作是一种检测机制，通常收集器机器都会在这个节点写入日志收集进度信息。日志系统根据该状态子节点的最后更新时间
来判断对应的收集器机器是否存活。</p>
<h4 id="4-动态分配"><a href="#4-动态分配" class="headerlink" title=".4 动态分配"></a>.4 动态分配</h4><p>如果收集器机器挂掉或是扩容了，就需要动态地进行收集任务的分配。在运行过程中，日志系统始终关注着<code>/logs/collector</code>这个节点下所有子节点的变更，
一旦检测到有收集器机器停止汇报或是有新的收集器机器加入，就要开始进行任务的重新分配。无论是针对收集器机器停止汇报还是新机器加入的情况，
日志系统都需要将之前分配给该收集器的所有任务转移。为了解决这个问题，通常有两种做法。</p>
<h5 id="4-1-全局动态分配"><a href="#4-1-全局动态分配" class="headerlink" title=".4.1 全局动态分配"></a>.4.1 全局动态分配</h5><p>这是一种简单粗暴的做法，在出现收集器机器挂掉或是新机器加入的时候，日志系统需要根据新的收集器机器列表，立即对所有的日志源机器重新进行一次分组，
然后将其分配给剩下的收集器机器。</p>
<h5 id="4-2-局部动态分配"><a href="#4-2-局部动态分配" class="headerlink" title=".4.2 局部动态分配"></a>.4.2 局部动态分配</h5><p>全局动态分配方式虽然策略简单，但是存在一个问题：一个或部分收集器机器的变更，就会导致全局动态任务的分配，影响面比较大，因此风险也就比较大。
所谓局部动态分配，顾名思义就是在小范围内进行任务的动态分配。在这种策略中，每个收集器机器在汇报自己日志收集状态的同时，也会把自己的负载汇报上去。
请注意，这里提到的负载并不仅仅只是简单地指机器CPU负载（Load），而是一个对当前收集器任务执行的综合评估。  </p>
<p>在这种策略中，如果一个收集器机器挂了，那么日志系统就会把之前分配给这个机器的任务重新分配到那些负载较低的机器上去。同样，如果有新的收集器机器加入，
会从那些负载高的机器上转移部分任务给这个新加入的机器。</p>
<h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title=".5 注意事项"></a>.5 注意事项</h4><h5 id="5-1-节点类型"><a href="#5-1-节点类型" class="headerlink" title=".5.1 节点类型"></a>.5.1 节点类型</h5><p>首先看<code>/logs/collector</code>这个节点下面子节点的节点类型。这个节点下面的所有子节点都代表了每个收集器机器，那么初步认为这些子节点必须选择临时节点，
原因是日志系统可以根据这些临时节点来判断收集器机器的存活性。但是，同时还需要注意的一点是：在分布式日志收集这个场景中，收集器节点上还会存放所有
已经分配给该收集器机器的日志源机器列表，如果只是简单地依靠ZooKeeper自身的临时节点机制，那么当一个收集器挂掉或是当这个收集器机器中断“心跳汇报”
的时候，待该收集器节点的会话失效后，ZooKeeper就会立即删除该节点，于是，记录在该节点上的所有日志源机器列表也就随之被清除掉了。  </p>
<p>从上面的描述中可以知道，临时节点显然无法满足这里的业务需求，所以我们选择了使用持久节点来标识每一个收集器机器，同时在这个持久节点下面分别创建
<code>/logs/collector/[Hostname]/status</code>节点来表征每一个收集器机器的状态。这样一来，既能实现日志系统对所有收集器的监控，同时在收集器机器挂掉
后，依然能够准确地将分配于其中的任务还原。</p>
<h5 id="5-2-日志系统节点监听"><a href="#5-2-日志系统节点监听" class="headerlink" title=".5.2 日志系统节点监听"></a>.5.2 日志系统节点监听</h5><p>在实际生产运行过程中，每一个收集器机器更改自己状态节点的频率可能非常高（如每秒1次或更短），而且收集器的数量可能非常大，如果日志系统监听所有
这些节点变化，那么通知的消息量可能会非常大。另一方面，在收集器机器正常工作的情况下，日志系统没有必要去实时地接收每次节点状态变更，因此大部分
这些变更通知都是无用的。因此我们考虑放弃监听设置，而是采用日志系统主动轮询收集器节点的策略，这样就节省了不少网卡流量，唯一的缺陷就是有
一定的延时（考虑到分布式日志收集系统的定位，这个延时是可以接受的）。</p>
<h3 id="5-1-2-在线云主机管理"><a href="#5-1-2-在线云主机管理" class="headerlink" title="5.1.2 在线云主机管理"></a>5.1.2 在线云主机管理</h3><p>在线云主机管理通常出现在那些虚拟主机提供商的应用场景中。在这类集群管理中，有很重要的一块就是集群机器的监控。这个场景通常对于集群中的机器状态，
尤其是机器在线率的统计有较高的要求，同时需要能够快速地对集群中机器的变更做出响应。  </p>
<p>在传统的实现方案中，监控系统通过某种手段（比如检测主机的指定端口）来对每台机器进行定时检测，或者每台机器自己定时向监控系统汇报“我还活着”。
但是这种方式需要每个业务系统的开发人员自己来处理网络通信、协议设计、调度和容灾等诸多琐碎的问题。下面来看看使用ZooKeeper实现的另一种集群机器
存活性监控系统。针对这个系统，我们的需求点通常如下。</p>
<ul>
<li>如何快速地统计当前生产环境一共有多少台机器？</li>
<li>如何快速地获取到机器上/下线的情况？</li>
<li>如何实时监控集群中每台主机的运行时状态？</li>
</ul>
<h4 id="1-机器上-下线"><a href="#1-机器上-下线" class="headerlink" title=".1 机器上/下线"></a>.1 机器上/下线</h4><p>为了实现自动化的线上运维，我们必须对机器的上/下线情况有一个全局的监控。通常在新增机器的时候，需要首先将指定的Agent部署到这些机器上去。
Agent部署启动之后，会首先向ZooKeeper的指定节点进行注册，具体的做法就是在机器列表节点下面创建一个临时子节点，例如<code>/XAE/machine/[Hostname]</code>
（下文以“主机节点”代表这个节点），如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-12.png" alt=""><br>当Agent在ZooKeeper上创建完这个临时子节点后，对<code>/XAE/machines</code>节点关注的监控中心就会接收到“子节点变更”事件，即上线通知，于是就可以对这个
新加入的机器开启相应的后台管理逻辑。另一方面，监控中心同样可以获取到机器下线的通知，这样便实现了对机器上/下线的检测，同时能够很容易地获取
到在线的机器列表，对于大规模的扩容和容量评估都有很大的帮助。</p>
<h4 id="2-机器监控"><a href="#2-机器监控" class="headerlink" title=".2 机器监控"></a>.2 机器监控</h4><p>对于一个在线云主机系统，不仅要对机器的在线状态进行检测，还需要对机器的运行时状态进行监控。在运行的过程中，Agent会定时将主机的运行状态信息
写入ZooKeeper上的主机节点，监控中心通过订阅这些节点的数据变更通知来间接地获取主机的运行时信息。  </p>
<p>随着分布式系统规模变得越来越庞大，对集群机器的监控和管理显得越来越重要。上面提到的这种借助ZooKeeper来实现的方式，不仅能够实时地检测到集群
中机器的上/下线情况，而且能够实时地获取到主机的运行时信息，从而能够构建出一个大规模集群的主机图谱。</p>
<h2 id="6-1-Master选举"><a href="#6-1-Master选举" class="headerlink" title="6.1 Master选举"></a>6.1 Master选举</h2><p>Master选举是一个在分布式系统中非常常见的应用场景。分布式最核心的特性就是能够将具有独立计算能力的系统单元部署在不同的机器上，构成一个完整的
分布式系统。而与此同时，实际场景中往往也需要在这些分布在不同机器上的独立系统单元中选出一个所谓的“老大”，在计算机科学中，我们称之为“Master”。  </p>
<p>在分布式系统中，Master往往用来协调集群中其他系统单元，具有对分布式系统状态变更的决定权。例如，在一些读写分离的应用场景中，客户端的写请求往往
是由Master来处理的；而在另一些场景中，Master则常常负责处理一些复杂的逻辑，并将处理结果同步给集群中其它系统单元。Master选举可以说是ZooKeeper
最典型的应用场景了，在本节中，我们就结合“一种海量数据处理与共享模型”这个具体例子来看看ZooKeeper在集群Master选举中的应用场景。  </p>
<p>在分布式环境中，经常会碰到这样的应用场景：集群中的所有系统单元需要对前端业务提供数据，比如一个商品ID，或者是一个网站轮播广告的广告ID（通常
出现在一些广告投放系统中）等，而这些商品ID或是广告ID往往需要从一系列的海量数据处理中计算得到————这通常是一个非常耗费I/O和CPU资源的过程。
鉴于该计算过程的复杂性，如果让集群中的所有机器都执行这个计算逻辑的话，那么将耗费非常多的资源。一种比较好的方法就是只让集群中的部分，甚至只
让其中的一台机器去处理数据计算，一旦计算出数据结果，就可以共享给整个集群中的其他所有客户端机器，这样可以大大减少重复劳动，提升性能。  </p>
<p>这里我们以一个简单的广告投放系统后台场景为例来讲解这个模型。整个系统大体上可以分成客户端集群、分布式缓存系统、海量数据处理总线和ZooKeeper
四个部分，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-13.png" alt=""><br>Client集群每天定时会通过ZooKeeper来实现Master选举。选举产生Master客户端之后，这个Master就会负责进行一系列的海量数据处理，最终计算得到
一个数据结果，并将其放置在一个内存/数据库中。同时，Master还需要通知集群中其它所有的客户端从这个内存/数据库中共享计算结果。  </p>
<p>接下去，我们将重点来看Master选举的过程，首先来明确下Master选举的需求：在集群的所有机器中选举出一台机器作为Master。针对这个需求，通常情况
下，我们可以选择常见的关系型数据库中的主键特性来实现：集群中的所有机器都向数据库中插入一条相同主键ID的记录，数据库会帮助我们自动进行主键冲突
检查，也就是说，所有进行插入操作的客户端机器中，只有一台机器能够成功————那么，我们就认为向数据库中成功插入数据的客户端机器成为Master。  </p>
<p>乍一看，这个方案确实可行，依靠关系型数据库的主键特性能够很好地保证在集群中选举出唯一的一个Master。但是我们需要考虑的另一个问题是，如果当前
选举出的Master挂了，那么该如何处理？谁来告诉我Master挂了呢？显然，关系型数据库没法通知我们这个事件。  </p>
<p>ZooKeeper的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即ZooKeeper将会保证客户端无法重复创建一个已经存在
的数据节点。也就是说，如果同时有多个客户端请求创建同一个节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式
环境中进行Master选举了。  </p>
<p>在这个系统中，首先会在ZooKeeper上创建一个日期节点，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-14.png" alt=""><br>客户端集群每天都会定时往ZooKeeper上创建一个临时节点，例如<code>/master_election/2017-09-03/binding</code>。在这个过程中，只有一个客户端能够成功
创建这个节点，那么这个客户端所在机器就称为了Master。同时，其他没有在ZooKeeper上成功创建节点的客户端，都会在节点<code>/master_ecection/2017-09-03</code>
上注册一个子节点变更的Watcher，用于监控当前的Master机器是否存活，一旦发现当前的Master挂了，那么其余的客户端将会重新进行Master选举。  </p>
<p>从上面的讲解中，我们可以看到，如果仅仅只是想实现Master选举的话，那么其实只需要有一个能够保证唯一性的组件即可，例如关系型数据库的主键模型
就是不错的选择。但是，如果希望能够快速地进行集群Master动态选举，那么基于ZooKeeper来实现是一个不错的新思路。</p>
<h2 id="7-1-分布式锁"><a href="#7-1-分布式锁" class="headerlink" title="7.1 分布式锁"></a>7.1 分布式锁</h2><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的
时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。  </p>
<p>在平时的实际项目开发中，我们往往很少会去在意分布式锁，而是依赖于关系型数据库固有的排他性来实现不同进程之间的互斥。这确实是一种非常简便且被
广泛使用的分布式锁实现方式。然而有一个不争的事实是，目前绝大多数大型分布式系统的性能瓶颈都集中在数据库操作上。因此，如果上层业务再给数据库
添加一些额外的锁，例如行锁、表锁甚至是繁重的事务处理，那么是不是会让数据库更加不堪重负呢？下面我们来看看使用ZooKeeper如何实现分布式锁，
这里主要讲解排他锁和共享锁两类分布式锁。</p>
<h3 id="7-1-1-排他锁"><a href="#7-1-1-排他锁" class="headerlink" title="7.1.1 排他锁"></a>7.1.1 排他锁</h3><p>排他锁（Exclusive Locks，简称X锁），又称为写锁或独占锁，是一种基本的锁类型。如果事务T1对数据对象O1加上了排他锁，那么在整个加锁期间，只允许
事务T1对O1进行读取和更新操作，其他任何事务都不能再对这个数据对象进行任何类型的操作————直到T1释放了排他锁。  </p>
<p>从上面讲解的排他锁的基本概念中，我们可以看到，排他锁的核心是如何保证当前有且仅有一个事务获得锁，并且锁被释放后，所有正在等待获取锁的事务都
能够被通知到。下面我们就看看如何借助ZooKeeper实现排他锁。</p>
<h4 id="1-定义锁"><a href="#1-定义锁" class="headerlink" title=".1 定义锁"></a>.1 定义锁</h4><p>有两种常见的方式可以用来定义锁，分别是synchronized机制和JDK5提供的ReentrantLock。然而，在ZooKeeper中，没有类似于这样的API可以直接使用，
而是通过ZooKeeper上的数据节点来表示一个锁，例如<code>/exclusive_lock/lock</code>节点就可以被定义为一个锁，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-15.png" alt=""></p>
<h4 id="2-获取锁"><a href="#2-获取锁" class="headerlink" title=".2 获取锁"></a>.2 获取锁</h4><p>在需要获取排他锁时，所有的客户端都会试图通过调用create()接口，在<code>/exclusive_lock</code>节点下创建临时子节点<code>/exclusive_lock/lock</code>。而ZooKeeper
会保证在所有的客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获取了锁。同时，所有没有获取到锁的客户端就需要到<code>/exclusive_lock</code>
节点上注册一个子节点变更的Watcher监听，以便实时监听到lock节点的变更情况。</p>
<h4 id="3-释放锁"><a href="#3-释放锁" class="headerlink" title=".3 释放锁"></a>.3 释放锁</h4><p>由于是临时节点，有下面两种情况，可能释放锁：</p>
<ul>
<li>当前获取锁的客户端机器发生宕机</li>
<li>正常执行完业务逻辑后，客户端主动将临时节点删除。</li>
</ul>
<p>无论在上面情况下移除了lock节点，ZooKeeper都会通知所有在<code>/exclusive_lock</code>节点上注册了子节点变更Watcher监听的客户端。这些客户端在接收到通知后，
再次重新发起分布式锁获取，即重复“获取锁”过程。如下图：
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-16.png" alt="" title="排他锁的流程图"></p>
<h3 id="7-1-2-共享锁"><a href="#7-1-2-共享锁" class="headerlink" title="7.1.2 共享锁"></a>7.1.2 共享锁</h3><p>共享锁（Shared Locks，简称S锁），又称读锁，同样是一种基本的锁类型。如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作，
其他事务也只能对这个数据对象加共享锁————直到该数据对象上的所有共享锁都被释放。  </p>
<p>共享锁和排他锁最根本的区别在于，加上排他锁后，数据对象只对一个事务可见，而加上共享锁后，数据对所有事务都可见。</p>
<h4 id="1-定义锁-1"><a href="#1-定义锁-1" class="headerlink" title=".1 定义锁"></a>.1 定义锁</h4><p>和排他锁一样，同样是通过ZooKeeper上的数据节点来表示一个锁，是一个类似于<code>/shared_lock/[Hostname]-请求类型-序号</code>的临时顺序节点，例如
<code>/shared_lock/192.168.0.1-R-0000000001</code>，那么，这个节点就代表了一个共享锁，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-17.png" alt=""></p>
<h4 id="2-获取锁-1"><a href="#2-获取锁-1" class="headerlink" title=".2 获取锁"></a>.2 获取锁</h4><p>在需要获取共享锁时，所有客户端都会到<code>/shared_lock</code>这个节点下面创建一个临时顺序节点，如果当前是读请求，那么就创建例如<code>/shared_lock/192.168.0.1-R-000000001/</code>
的节点；如果是写请求，那么就创建例如<code>/shared_lock/192.168.0.1-W-000000001</code>的节点。</p>
<h4 id="3-判断读写顺序"><a href="#3-判断读写顺序" class="headerlink" title=".3 判断读写顺序"></a>.3 判断读写顺序</h4><p>根据共享锁的定义，不同的事务都可以同时对同一数据对象进行读取操作，而更新操作必须在当前没有任何事务进行读写操作的情况下进行。基于这个原则，
我们来看看如何通过ZooKeeper的节点来确定分布式读写顺序，大致可以分为如下4个步骤。</p>
<ol>
<li>创建完节点后，获取<code>/shared_lock</code>节点下的所有子节点，并对该节点注册子节点变更的Watcher监听。</li>
<li>确定自己的节点序号在所有子节点中的顺序。</li>
<li>如果当前节点业务为读请求：如果没有比自己序号小的子节点，或是所有比自己序号小的子节点都是读请求，那么表明自己已经成功获取到了共享锁，同时
开始执行读取逻辑。如果比自己序号小的子节点有写请求，那么就需要进入等待。<br>如果当前节点业务为写请求：如果自己不是序号最小的子节点， 那么就需要进入等待。</li>
<li>接收到Watcher通知后，重复步骤1。</li>
</ol>
<h4 id="4-释放锁"><a href="#4-释放锁" class="headerlink" title=".4 释放锁"></a>.4 释放锁</h4><p>释放锁的逻辑和排他锁是一致的。</p>
<h4 id="5-羊群效应"><a href="#5-羊群效应" class="headerlink" title=".5 羊群效应"></a>.5 羊群效应</h4><p>上面讲解的这个共享锁实现，大体上能够满足一般的分布式集群竞争锁的需求，并且性能都还可以————这里说的一般场景是指集群规模不是特别大，一般是在
10台机器以内。但是如果机器规模扩大之后，会有什么问题呢？我们着重来看上面“判断读写顺序”过程的步骤3，如下图，看看实际运行中的情况。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-18.png" alt="">  </p>
<ol>
<li>192.168.0.1这台机器首先进行读操作，完成读操作后将节点<code>/192.168.0.1-R-000000001</code>删除。</li>
<li>余下的4台机器均收到了这个节点被移除的通知，然后重新从<code>/shared_lock/</code>节点上获取一份新的子节点列表。</li>
<li>每个机器判断自己的读写顺序。其中192.168.0.2这台机器检测到自己已经是序号最小的机器了，于是开始进行写操作，而余下的其他机器发现没有轮到
自己进行读取或更新操作，于是继续等待。</li>
<li>继续……</li>
</ol>
<p>上面这个过程就是共享锁在实际运行中最主要的步骤了，我们着重看下上面步骤3中提到的：“而余下的其他机器发现没有轮到自己进行读取或更新操作，于是继续等待。”
很明显，我们看到，192.168.0.1这个客户端在移除自己的共享锁后，ZooKeeper发送了子节点变更Watcher通知给所有机器，然而这个通知除了给192.168.0.2
这台机器产生实际影响外，对于余下的其他所有机器都没有任何作用。  </p>
<p>相信读者也已经意思到了，在这整个分布式锁的竞争过程中，大量的“Watcher通知”和“子节点列表获取”两个操作重复运行，并且绝大多数的运行结果都是
判断出自己并非是序号最小的节点，从而继续等待下一次通知————这个看起来显然不怎么科学。客户端无端地接收到过多和自己并不相关的事件通知，如果在集群
规模比较大的情况下，不仅会对ZooKeeper服务器造成巨大的性能影响和网络冲击，更为严重的是，如果同一时间有多个节点对应的客户端完成事务或是事务
中断引起节点消息，ZooKeeper服务器就会在短时间内向其余客户端发送大量的事件通知————这就是所谓的羊群效应。  </p>
<p>上面这个ZooKeeper分布式共享锁实现中出现羊群效应的根源在于，没有找准客户端真正的关注点。我们再来回顾一下上面的分布式锁竞争过程，它和核心
逻辑在于：判断自己是否是所有子节点中序号最小的。于是，很容易可以联想到，每个节点对应的客户端只需要关注比自己序号小的那个相关节点的变更情况
就可以了————而不需要关注全局的子列表变更情况。</p>
<h4 id="6-改进后的分布式锁实现"><a href="#6-改进后的分布式锁实现" class="headerlink" title=".6 改进后的分布式锁实现"></a>.6 改进后的分布式锁实现</h4><p>现在我们来看看如何改进上面的分布式锁实现。首先，我们需要肯定的一点是，上面提到的共享锁实现，从整体思路上来说完全正确。这里主要的改动在于：
每个锁竞争者，只需要关注<code>/shared_lock/</code>节点下序号比自己小的那个节点是否存在即可，具体实现如下：</p>
<ol>
<li>客户端调用create()方法创建一个类似于<code>/shared_lock/[Hostname]-请求类型-序号</code>的临时顺序节点。</li>
<li>客户端调用getChildren()接口来获取所有已经创建的子节点列表，注意，这里不注册任何Watcher。</li>
<li>如果无法获取共享锁，那么就调用exist()来对比自己小的那个节点注册Watcher。注意，这里“比自己小的节点”只是一个笼统的说法，具体对于读请求和写请求不一样。<br>读请求：向比自己序号小的最后一个写请求节点注册Watcher监听。<br>写请求：向比自己序号小的最后一个节点注册Watcher监听。</li>
<li>等待Watcher通知，继续进入步骤2。</li>
</ol>
<p>流程图如下：
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-19.png" alt="" title="共享锁流程图">  </p>
<h4 id="7-注意"><a href="#7-注意" class="headerlink" title=".7 注意"></a>.7 注意</h4><p>看到这里，相信很多读者都会觉得改进后的分布式锁实现相对来说比较麻烦。确实如此，如同在多线程并发编程实践中，我们会去尽量缩小锁的范围————对于
分布式锁实现的改进其实也是同样的思路。那么对于开发人员来说，是否必须按照改进后的思路来设计实现自己的分布式锁呢？答案是否定的。在具体的实际开发
过程中，我们提倡根据具体的业务场景和集群规模来选择适合自己的分布式锁实现：在集群规模不大、网络资源丰富的情况下，第一种分布式锁实现方式是
简单实用的选择；而如果集群规模达到一定程度，并且希望能够精细化地控制分布式锁机制，那么不妨试试改进版的分布式锁实现。</p>
<h2 id="8-1-分布式队列"><a href="#8-1-分布式队列" class="headerlink" title="8.1 分布式队列"></a>8.1 分布式队列</h2><p>业界有不少分布式队列产品，不过绝大多数都是类似于ActiveMQ、Kafka等的消息中间件。在本节中，我们主要介绍基于ZooKeeper实现的分布式队列。
分布式队列，简单地讲分为两大类，一种是常规的先入先出队列，另一种则是要等到队列元素集聚之后才统一安排执行的Barrier模型。</p>
<h3 id="8-1-1-FIFO-先进先出"><a href="#8-1-1-FIFO-先进先出" class="headerlink" title="8.1.1 FIFO:先进先出"></a>8.1.1 FIFO:先进先出</h3><p>使用ZooKeeper实现FIFO队列，和共享锁的实现非常类似。FIFO队列就类似于一个全写的共享锁模型，大体的设计思想其实非常简单：所有客户端都会到
<code>/queue_fifo</code>这个节点下面创建一个临时顺序节点，例如<code>/queue_fifo/192.168.0.1-0000000001</code>，如下图：
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-20.png" alt=""><br>创建完节点之后，根据如下4个步骤来确定执行顺序。</p>
<ol>
<li>通过调用getChildren()接口来获取<code>/queue_fifo</code>节点下的所有子节点，即获取队列中所有的元素。</li>
<li>确定自己的节点序号在所有子节点中的顺序。</li>
<li>如果自己不是序号最小的子节点，那么就需要进入等待，同时向比自己序号小的最后一个节点注册Watcher监听。</li>
<li>接收到Watcher通知到，重复步骤1。</li>
</ol>
<p>整个FIFO队列的工作流程，如下图：
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-21.png" alt=""></p>
<h3 id="8-1-2-Barrier-分布式屏障"><a href="#8-1-2-Barrier-分布式屏障" class="headerlink" title="8.1.2 Barrier:分布式屏障"></a>8.1.2 Barrier:分布式屏障</h3><p>Barrier原意是指障碍物、屏障，而在分布式系统中，特指系统之间的一个协调条件，规定了一个队列的元素必须都集聚后才能统一进行安排，否则一直等待。
这往往出现在那些大规模分布式并行计算的应用场景了：最终的合并计算需要基于很多并行计算的子结果来进行。这些队列其实是FIFO队列的基础上进行了
增强，大致的设计思想如下：开始时，<code>/queue_barrier</code>节点是一个已经存在的默认节点，并且将其节点的数据内容赋值为一个数字n来代表Barrier值，
例如n=10表示只有当<code>/queue_barrier</code>节点下的子节点个数达到10后，才会打开Barrier。之后，所有的客户端都会到<code>/queue_barrier</code>节点下创建一个
临时节点，例如<code>/queue_barrier/192.168.0.1</code>，如下图：
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-22.png" alt=""><br>创建完节点之后，根据如下5个步骤来确定执行顺序。</p>
<ol>
<li>通过调用getDate()接口获取<code>/queue_barrier</code>节点的数据内容：10。</li>
<li>通过调用getChildren()接口获取<code>/queue_barrier</code>节点下的所有子节点，即获取队列中所有元素，同时注册对子节点列表变更的Watcher监听。</li>
<li>统计子节点的个数。</li>
<li>如果子节点个数还不足10个，那么就需要进入等待。</li>
<li>接收到Watcher通知后，重复步骤2。
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-23.png" alt="" title="Barrier的流程图"><br><strong>博主理解为，如果在很少的时间内，同时超过了10个以上的业务机创建了临时节点，那么业务处理的速度并不是恒定的，因为有可能这个业务被11个机器处理，
下一个被12个业务机处理？</strong></li>
</ol>
<h2 id="9-1-小结"><a href="#9-1-小结" class="headerlink" title="9.1 小结"></a>9.1 小结</h2><p>数据发布/订阅（配置中心）、负载均衡（DNS解析）、命名服务（顺序节点特性）、分布式协调/通知（Watcher机制），集群管理（子节点）、Master选举
（同时创建节点）、分布式锁（同时创建节点）、分布式队列（创建顺序节点）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-典型应用场景及实现&quot;&gt;&lt;a href=&quot;#1-典型应用场景及实现&quot; class=&quot;headerlink&quot; title=&quot;1 典型应用场景及实现&quot;&gt;&lt;/a&gt;1 典型应用场景及实现&lt;/h1&gt;&lt;h2 id=&quot;1-1-数据发布-订阅&quot;&gt;&lt;a href=&quot;#1-1-数据
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>JOIN中的ON与WHERE</title>
    <link href="http://www.liwenguang.cn/2017/08/29/SQL/MySQL/JOIN%E4%B8%AD%E7%9A%84ON%E5%92%8CWHERE/"/>
    <id>http://www.liwenguang.cn/2017/08/29/SQL/MySQL/JOIN中的ON和WHERE/</id>
    <published>2017-08-29T15:50:12.000Z</published>
    <updated>2017-08-29T16:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在给公司的CRM系统某个报表导出对接调度系统报表导出的时候出现了一个小问题，这里记录一下。  </p>
<p>缘由是这样的：因为要对接的报表导出代码历史悠久，导出的DAO层对sql的查询以及业务处理很是复杂繁琐，而且性能特别低，由于业务的复杂性（6表联合查询），
而且主表有个字段要通过主表本身查询才能得出结果，因此实际上是7表联合查询，原来的业务逻辑上，大概需要5s，原因在于多次查询数据库对数据进行改造后
再次查询数据库，最后使用拼接，输出csv文件。而现在那个页面要导出的数据变多了，大概是20W条，导致导出直接等很久，而且不支持6.5W以上的导出（EXCEL特性），
因此对接我的报表中心，其实报表中心比较简单，通过ZK实现调度，执行业务客户端的业务方法，这里主要说关于JOIN中ON和WHERE的问题。下面是最终使用的SQL:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	base.mobile,</div><div class="line">	base.card_no,</div><div class="line">	base.real_name,</div><div class="line">	base.nick_name,</div><div class="line">	grade.`name` AS grade_name,</div><div class="line">	base.sex,</div><div class="line">	base.id_card_no,</div><div class="line">	base.point,</div><div class="line">	base.source,</div><div class="line">	wx.open_id,</div><div class="line">	wx.subscribe,</div><div class="line">	mac.mac,</div><div class="line">    base.birthday,</div><div class="line">    base.bind_time,</div><div class="line">	invite.mobile AS inviter_mobile,</div><div class="line">	GROUP_CONCAT(tag_name.tag_code_name) AS tags</div><div class="line">FROM</div><div class="line">	member_base_info base</div><div class="line">LEFT JOIN  grade ON    (base.grade_code = grade.`code` AND grade.tenant_id = &apos;xx&apos;)</div><div class="line">LEFT JOIN  wx ON       (base.member_id = wx.member_id  AND wx.tenant_id = &apos;xx&apos;)</div><div class="line">LEFT JOIN  mac ON  	   (base.member_id = wx.member_id  AND mac.tenant_id = &apos;xx&apos;)</div><div class="line">LEFT JOIN  invite ON   (base.invite_mid = invite.member_id  AND invite.tenant_id = &apos;xx&apos;)</div><div class="line">LEFT JOIN  tag_code ON (base.member_id = tag_code.member_id AND tag_code.tenant_id = &apos;xx&apos;)</div><div class="line">LEFT JOIN  tag_name ON (tag_code.tag_code = tag_name.tag_code AND tag_name.tenant_id = &apos;xx&apos;)</div><div class="line">WHERE</div><div class="line">	base.tenant_id = &apos;xx&apos;</div><div class="line">GROUP BY base.id</div></pre></td></tr></table></figure></p>
<p>上面的代码在于，我在表的关联查询中，ON中的限定语句只是筛选了右边表，而左边的限定条件放在了最后的WHERE语句中，这是通过摸索三小时最后得出的结论，
<code>JOIN ON (A) WHERE B</code>，以<code>LEFT JOIN</code>为例，当A中的筛选条件有对左边的表过滤时，这个筛选条件是不起作用的。</p>
<p>以下两个表为测试表：<br>A表结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>B表结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.id = b.id <span class="keyword">AND</span> a.id = <span class="number">1</span></div><div class="line"><span class="comment">-- 上面代码的结果为：</span></div><div class="line"><span class="comment">-- | id | id1 |</span></div><div class="line"><span class="comment">-- | 1  |  1  |</span></div><div class="line"><span class="comment">-- | 2  |     |</span></div><div class="line"><span class="comment">-- | 3  |     |</span></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.id = b.id <span class="keyword">where</span> a.id = <span class="number">1</span></div><div class="line"><span class="comment">-- 上面代码的结果为：</span></div><div class="line"><span class="comment">-- | id | id1 |</span></div><div class="line"><span class="comment">-- | 1  |  1  |</span></div></pre></td></tr></table></figure>
<p>结论：</p>
<blockquote>
<p><strong><code>JOIN ON (A) WHERE B</code></strong> 中，A使用副表的过滤条件，B写主表的过滤条件。这样才能达到你的业务效果，原因在于生成中间表过程中使用的A
  条件，但是不会过滤，最后中间表生成结果会使用B条件过滤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在给公司的CRM系统某个报表导出对接调度系统报表导出的时候出现了一个小问题，这里记录一下。  &lt;/p&gt;
&lt;p&gt;缘由是这样的：因为要对接的报表导出代码历史悠久，导出的DAO层对sql的查询以及业务处理很是复杂繁琐，而且性能特别低，由于业务的复杂性（6表联合查询），
而且主
    
    </summary>
    
      <category term="SQL" scheme="http://www.liwenguang.cn/categories/SQL/"/>
    
      <category term="MySQL" scheme="http://www.liwenguang.cn/categories/SQL/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>五、课外学习Curator操作</title>
    <link href="http://www.liwenguang.cn/2017/08/28/zookeeper/5_%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0Curator%E6%93%8D%E4%BD%9C.html/"/>
    <id>http://www.liwenguang.cn/2017/08/28/zookeeper/5_课外学习Curator操作.html/</id>
    <published>2017-08-27T17:15:20.000Z</published>
    <updated>2017-08-27T17:17:30.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>五、使用Zookeeper</title>
    <link href="http://www.liwenguang.cn/2017/08/28/zookeeper/5_%E4%BD%BF%E7%94%A8Zookeeper.html/"/>
    <id>http://www.liwenguang.cn/2017/08/28/zookeeper/5_使用Zookeeper.html/</id>
    <published>2017-08-27T16:46:23.000Z</published>
    <updated>2017-08-27T17:10:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>原书本节全是关于Zookeeper的原生JavaAPI讲解，以及Curator开源框架的讲解，因此使用另外了一个专门的文章用来记录Curator的使用。
<a href="1-1">此处传送门</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原书本节全是关于Zookeeper的原生JavaAPI讲解，以及Curator开源框架的讲解，因此使用另外了一个专门的文章用来记录Curator的使用。
&lt;a href=&quot;1-1&quot;&gt;此处传送门&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>四、Zookeeper与Paxos</title>
    <link href="http://www.liwenguang.cn/2017/08/25/zookeeper/4_Zookeeper%E4%B8%8EPaxos.html/"/>
    <id>http://www.liwenguang.cn/2017/08/25/zookeeper/4_Zookeeper与Paxos.html/</id>
    <published>2017-08-25T13:15:30.000Z</published>
    <updated>2017-08-27T16:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章概要：<br>首先对ZooKeeper进行一个整体上的介绍，包括ZooKeeper的设计目标、由来以及它的基本概念，然后将会重点介绍ZAB这一ZooKeeper中非常重要的一致性协议。</p>
<h1 id="1-初识ZooKeeper"><a href="#1-初识ZooKeeper" class="headerlink" title="1. 初识ZooKeeper"></a>1. 初识ZooKeeper</h1><h2 id="1-1-ZooKeeper介绍"><a href="#1-1-ZooKeeper介绍" class="headerlink" title="1.1 ZooKeeper介绍"></a>1.1 ZooKeeper介绍</h2><p>ZooKeeper由雅虎创建，是Chubby的开源实现。设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<h3 id="1-1-1-ZooKeeper是什么"><a href="#1-1-1-ZooKeeper是什么" class="headerlink" title="1.1.1 ZooKeeper是什么"></a>1.1.1 ZooKeeper是什么</h3><p>ZooKeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举
、分布式锁和分布式队列等功能。ZooKeeper可以保证如下分布式一致性特性。</p>
<h4 id="1-顺序一致性"><a href="#1-顺序一致性" class="headerlink" title=".1 顺序一致性"></a>.1 顺序一致性</h4><p>从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到ZooKeeper中去。</p>
<h4 id="2-原子性"><a href="#2-原子性" class="headerlink" title=".2 原子性"></a>.2 原子性</h4><p>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定
不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</p>
<h4 id="3-单一视图（Single-System-Image）"><a href="#3-单一视图（Single-System-Image）" class="headerlink" title=".3 单一视图（Single System Image）"></a>.3 单一视图（Single System Image）</h4><p>无论客户端连接的是哪ZooKeeper服务器，其看到的服务端数据模型都是一致性。</p>
<h4 id="4-可靠性"><a href="#4-可靠性" class="headerlink" title=".4 可靠性"></a>.4 可靠性</h4><p>一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p>
<h4 id="5-实时性"><a href="#5-实时性" class="headerlink" title=".5 实时性"></a>.5 实时性</h4><p>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，
ZooKeeper仅仅保证在一定额时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p>
<h3 id="1-1-2-ZooKeeper的设计目标"><a href="#1-1-2-ZooKeeper的设计目标" class="headerlink" title="1.1.2 ZooKeeper的设计目标"></a>1.1.2 ZooKeeper的设计目标</h3><p>ZooKeeper致力于提供一个高性能、高可用，且具有严格的顺序访问控制能力（主要是写操作的严格顺序性）的分布式协调服务。高性能使得ZooKeeper能够应用于
那些对系统吞吐有明确要求的大型分布式系统中，高可用使得分布式的单点问题得到了很好的解决，而严格的顺序访问控制使得客户端能够基于ZooKeeper实现
一些复杂的同步原语。下面我们来具体看一下ZooKeeper的四个设计目标。</p>
<h4 id="1-目标一：简单的数据模型"><a href="#1-目标一：简单的数据模型" class="headerlink" title=".1 目标一：简单的数据模型"></a>.1 目标一：简单的数据模型</h4><p>ZooKeeper使得分布式程序能够通过一个共享的、树型结构的名字空间来进行相互协调。  </p>
<p>这里所说的树型结构的名字空间，是指ZooKeeper服务器内存中的一个数据模型，其由一系列被称为ZNode的数据节点组成，总的来说，其数据模型类似于一个文件系统，
而ZNode之间的层级关系，就像文件系统的目录结构一样。不过和传统的磁盘文件系统不同的是，ZooKeeper将全量数据存储在内存中，以此来实现提高
服务器吞吐、减少延迟的目的。</p>
<h4 id="2-目标二：可以构建集群"><a href="#2-目标二：可以构建集群" class="headerlink" title=".2 目标二：可以构建集群"></a>.2 目标二：可以构建集群</h4><p>一个ZooKeeper集群通常由一组机器组成，一般3~5台机器就可以组成一个可用的ZooKeeper集群了（2n+1）。  </p>
<p>组成ZooKeeper集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持着通信。值得一提的，只要集群中存在超过一半的机器
能够正常工作，那么整个集群就能够正常对外服务。  </p>
<p>ZooKeeper的客户端程序会选择和集群中任意一台机器共同来创建一个TCP连接，而一旦客户端和某台ZooKeeper服务器之间的连接断开后，客户端会自动连接
到集群中的其他机器。</p>
<h4 id="3-顺序访问"><a href="#3-顺序访问" class="headerlink" title=".3 顺序访问"></a>.3 顺序访问</h4><p>对于来自客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用ZooKeeper
的这个特性来实现更高层次的同步原语。</p>
<h4 id="4-高性能"><a href="#4-高性能" class="headerlink" title=".4 高性能"></a>.4 高性能</h4><p>由于ZooKeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景。</p>
<h2 id="1-2-ZooKeeper从何而来"><a href="#1-2-ZooKeeper从何而来" class="headerlink" title="1.2 ZooKeeper从何而来"></a>1.2 ZooKeeper从何而来</h2><p>ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是
这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人眼将精力集中在处理业务逻辑上。  </p>
<p>关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目），雅虎
的工程师希望给合格项目也取一个动物的名字，大家纷纷表示就叫动物园管理员吧————因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看
上去就像一个大型的动物园了，而ZooKeeper正好要用来进行分布式环境的协调————于是，ZooKeeper的名字也就由此诞生了。</p>
<h2 id="1-3-ZooKeeper的基本概念"><a href="#1-3-ZooKeeper的基本概念" class="headerlink" title="1.3 ZooKeeper的基本概念"></a>1.3 ZooKeeper的基本概念</h2><h3 id="1-3-1-集群角色"><a href="#1-3-1-集群角色" class="headerlink" title="1.3.1 集群角色"></a>1.3.1 集群角色</h3><p>通常在分布式系统中，构成一个集群的每一台机器都有自己的角色，最典型的集群模式就是Master/Slave模式（主备模式）。在这种模式下，我们把能够处理所有
写操作的机器称为Master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器称为Slave机器。  </p>
<p>而在ZooKeeper中，这些概念被颠覆了。它没有沿用传统的Master/Slave概念，而是引入了Leader、Follower和Observer三种角色。ZooKeeper集群中的所有
机器通过一个Leader选举过程来选定一台被称为“Leader”的机器，Leader服务器为客户端提供读和写服务。除Leader外，其他机器包括Follower和Observer。
Follower和Observer都能够提供读服务，唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以
在不影响写性能的情况下提升集群的读性能。  </p>
<h3 id="1-3-2-会话（Session）"><a href="#1-3-2-会话（Session）" class="headerlink" title="1.3.2 会话（Session）"></a>1.3.2 会话（Session）</h3><p>Session是指客户端会话，在讲解会话之前，我们首先来了解一下客户端连接。在ZooKeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。
ZooKeeper对外的服务端口默认是2181，客户端启动的时候，首先会服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，
通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。
Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，
只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>
<h3 id="1-3-3-数据节点（Znode）"><a href="#1-3-3-数据节点（Znode）" class="headerlink" title="1.3.3 数据节点（Znode）"></a>1.3.3 数据节点（Znode）</h3><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然后，在ZooKeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；
第二类则是指数据模型中的数据单元，我们称之为数据几点————Znode。ZooKeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree），由<code>/</code>进行分割
的路径，就是一个Znode，例如<code>/foo/path1</code>。每个Znode上都会保存自己的数据内容，同时还会保存一系列属性信息。  </p>
<p>在ZooKeeper中，Znode可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个Znode被创建了，除非主动进行Znode的移除操作，否则这个Znode将一直保存在ZooKeeper
上。临时节点生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper还允许用户为每个节点
添加一个特殊的属性：SEQUENTIAL。一旦节点被标注上这个属性，那么在这个节点被创建的时候，ZooKeeper会自动在其节点名后面追上一个整型数字，这个
整型数字是一个由父节点维护的自增数字。</p>
<h3 id="1-3-4-版本"><a href="#1-3-4-版本" class="headerlink" title="1.3.4 版本"></a>1.3.4 版本</h3><p>在前面我们已经提到，ZooKeeper的每个Znode上都会存储数据，对应于每个Znode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个Znode
的三个数据版本，分别是version（当前Znode的版本）、cversion（当前Znode字节点的版本）、aversion（当前Znode的ACL版本）。</p>
<h3 id="1-3-5-Watcher"><a href="#1-3-5-Watcher" class="headerlink" title="1.3.5 Watcher"></a>1.3.5 Watcher</h3><p>Watcher（事件监听器），是ZooKeeper中得意一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端
会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p>
<h3 id="1-3-6-ACL"><a href="#1-3-6-ACL" class="headerlink" title="1.3.6 ACL"></a>1.3.6 ACL</h3><p>ZooKeeper采用ACL（Access Control Lists）策略来进行权限控制。</p>
<ul>
<li>CREATE：创建子节点的权限。</li>
<li>READ：获取节点数据和子节点列表的权限。</li>
<li>WRITE：更新节点数据的权限。</li>
<li>DELETE：删除子节点的权限。</li>
<li>ADMIN：设置节点ACL的权限。</li>
</ul>
<p>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</p>
<h2 id="1-4-为什么选择ZooKeeper"><a href="#1-4-为什么选择ZooKeeper" class="headerlink" title="1.4 为什么选择ZooKeeper"></a>1.4 为什么选择ZooKeeper</h2><p>在解决分布式数据一致性上，除了ZooKeeper之外，目前还没有一个成熟稳定且被大规模应用的解决方案。ZooKeeper无论从性能、易用性还是稳定性上来说，
都已经达到了一个工业级产品的标准。并且开发源码、免费。</p>
<h1 id="2-ZooKeeper的ZAB协议"><a href="#2-ZooKeeper的ZAB协议" class="headerlink" title="2 ZooKeeper的ZAB协议"></a>2 ZooKeeper的ZAB协议</h1><h2 id="2-1-ZAB协议"><a href="#2-1-ZAB协议" class="headerlink" title="2.1 ZAB协议"></a>2.1 ZAB协议</h2><p>事实上，ZooKeeper并没有完全采用Paxos算法，而是使用了一种称为ZooKeeper Atomic Broadcast（ZAB，ZooKeeper原子消息广播协议）的协议作为其数据一致性的核心算法。  </p>
<p>ZAB协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。ZAB协议的开发设计人员在协议设计之初并没有要求其具有很好的扩展性，
最初只是为雅虎公司内部那些高吞吐量、低延迟、健壮、简单的分布式系统场景设计的。在ZooKeeper的官方文档也指出，ZAB协议不像Paxos算法那样，是一种
通用的分布式一致性算法，它是一种特别为ZooKeeper设计的崩溃可恢复的原子消息广播算法。  </p>
<p>在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。<strong>具体的，
ZooKeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程上去。</strong>
ZAB协议的这个主备模型架构保增乐同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的并发请求。另一方面，考虑到在分布式环境中，
顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更，例如变更C需要依赖变更A和变更B。这样的依赖关系
也对ZAB协议提出了一个要求：ZAB协议必须能够保证一个全局的变更序列被顺序应用，也就是说，ZAB协议需要保证如果一个状态变更已经被处理了，那么所有其
依赖的状态变更都应该已经被提前处理掉了。<strong>最后，考虑到主进程在任何时候都有可能出现崩溃退出或重启现象。因此，ZAB协议还需要做到在当前主进程出现上述异常情况的时候，依旧能够正常工作。</strong>  </p>
<p>ZAB协议的核心是定义了哪些会改变ZooKeeper服务器数据状态的事务请求的处理方式，即：</p>
<blockquote>
<p>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其他服务器则成为Follower服务器。
Leader服务器负责将一个客户端事务请求转换成一个事务Proposal（提议），并将该Proposal分发给集群中所有的Follower服务器。之后Leader
服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower
服务器分发Commit消息，要求其将前一个Proposal进行提交。</p>
</blockquote>
<h2 id="2-2-协议介绍"><a href="#2-2-协议介绍" class="headerlink" title="2.2 协议介绍"></a>2.2 协议介绍</h2><p>ZAB协议包括两种基本的模式，分别是崩溃恢复和消息广播。当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，
ZAB协议就会进入恢复模式并选举产生新的Leader服务器。<strong>当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，
ZAB协议就会退出恢复模式</strong>。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。  </p>
<p>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。当一台同样遵守ZAB协议的服务器启动后加入到
集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，
并与其进行数据同步，然后一起参与到消息广播流程中区。正如上文介绍所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求和处理。
Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，
那么这些非Leader服务器首先将这个事务请求转发给Leader服务器。  </p>
<p>当Leader服务器出现崩溃退出或机器重启，亦或是集群中已经不存在过半的服务器与该Leader服务器保持正常通信时，那么在重新开始新一轮的原子广播事务操作之前，
所有进程首先会使用崩溃恢复协议来使彼此达到一个一致的状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。  </p>
<p>一个机器要称为新的Leader，必须获得过半进程的支持，同时由于每个进程都有可能会崩溃，因此，在ZAB协议运行过程中，前后会出现多个Leader，并且每个进程也有可能
会多次成为Leader。进入崩溃恢复模式后，只要集群中存在过半的服务器能够彼此进行正常通信，那么就可以产生一个新的Leader并再次进入消息广播模式。
举个例子来说，一个由3台机器组成的AZB服务，通常由1个Leader、2个Follower服务器组成。某一时刻，加入其中一个Follower服务器挂了，整个ZAB是
不会中断服务的，这是因为Leader服务器依然能够获得过半机器（包括Leader自己）的支持。</p>
<h3 id="2-2-1-消息广播"><a href="#2-2-1-消息广播" class="headerlink" title="2.2.1 消息广播"></a>2.2.1 消息广播</h3><p>ZAB协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并
将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-4-1-1.png" alt="" title="消息广播流程示意图"><br>在ZAB协议的二阶段提交过程中，移除了中断逻辑，所有的Follower服务器要么正常反馈Leader提出的事务Proposal，要么就抛弃Leader服务器。同时，ZAB协议将二阶段
提交中的中断逻辑移除意味着我们可以在过半的Follower服务器已经反馈Ack之后就开始提交事务Proposal了，而不需要等待集群中所有的Follower服务器都
反馈响应。当然，<strong>在这种简化了的二阶段提交模型下，是无法处理Leader服务器崩溃退出而带来的数据不一致问题，因此在ZAB协议中添加了另一个模式，
即采用崩溃恢复模式来解决这个问题</strong>。另外，整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中
消息接收与发送的顺序性。  </p>
<p>在整个消息广播过程中，Leader服务器会为每个事务请求对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal分配一个
全局单调递增的唯一ID，我们称之为事务ID（即ZXID）。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的
先后顺序来进行排序与处理。  </p>
<p><strong>具体的，在消息广播过程中，Leader服务器会为每一个Follower服务器都各自分配一个单独的队列，然后将需要广播的事务Proposal依次放入这些队列中，并且根据FIFO
策略进行消息发送。每一个Follower服务器在接收到这个事务Proposal之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给Leader
服务器一个Ack响应。当Leader服务器接收到超过半数Follower的Ack响应后，就会广播一个Comit消息给所有的Follower服务器以通知其进行事务提交，同时Leader自身
也会完成对事务的提交，而每一个Follower服务器在接收到Commit消息后，也会完成对事务的提交。</strong></p>
<h3 id="2-2-2-崩溃恢复"><a href="#2-2-2-崩溃恢复" class="headerlink" title="2.2.2 崩溃恢复"></a>2.2.2 崩溃恢复</h3><p>一旦Leader服务器出现奔溃，或者说由于网络原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式。在ZAB协议中，为了保证程序的正确运行，
整个恢复过程后需要选举出一个新的Leader服务器。因此，AZB协议需要一个高效且可靠的Leader选举算法，从而确保能够快速地选举出新的Leader。同时，
Leader选举算法不仅仅需要让Leader自己知道其自身已经被选举为Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的Leader服务器。</p>
<h4 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title=".1 基本特性"></a>.1 基本特性</h4><p>ZAB协议规定了如果一个事务Proposal在一台机器上被处理成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。接下来我们看看在崩溃恢复过程中，
可能会出现的两个数据不一致性的隐患及针对这些情况ZAB协议所需要保证的特性。</p>
<blockquote>
<p>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。</p>
</blockquote>
<p>假设一个事务在Leader服务器上被提交了，并且已经得到过半Follower服务器的Ack反馈，但是它将Commit消息发送给所有Follower机器之前，Leader服务器挂了。
例如，在集群正常运行过程中的某一个时刻，Server1是Leader服务器，其先后广播了消息P1、P2、C1、P3、C2，其中，当Leader服务器将消息C2（Commit Of Proposal2）
发出后就立即崩溃退出了。针对这种情况，ZAB协议就需要确保事务Proposal2最终能够在所有的服务器上都被提交成功，否则将出现不一致。</p>
<blockquote>
<p>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务。</p>
</blockquote>
<p>假设初始的Leader服务器Server1在提出了一个事务Proposal3之后就崩溃退出了，从而导致集群中的其它服务器都没有收到这个事务Proposal。于是，当Server1
恢复过来再次加入到集群中的时候，ZAB协议需要确保丢弃Proposal3这个事务。  </p>
<p>结合上面的这两个崩溃恢复过程中需要处理的特殊情况，就决定了ZAB协议必须设计这样一个Leader选举算法：<strong>能够确保提交已经被Leader提交的事务Proposal，
同时丢弃已经被跳过的事务Proposal</strong>。针对这个要求，如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号（即ZXID）的事务
Proposal，那么就可以保证这个新选举出来的Leader一定具有所有已经提交的提案。更为重要的是，如果让具有最高编号事务Proposal的机器来成为Leader，就
可以省去Leader服务器检查Proposal提交和丢弃工作的这一步操作了。</p>
<h4 id="2-数据同步"><a href="#2-数据同步" class="headerlink" title=".2 数据同步"></a>.2 数据同步</h4><p>完成Leader选举之后，在正式开始工作（即接收客户端的事务请求，然后提出新的提案）之前，Leader服务器会首先确认事务日志中的所有Proposal是否都已经
被集群中过半的机器提交了，即是否完成数据同步。下面我们就来看看ZAB协议的数据同步过程。  </p>
<p>所有正常运行的服务器，要么称为Leader，要么称为Follower并和Leader保持同步。Leader服务器需要确保所有的Follower服务器能够接收每一条事务Proposal，
并且能够正确地将所有已经提交了的事务Proposal应用到内存数据中去。<strong>具体的，Leader服务器会为每一个Follower服务器都准备一个队列，并将那些没有被
各Follower服务器同步的事务以Proposal消息的形式逐个发送给Follower服务器，并在每一个Proposal消息后面紧接着再发送一个Commit消息，以表示该事务
已经被提交</strong>。等到Follower服务器将所有其尚未同步的事务Proposal都从Loeader服务器上同步过来并成功应用到本地数据库中后，Leader服务器就会将
Follower服务器加入到真正的可用Follower列表中，并开始之后的其它流程。  </p>
<p>上面讲到的是正常情况下的数据同步逻辑，下面来看ZAB协议是如何处理那些需要被丢弃的事务Proposal的。在ZAB协议的事务编号ZXID设计中，ZID是一个64位的数字，
其中低32位可以看作是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务Proposal的时候，都会对该计数器进行加1操作；
而高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader服务器，就会从这个Leader服务器上取出本地日志中最大事务Proposal的ZXID，并从
该ZXID中解析出对应的epoch值，然后再对其进行加1操作，之后就会以此编号作为新的epoch，并将低32位置0来开始生成新的ZXID。ZAB协议中的这一通过epoch编号
来区分Leader周期变化的策略，能够有效地避免不同的Leader服务器错误地使用相同的ZXID编号提出不一样的事务Proposal的异常情况，这对于识别在Leader崩溃恢复前后
生成的Proposal非常有帮助，大大简化和提升了数据恢复流程。  </p>
<p>基于这样的策略，当一个包含了上一个Leader周期尚无提交过的事务Proposal的服务器启动时，其肯定无法成为Leader，原因很简单，因为当前集群中一定包含一个Quorum集合，
该集合中的机器一定包含了更好epoch的事务Proposal，因此这台机器的事务Proposal肯定不是最高，也就无法成为Leader了。当这台机器加入到集群中，以
Follower角色连接上Leader服务器之后，Leader服务器会根据自己服务器上最后被提交的Proposal来和Follower服务器的Proposal进行比对，比对的结果
当然是Leader会要求Follower进行一个回退操作————回退到一个确实已经被集群中过半机器提交的最新的事务Proposal。（ZXID的高32位是纪元，当已经挂了
的Leader重新恢复变成Leader时，其纪元一定小于当前一直在运行的服务器，因此老的Leader就算恢复了也不会成为Leader。大清亡了，新的时代，）</p>
<h2 id="2-3-ZAB与Paxos算法的联系"><a href="#2-3-ZAB与Paxos算法的联系" class="headerlink" title="2.3 ZAB与Paxos算法的联系"></a>2.3 ZAB与Paxos算法的联系</h2><p>ZAB协议并不是Paxos算法的一个典型实现，在讲解ZAB和Paxos之间的区别之前，我们首先来看下两者的联系。</p>
<ul>
<li>两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。</li>
<li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。</li>
<li>在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，只是名字变成了Ballot。</li>
</ul>
<p>在Paxos算法中，一个新选举产生的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和所有其它进程进程通信的方式来收集上一个主进程提出
的提案，并将它们提交。第二阶段被称为写阶段，在这个阶段，当前主进程开始提出它自己的提案。在Paxos算法设计的基础上，ZAB协议额外添加了一个同步阶段。
在同步阶段之前，ZAB协议也存在一个和Paxos算法中的读阶段非常类似的过程，称为发现（Discovery）阶段。在同步阶段中，新的Leader会确保存在
过半的Follower已经提交了之前Leader周期中的所有事务Proposal。这一同步阶段的引入，能够有效地保证Leader在新的周期中提出事务Proposal之前，所有的
进程都已经完成了对之前所有事务Proposal的提交。一旦完成同步阶段后，那么ZAB就会执行和Paxos算法类似的写阶段。  </p>
<p>总的来说，ZAB协议和Paxos算法的本质区别在于，两者的设计目标不太一样。ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如ZooKeeper，
而Paxos算法则是用于构建一个分布式的一致性状态机系统。</p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>ZooKeeper的设计目标、由来以及基本概念。另外还有它的一致性协议————ZAB，并将其与Paxos算法进行了比对。  </p>
<p>ZooKeeper为了保证状态的一致性，提出了两个安全属性：</p>
<ul>
<li>全序（消息a和消息b发送的顺序Client和Server看的都是一样的），通过TCP协议的FIFO队列特性实现。</li>
<li>因果顺序（消息a先于消息b发送，则消息a先于消息b执行）。通过Leader消息先到先执行。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章概要：&lt;br&gt;首先对ZooKeeper进行一个整体上的介绍，包括ZooKeeper的设计目标、由来以及它的基本概念，然后将会重点介绍ZAB这一ZooKeeper中非常重要的一致性协议。&lt;/p&gt;
&lt;h1 id=&quot;1-初识ZooKeeper&quot;&gt;&lt;a href=&quot;#1-初识Z
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>三、Paxos的工程实践</title>
    <link href="http://www.liwenguang.cn/2017/08/22/zookeeper/3_Paxos%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5.html/"/>
    <id>http://www.liwenguang.cn/2017/08/22/zookeeper/3_Paxos的工程实践.html/</id>
    <published>2017-08-21T16:11:23.000Z</published>
    <updated>2017-08-25T13:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>前章提要：<br>主要从理论上讲解了Paxos算法，如何在保证数据一致性的情况下兼顾稳定性和性能也是一个巨大的挑战。从本章开始，我们将结合实际工程实际中的Paxos实现，
来讲解如何真正地使用Paxos算法来解决分布式一致性问题。</p>
<h1 id="1-Chubby"><a href="#1-Chubby" class="headerlink" title="1. Chubby"></a>1. Chubby</h1><p>Google Chubby是一个大名鼎鼎的分布式锁服务，GFS和Big Table等大型系统多用它来解决分布式协作、元数据存储和Master选举等一系列与分布式锁服务相关的问题。
Chubby的底层一致性实现就是以Paxos算法为基础的，这给Paxos算法的学习者提供了一个理论联系的范例，从而可以了解到Paxos算法是如何在实际工程中得到应用的。</p>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>Chubby是一个面向松耦合分布式系统的锁服务，通常用于为一个由大量小型计算机构成的松耦合分布式系统提供高可用的分布式锁服务。一个分布式锁服务的目的是
允许它的客户端进程同步彼此的操作，并对当前所处环境的基本状态信息达成一致。针对这个目的，Chubby提供了粗粒度的分布式锁服务，开发人员不需要使用复杂的同步协议。
而是直接调用Chubby的锁服务接口即可实现分布式系统中多个进程之间粗粒度的同步控制，从而保证分布式数据的一致性。  </p>
<p>Chubby的客户端接口设计非常类似于UNIX文件系统结构，应用程序通过Chubby的客户端接口，不仅能够对Chubby服务器上的整个文件进行读写操作，还能够添加对文件节点的锁控制，
并且能够订阅Chubby服务端发出的一些列文件变动的事件通知。</p>
<h2 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a>1.2 应用场景</h2><p>在Chubby的众多应用场景中，最为典型的就是集群中服务器的Master选举。例如在Google文件系统（Google File System，GFS）中使用Chubby锁服务来实现对
GFS Master服务器的选举。而在BigTable（用于结构化数据存储与管理的大型分布式存储系统）中，同样被用于Master选举，并且借助Chubby，
Master能够非常方便地的感知到其所控制的那些服务器。同时，通过Chubby，BigTable的哭护短还能够方便地定位到当前BitTable集群的Master服务器。
此外，在GFS和BigTable中，都使用Chubby来进行系统运行时元数据的存储。</p>
<h2 id="1-3-设计目标"><a href="#1-3-设计目标" class="headerlink" title="1.3 设计目标"></a>1.3 设计目标</h2><p>对于Chubby的设计，有的开发人员觉得作为Paxos算法的实现者，Chubby应该构建成一个包含Paxos算法的协议库，从而使应用程序能够便捷地使用Paxos算法。
但是，Chubby的最初设计者并没有选择这么做，而是将Chubby设计成一个需要访问中心化节点的分布式锁服务。  </p>
<p>Chubby之所以设计成这样一个完整的分布式锁服务，是因为锁服务具有以下4个传统算法库所不具有的优点。</p>
<h3 id="1-对上层应用程序的侵入性更小"><a href="#1-对上层应用程序的侵入性更小" class="headerlink" title="1. 对上层应用程序的侵入性更小"></a>1. 对上层应用程序的侵入性更小</h3><p>对于应用程序开发初期，开发人员都是从一个只需要支撑较小的负载，并且只需要保证大体可用的原型开始的，往往并没有在代码层面为分布式一致性协议的实现留有余地。
于是，集群中副本复制和Master选举等一系列提高分布式系统可用性的措施，就通过一个封装了分布式一致性协议的客户端来完成，但相比之下，
使用一个分布式锁服务的接口方式对上层应用程序的侵入性会更小。</p>
<h3 id="2-便于提供数据的发布与订阅"><a href="#2-便于提供数据的发布与订阅" class="headerlink" title="2. 便于提供数据的发布与订阅"></a>2. 便于提供数据的发布与订阅</h3><p>几乎在所有使用Chubby进行Master选举的应用场景中，都需要一种广播结果的机制，用来向所有的客户端公布当前的Master服务器。这就意味着Chubby应该
允许其客户端在服务器上进行少量数据的存储与读取————也就是对小文件的读写操作。虽然这个特性也能够通过分布式命名服务来实现，但是根据实际的经验来看，
分布式锁服务本身也非常适合提供这个功能，这一方面能够大大减少客户端依赖的外部服务，另一方面，数据的发布与订阅功能和锁服务在分布式一致性特性上是想通的。</p>
<h3 id="3-开发人员对基于锁的接口更为熟悉"><a href="#3-开发人员对基于锁的接口更为熟悉" class="headerlink" title="3. 开发人员对基于锁的接口更为熟悉"></a>3. 开发人员对基于锁的接口更为熟悉</h3><p>对于绝大部分的开发人员来说，Chubby为其提供了一套近乎和单机锁机制一致的分布式锁服务接口，比提供一个一致性协议的库来得更为友好。</p>
<h3 id="4-更便捷地构建更可靠的服务"><a href="#4-更便捷地构建更可靠的服务" class="headerlink" title="4. 更便捷地构建更可靠的服务"></a>4. 更便捷地构建更可靠的服务</h3><p>通常一个分布式一致性算法都需要使用Quorum机制来进行数据项值的选定。Quorum机制是分布式系统中实现数据一致性的一个比较特殊的策略，它指的是在
一个由若干个机器组成的急群众，在一个数据项值的选定过程中，要求急群众存在过半的机器达成一致，因此Quorum机制也被称作“过半机制”。
在Chubby中通常使用5台服务器来组成一个集群单元，根据Quorum机制，只要整个急群众有3台服务器是正常运行的，那么整个集群就可以对外提供正常的服务。
相反的，如果仅提供一个分布式一致性协议的客户端库，那么这些高可用性的系统部署都将交给开发人员自己来处理，提高了成本。</p>
<p>因此，Chubby被设计成了一个需要访问中心化节点的分布式锁服务。同时，在Chubby的设计过程中，提出了以下几个设计目标。</p>
<h3 id="1-提供一个完整的、独立的分布式锁服务，而非仅仅是一个一致性协议的客户端库："><a href="#1-提供一个完整的、独立的分布式锁服务，而非仅仅是一个一致性协议的客户端库：" class="headerlink" title="1. 提供一个完整的、独立的分布式锁服务，而非仅仅是一个一致性协议的客户端库："></a>1. 提供一个完整的、独立的分布式锁服务，而非仅仅是一个一致性协议的客户端库：</h3><p>例如，对于Master选举同时将Master信息登记并广播的场景，应用程序只需要向Chubby请求一个锁，并且在获得锁之后向相应的锁文件写入Master信息即可，
其余的客户端就可以通过读取这个锁文件来获取Master信息。</p>
<h3 id="2-提供粗粒度的锁服务"><a href="#2-提供粗粒度的锁服务" class="headerlink" title="2. 提供粗粒度的锁服务"></a>2. 提供粗粒度的锁服务</h3><p>Chubby锁服务针对的应用场景是客户端获得锁之后会进行长时间的持有（数小时或数天），而非用于短暂获取锁的场景。针对这种应用场景，当锁服务短暂失效时
（例如服务器宕机），Chubby需要保持所有锁的持有状态，以避免持有锁的客户端出现问题。这和细粒度锁的设计方式有很大的区别，细粒度锁通常设计为锁
服务一旦失效就释放所有锁，因为细粒度锁的持有时间很短，相比而言放弃锁带来的代价较小。</p>
<h3 id="3-在提供锁服务的同时提供对小文件的读写功能"><a href="#3-在提供锁服务的同时提供对小文件的读写功能" class="headerlink" title="3. 在提供锁服务的同时提供对小文件的读写功能"></a>3. 在提供锁服务的同时提供对小文件的读写功能</h3><p>Chubby提供对小文件的读写服务，以使得被选举出来的Master可以在不依赖额外服务的情况下，非常方便地向所有客户端发布自己的状态信息。具体的，
当一个客户端成功获取到一个Chubby文件锁而成为Master之后，就可以继续向这个文件里写入Master信息，其他客户端就可以通过读取这个文件得知当前的Master信息。</p>
<h3 id="4-高可用、高可靠"><a href="#4-高可用、高可靠" class="headerlink" title="4. 高可用、高可靠"></a>4. 高可用、高可靠</h3><p>在Chubby的架构设计中，允许运维人员通过部署多台机器（一般是5台机器）来组成一个Chubby集群，从而保证集群的高可用，基于Paxos算法的实现，
只要保证在3台正常运行的机器，整个集群对外服务就能保持可用。</p>
<h3 id="5-提供事件通知机制"><a href="#5-提供事件通知机制" class="headerlink" title="5. 提供事件通知机制"></a>5. 提供事件通知机制</h3><p>Chubby客户单需要实时地感知到Master的变化情况，当然这可以通过让客户端反复轮询来实现，但是在客户端规模不断增大的情况下，客户端主动轮询的实时性效果并不理想，
且对服务器性能和网络带宽压力都非常大。因此，Chubby需要由能力将服务端的数据变化情况（如文件内容变更）以事件的形式通知到所有订阅的客户端。</p>
<h2 id="1-4-Chubby技术架构"><a href="#1-4-Chubby技术架构" class="headerlink" title="1.4 Chubby技术架构"></a>1.4 Chubby技术架构</h2><h3 id="1-4-1-系统结构"><a href="#1-4-1-系统结构" class="headerlink" title="1.4.1 系统结构"></a>1.4.1 系统结构</h3><p>Chubby的整个系统结构主要由服务端和客户端两部分组成，客户端通过RPC调用与服务端进行通信<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-3-1-1.png" alt="" title="Chubby服务端与客户端结构"><br>一个典型的Chubby集群，或称为Chubby cell，通常由5台服务器组成。这些副本服务器采用Paxos协议，通过投票的方式来选举产生一个获得过半投票的
服务器作为Master。一旦某台服务器成为了Master，Chubby就会保证在一段时期内不会再有其他服务器成为Master————这段时期称为Master租期（Master lease）。
在运行过程中，Master服务器会通过不断续租的方式来延长Master租期，而如果Master服务器出现故障，那么余下的服务器就会进行新一轮的Master选举，
最终产生新的Master服务器，开始新的Master租期。  </p>
<p>集群中的每个服务器都维护着一份服务端数据库的副本，但在实际运行过程中，只有Master服务器才能对数据库进行写操作，而其它服务器都是使用Paxos协议从
Master服务器上同步数据库数据的更新。  </p>
<p>现在，我们再来看下Chubby的客户端是如何定位到Master服务器的。Chubby客户端通过向记录有Chubby服务端机器列表的DNS来请求获取所有的Chubby服务器列表，
然后逐个发起请求询问该服务器是否是Master。在这个询问过程中，那些非Master的服务器，则会将当前Master所在的服务器标识反馈给客户端，这样
客户端就能够非常快速地定位到Master服务器了。  </p>
<p>一旦客户端定位到Master服务器之后，只要该Master正常运行，那么客户端就会将所有的请求都发送到该Master服务器上。针对写请求，Chubby Master
会采用一致性协议将其广播给集群中所有的副本服务器，并且在过半的服务器接受了该写请求之后，再响应给客户端正确的应答。而对于读请求，
则不需要在集群内部进行广播处理，直接由Master服务器单独处理即可。  </p>
<p>在Chubby运行过程中，服务器难免会发生故障。如果当前的Master服务器崩溃了，那么集群中的其他服务器会在Master租期到期后，重新开启新一轮的Master
选举。通常，进行一次Master选举大概需要花费几秒钟的时间。而如果是集群中任意一台非Master服务器崩溃，那么整个集群是不会停止工作的，
这个崩溃的服务器会在恢复之后自动加入到Chubby集群中去。新加入的服务器首先需要同步Chubby最新的数据库数据，完成数据同步之后，新的服务器就可以
加入到正常的Paxos运作流程中与其它服务器副本一起协同工作。  </p>
<p>如果集群中的一个服务器发生崩溃并在几个小时后仍无法恢复正常，那么就需要加入新的机器，并同时更新DNS列表。Chubby服务器的更换方式非常简单，
只需要启动Chubby服务端程序，然后更新DNS上的机器列表（即使用新机器的IP地址替换老机器的IP地址）即可。在Chubby运行过程中，
Master服务器会周期性地轮询DNS列表因此其很快就会感知服务器地址列表的变更，然后Master就会将集群数据库中的地址列表做相应的变更，
集群内部的其他副本服务器通过复制方式就可以获取到最新的服务器地址列表了。</p>
<h3 id="1-4-2-目录与文件"><a href="#1-4-2-目录与文件" class="headerlink" title="1.4.2 目录与文件"></a>1.4.2 目录与文件</h3><p>Chubby对外提供了一套与Unix文件系统非常相近但是更简单的访问接口。Chubby的数据结构可以看作是一个由文件和目录组成的树，其中每一个节点都可以表示为一个
使用斜杠分割的字符串，典型的节点路径表示如下：</p>
<blockquote>
<p><code>/ls/foo/wombat/pouch</code><br>其中，ls是所有Chubby节点所共有的前缀，代表着锁服务，是Lock Service的缩写；foo则指定了Chubby集群的名字，从DNS可以查询到由一个或多个
服务器组成该Chubby集群；剩余部分的路径<code>wombat/pouch</code>则是一个真正包含业务含义的节点名字，由Chubby服务器内部解析并定位到数据节点。</p>
</blockquote>
<p>Chubby的命名空间，包括文件和目录，我们称之为节点（nodes，在本书后面的内容中，我们以数据节点来泛指Chubby的文件或目录）。在同一个Chubby
集群数据库中，每一个节点都是全局唯一的。和Unix系统一样，每个目录都可以包含一系列的子文件和子目录列表，而每个文件中则会包含文件内容。当然，
Chubby并非模拟一个完整的文件系统，因此没有符号链接和硬连接的概念。  </p>
<p>由于Chubby的命名结构组成了一个近似标准文件系统的视图，因此Chubby的客户端应用程序也可以通过自定义的文件系统访问接口来访问Chubby服务端数据，
比如可以使用GFS的文件系统访问接口，这就大大减少了用户使用Chubby的成本。  </p>
<p>Chubby上的每个数据节点都分为持久节点和临时节点两大类，其中持久节点需要显式地调用接口API来进行删除，而临时节点则会在其对应的客户端会话失效后被自动删除。
（zk中的EPHEMERAL）也就是说，临时节点的生命周期和客户端会话绑定，如果该临时节点对应的文件没有被任何客户端打开的话，那么它就会被删除掉。
因此，临时节点通常可以用来进行客户端会话有效性的判断依据。  </p>
<p>另外，Chubby上的每个数据节点都包含了少量的元数据信息，其中包括用于权限控制的访问控制列表（ACL）信息。同时，每个节点的元数据中还包括4个单调
递增的64编号，分别如下。</p>
<ul>
<li>实例编号：实例编号用于标识Chubby创建该数据节点的顺序，节点的创建顺序不同，其实例编号也不同，因此，通过实例编号，即使针对两个名字相同的数据节点，
客户端也能够非常方便地识别出是否是同一个数据节点————因此创建时间晚的数据节点，其实例编号必定大于任意先前创建的同名节点。</li>
<li>文件内容编号（只针对文件）：文件内容编号用于标识文件内容的变化情况，该编号会在文件内容被写入时增加。</li>
<li>锁编号：锁编号用于标识节点锁状态变更情况，该编号会在节点锁从自由（free）状态转换到被持有（held）状态时增加。</li>
<li>ACL编号：ACL编号用于标识节点的ACL信息变更情况，该编号会在节点的ACL配置信息被写入时增加。<br>同时，Chubby还会标识一个64位的文件内容校验码，以便客户端能够识别出文件是否变更。</li>
</ul>
<h3 id="1-4-3-锁与锁序列器"><a href="#1-4-3-锁与锁序列器" class="headerlink" title="1.4.3 锁与锁序列器"></a>1.4.3 锁与锁序列器</h3><p>在分布式系统中，锁是一个非常复杂的问题，由于网络通信的不确定性，导致在分布式系统中锁机制变得非常复杂，消息的延迟或是乱序都有可能会引起锁的失效。
一个典型的分布式锁错乱案例是，<strong>一个客户端C1获取到了互斥锁L，并且在锁L的保护下发出请求R，但请求R迟迟没有到达服务端（可能出现网络延时或
反复重发等），这时应用程序会认为该客户端进程已经失败，于是便会为另一个客户端C2分配锁L，然后再重新发起之前的请求R，并成功地应用到了服务器
上。此时，不幸的事情发生了，客户端C1发起的请求R在经过一波三折之后也到达了服务端，此时，它有可能会在不受任何锁控制的情况下被服务端处理，
从而覆盖了客户端C2的操作，于是导致系统数据出现不一致。</strong>当然，诸如此类消息接收顺序紊乱引起的数据不一致问题已经在人们对分布式计算的长期
研究过程中得到了很好的解决，典型的解决方案包括虚拟时间和虚拟同步。  </p>
<p>在Chubby中，任意一个数据节点都可以充当一个读写锁来使用：一种是单个客户端以排他（写）模式持有这个锁，另一种则是任意数目的客户端以共享（读）模式
持有这个锁。同时，在Chubby的锁机制中需要注意的一点是，Chubby舍弃了严格的强制锁，客户端可以在没有获取任何锁的情况下访问Chubby的文件，也就是说，
持有锁F既不是访问文件F的必要条件，也不会阻止其它客户端访问文件F。  </p>
<h4 id="1-锁延迟"><a href="#1-锁延迟" class="headerlink" title=".1 锁延迟"></a>.1 锁延迟</h4><p>在Chubby中，主要采用锁延迟和锁序列器两种策略来解决上面我们提到的由于消息延迟和重排序引起的分布式锁问题。其中锁延迟是一种比较简单的策略，
使用Chubby的应用几乎不需要进行任何的代码修改。<strong>具体的，如果一个客户端以正常的方式主动释放了一个锁，那么Chubby服务端将会允许其它客户端能够
立即获得该锁。而如果一个锁是因为客户端的异常情况（如客户端无响应）而被释放的话，那么Chubby服务器会为该锁保留一定的时间，我们称之为“锁延迟”（lock-delay）</strong>
在这段时间内，其它客户端无法获取这个锁。锁延迟措施能够很好地防止一些客户端由于网络闪断等原因而与服务器暂时断开的场景出现。总的来说，
该方案尽管不完美，但是锁延时能够有效地保护在出现消息延时情况下发生的数据不一致现象。  </p>
<h4 id="2-锁序列器"><a href="#2-锁序列器" class="headerlink" title=".2 锁序列器"></a>.2 锁序列器</h4><p>Chubby提供的另一种方式是使用锁序列器，当然该策略需要Chubby的上层应用配合在代码中加入相应的修改逻辑。<strong>任何时候，锁的持有者都可以向Chubby请求一个锁
序列器，其包括锁的名字、锁模式（排他或共享模式），以及锁序号。当客户端应用程序在进行一些需要锁机制保护的操作时，可以将该锁序列器一并发送给服务端。
Chubby服务端接收到这样的请求后，会首先检测该序列器是否有效，以及检查客户端是否处于恰当的锁模式；如果没有通过检查，那么服务端就会拒绝该客户端请求。</strong></p>
<h3 id="1-4-4-Chubby中的事件通知机制"><a href="#1-4-4-Chubby中的事件通知机制" class="headerlink" title="1.4.4 Chubby中的事件通知机制"></a>1.4.4 Chubby中的事件通知机制</h3><p>为了避免大量客户端轮询Chubby服务端状态所带来的压力，Chubby提供了事件通知机制。Chubby的客户端可以向服务端注册事件通知，当触发这些事件的时候，
服务端就会向客户端发送对应的事件通知。在Chubby的事件通知机制中，消息通知都是通过异步的方式发送给客户端的，常见的Chubby事件如下。</p>
<h4 id="1-文件内容变更"><a href="#1-文件内容变更" class="headerlink" title=".1 文件内容变更"></a>.1 文件内容变更</h4><p>例如，BigTable集群使用Chubby锁来确定集群中的哪台BitTable机器是Master；获得锁的BitTable Master会将自身信息写入Chubby上对应的文件中。
BitTable集群中的其他客户端可以通过监视这个Chubby文件的变化来确定新的BitTable Master机器。</p>
<h4 id="2-节点删除"><a href="#2-节点删除" class="headerlink" title=".2 节点删除"></a>.2 节点删除</h4><p>当Chubby上指定节点被删除的时候，会产生“节点删除”事件，这通常在临时节点中比较常见，可以利用该特性来间接判断该临时节点对应的客户端会话是否有效。</p>
<h4 id="3-子节点新增、删除"><a href="#3-子节点新增、删除" class="headerlink" title=".3 子节点新增、删除"></a>.3 子节点新增、删除</h4><p>当Chubby上指定的节点的子节点新增或是删除时，会产生“子节点新增、删除”事件。（还有更新）</p>
<h4 id="4-Master服务器转移"><a href="#4-Master服务器转移" class="headerlink" title=".4 Master服务器转移"></a>.4 Master服务器转移</h4><p>当Chubby服务器发生Master转移时，会以事件的形式通知客户端。</p>
<h3 id="1-4-5-Chubby中的缓存"><a href="#1-4-5-Chubby中的缓存" class="headerlink" title="1.4.5 Chubby中的缓存"></a>1.4.5 Chubby中的缓存</h3><p>为了提高Chubby的性能，同时也是为了减少客户端和服务端之间频繁的读请求对服务端的压力，Chubby除了提供事件通知机制之外，还在客户端中实现了缓存，
会在客户端对文件内容和元数据信息进行缓存。使用缓存机制在提高系统整体性能的同时，也为系统带来了一定的复杂性，其中最主要的问题就是应该如何保证缓存的一致性。
在Chubby中，<strong>通过租期机制来保证缓存的一致性</strong>。  </p>
<p>Chubby缓存的生命周期和Master租期机制紧密相关，Master会维护每个客户端的数据缓存情况，并通过向客户端发送过期信息的方式来保证客户端数据的一致性。
在这种机制下，Chubby就能够保证客户端要么能够从缓存中访问到一致的数据，要么访问出错，而一定不会访问到不一致的数据。<strong>具体的，每个客户端的缓存
都有一个租期，一旦该租期到期，客户端就需要向服务端续订租期以继续维持缓存的有效性。当文件数据或元数据被修改时，Chubby服务端首先会阻塞该修改操作，
然后由Master向所有可能缓存了该数据的客户端发送缓存过期信号，以使其缓存失效，等到Master在接收到所有相关客户端针对该过期信息的应答（应答包括两类，
一类是客户端明确要求更新缓存，另一类则是客户端允许缓存租期过期）后，再继续进行之前的修改操作。</strong>  </p>
<p>通过上面这个缓存机制的介绍，相信读者都已经明白了，Chubby的缓存数据保证了强一致性。尽管要保证严格的数据一致性对于性能的开销和系统的吞吐影响很大，
但由于弱一致性模式在实际使用过程中极容易出现问题，因此Chubby在设计之初就决定了强一致性模型。</p>
<h3 id="1-4-6-会话和会话激活（KeepAlive）"><a href="#1-4-6-会话和会话激活（KeepAlive）" class="headerlink" title="1.4.6 会话和会话激活（KeepAlive）"></a>1.4.6 会话和会话激活（KeepAlive）</h3><p>Chubby客户端和服务端之间通过创建一个TCP连接来进行所有的网络通信操作，我们将这一连接称为会话（Session）。会话是有生命周期的，存在一个超时时间，
在超时时间内，Chubby客户端和服务端之间可以通过心跳检测来保持会话的活性，以使会话周期得到延续，我们将这个过程称为KeepAlive（会话激活）。如果
能够成功地通过KeepAlive过程将Chubby会话一直延续下去，那么客户端创建的句柄（引用）、锁和缓存数据等都依然有效。</p>
<h3 id="1-4-7-KeepAlive请求"><a href="#1-4-7-KeepAlive请求" class="headerlink" title="1.4.7 KeepAlive请求"></a>1.4.7 KeepAlive请求</h3><p>下面我们就重点来看看Chubby Master是如何处理客户端的KeepAlive请求的。Master在接收到客户端的KeepAlive请求时，首先会将该请求阻塞住，并等到
该客户端的当前会话租期即将过期时，才为其续租该客户端的会话租期，之后再向客户端响应这个KeepAlive请求，并同时将最新的会话租期超时时间反馈给客户端。
Master对于会话续租时间的设置，默认是12秒，但这不是一个固定的值，Chubby会根据实际的运行情况，自行调节该周期的长短。举个例子来说，
如果当前Master处于高负载运行状态的话，那么Master会适当地延长会话租期的长度，以减少客户端KeepAlive请求的发送频率。客户端在接收到来自Master的续租
响应后，会立即发起一个新的KeepAlive请求，再由Master进行阻塞。因此我们可以看出，在正常运行过程中，每一个Chubby客户端总是会有一个KeepAlive
请求阻塞在Master服务器上。  </p>
<p>除了为客户端进行会话续租外，Master还将通过KeepAlive响应来传递Chubby事件通知和缓存过期通知给客户端。具体的，如果Master发现服务端已经触发了
针对该客户端的事件通知或缓存过期通知，那么会提前将KeepAlive响应反馈给客户端。</p>
<h3 id="1-4-8-会话超时"><a href="#1-4-8-会话超时" class="headerlink" title="1.4.8 会话超时"></a>1.4.8 会话超时</h3><p>谈到会话租期，Chubby的客户端也会维持一个和Master端近似相同的会话租期。为什么是近似相同呢？这是因为客户端必须考虑两方面的因素：一方面，KeepAlive
响应在网络传输过程中会花费一定的时间；另一方面，Master服务端和Chubby客户端存在时钟不一致性现象。因此在Chubby会话中，存在Master端会话租期和客户端本地
会话租期。  </p>
<p>如果Chubby客户端在运行过程中，按照本地的会话租期超时时间，检测到期会话租期已经过期却尚未接收到Master的KeepAlive响应，那么这个时候，它将无法确定Master
服务端是否已经中止了当前会话，我们称这个时候客户端处于“危险状态”。此时，Chubby客户端会清空其本地缓存，并将其标记为不可用。同时，客户端还会等待一个被
称作“宽限期”的时间周期，这个宽限期默认是45秒。如果在宽限期到期前，客户端和服务端成功地进行了KeepAlive，那么客户端就会再次开启本地缓存，否则，客户端就会
认为当前会话已经过期了，从而中止本次会话。  </p>
<p>我们再着重来看看上面提到的“危险状态”。当客户端进入上述提到的危险状态时，Chubby的客户端库会通过一个“jeopardy”事件来通知上层应用程序。如果
恢复正常，客户端同样会以一个“safe”事件来通知应用程序可以继续正常运行了。但如果客户端最终没能从危险状态中恢复过来，那么客户端会以一个“expired”
事件来通知应用程序当前Chubby会话已经超时。Chubby通过这些不同的事件类型通知，能够很好地辅助上层应用程序在不明确Chubby会话状态的情况下，
根据不同的事件类型来做出不同的处理：等待或重启。有了这样的机制保证之后，对于那些在短时间内Chubby服务不可用的场景下，客户端应用程序可以选择等待，而不是重启，
这对于那些重启整个应用程序需要花费较大代价的系统来说非常有帮助。</p>
<h3 id="1-4-9-Chubby-Master故障恢复"><a href="#1-4-9-Chubby-Master故障恢复" class="headerlink" title="1.4.9 Chubby Master故障恢复"></a>1.4.9 Chubby Master故障恢复</h3><p>Chubby的Master服务器上运行着会话租期计时器，用来管理所有会话的生命周期。如果在运行过程中Master出现了故障，那么该计时器会停止，直到新的Master选举
产生后，计时器才会继续计时，也就是说，从旧的Master崩溃到新的Master选举产生所花费的时间将不计入会话超时的计算中，这等价于延长了客户端的会话租期。
如果新的Master在短时间内就选举产生了，那么客户端就可以在本地会话租期过期前与其创建连接。而如果Master的选举花费了较长的时间，就会导致客户端只能情况本地的缓存，
并进入宽限期进行等待。从这里我们可以看出，由于宽限期的存在，使得会话能够很好地在服务端Master转换额过程中得到维持。整个Chubby Master故障恢复过程中
服务端和客户端的交互情况：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-3-1-2.png" alt="" title="Chubby Master故障恢复过程中服务端和客户端交互图"><br>展示了一个完整的Chubby服务端Master故障恢复过程中所触发的所有事件序列。在这整个故障恢复过程中，客户端必须使用宽限期来保证在Master转换过程完成之后，
其会话依然有效。  </p>
<p>一开始在旧的Master服务器上维持了会话租期“lease M1”，在客户端上维持了对应的“lease C1”，同时客户端的KeepAlive请求1一直被Master阻塞着。在一段时间之后，
Master向客户端反馈了KeepAlive响应2，同时开始了新的会话租期“lease M2”，而客户端在接收到该KeepAlive响应之后，立即发送了新的KeepAlive请求3，并
同时也开始了新的会话租期“lease C2”。至此，客户端和服务吨Master之间的所有交互都是正常的。但是随后，Master发生了故障，从而无法反馈客户端的KeepAlive
请求3。在这个过程中，客户端检测到会话租期“lease C2”已经过期，它会清空本地缓存，并进入宽限期。在这顿时间内，客户端无法确定Master上的会话周期
是否也已经过期，因此，它不会销毁它的本地会话，而是将所有应用程序对它的API调用都阻塞主，以避免在这个期间进行的API调用导致数据不一致现象。
同时，在客户端宽限期开始时，Chubby客户端会向上层应用程序发送一个“jeopardy”事件。一段时间后，CHubby服务端选举产生了新的Master，并为该客户端初始化
了新的会话租期“lease M3”。当客户端向新的Master发送KeepAlive请求4时，Master检测到该客户端的Master周期号已经过期，因此会在KeepAlive响应5
中拒绝这个客户端请求，并将最新的Master周期号发送给客户端。之后，客户端会携带上新的Master周期号，再次发送KeepAlive请求6给Master，最终，整个
客户端和服务端之间的会话就会再次恢复正常。  </p>
<p>通过上面的详细介绍，不难看出，在Master转换的这段时间内，只要客户端的宽限期是够长的，那么客户端应用程序可以在没有任何察觉的情况下，实现Chubby的故障恢复，
但如果客户端的宽限期设置得比较短，那么Chubby客户端就会丢弃当前会话，并将这个异常情况通知给上层应用程序。  </p>
<p>一旦客户端与新的Master建立上连接之后，客户端和Master之间会通过互相配合来实现对故障的平滑恢复。新的Master会设法将上一个Master服务器的内存状态构造出来。
<strong>具体的，由于本地数据库记录了每个客户端的会话信息，以及其持有的锁和临时文件等信息，因此Chubby会通过读取本地磁盘上的数据来恢复一部分状态。</strong>
总的来讲，一个新的Chubby Master服务器选举产之后，会进行如下几个主要处理。</p>
<h4 id="1-确定Master周期"><a href="#1-确定Master周期" class="headerlink" title=".1 确定Master周期"></a>.1 确定Master周期</h4><p>Master周期用来唯一标识一个Chubby集群的Master统治轮次，以便区分不同的Master。一旦新的Master周期确定下来之后，Master就会拒绝所有携带其他Master
周期编号的客户端请求，同时告知其最新的Master周期编号，例如上述提到的KeepAlive请求4。需要注意的一点是，只要发生Master重新选举，就一定会产生新的
Master周期，即使是在选举前后Master都是同一台机器的情况下也是如此。</p>
<h4 id="2-新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。"><a href="#2-新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。" class="headerlink" title=".2 新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。"></a>.2 新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。</h4><h4 id="3-Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。"><a href="#3-Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。" class="headerlink" title=".3 Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。"></a>.3 Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。</h4><h4 id="4-到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。"><a href="#4-到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。" class="headerlink" title=".4 到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。"></a>.4 到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。</h4><h4 id="5-Master会发送一个“Master故障切换”事件给每一个会话。"><a href="#5-Master会发送一个“Master故障切换”事件给每一个会话。" class="headerlink" title=".5 Master会发送一个“Master故障切换”事件给每一个会话。"></a>.5 Master会发送一个“Master故障切换”事件给每一个会话。</h4><p>客户端接收到这个事件后，会清空它的本地缓存，并警告上层应用程序可能已经丢失了别的事件，之后再向Master反馈应答。</p>
<h4 id="6-此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。"><a href="#6-此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。" class="headerlink" title=".6 此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。"></a>.6 此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。</h4><h4 id="7-在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。"><a href="#7-在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。" class="headerlink" title=".7 在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。"></a>.7 在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。</h4><h4 id="8-如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。"><a href="#8-如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。" class="headerlink" title=".8 如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。"></a>.8 如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。</h4><p>而如果该引用在之前的Master周期中已经被关闭了，那么它聚不能在这个Master周期内再次被重建了————这一机制就确保了即使由于网络原因使得Master接收到那些延迟或重发的网络数据包，
也不会错误地重建一个已经关闭的引用。</p>
<h2 id="1-5-Paxos协议实现"><a href="#1-5-Paxos协议实现" class="headerlink" title="1.5 Paxos协议实现"></a>1.5 Paxos协议实现</h2><p>Chubby服务端的基本架构大致分为三层：</p>
<ul>
<li>最底层是容错日志系统（Fault-Tolerant Log），通过Paxos算法能够保证集群中所有机器上的日志完全一致，同时具有较好的容错性。</li>
<li>日志层之上是Key-value类型的容错数据库（Fault-Tolerant DB），其通过下层的日志来保证一致性和容错性。</li>
<li>存储层之上就是Chubby对外提供的分布式锁服务和小文件存储服务。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-3-1-3.png" alt="" title="Chubby单机整体架构图"><br>Paxos算法的作用就在于保证集群内各个副本节点的日志能够保持一致。Chubby事务日志中的每一个Value对应Paxos算法中的一个Instance，由于Chubby需要对外提供
不间断的服务，因此事务日志无限增长，于是在整个Chubby巡行过程中，会存在多个Paxos Instance。同时，Chubby会为每一个Paxos Instance都按序分配一个全局唯一
的Instance编号，并将其顺序写入到事务日志中去。  </li>
</ul>
<p>在多Paxos Instance的模式下，为了提升算法执行的性能，就必须选举出一个副本节点作为Paxos算法的主节点，以避免因为每一个Paxos Instance都提出提案而陷入多个Paxos Round
并存的情况。同时，Paxos会保证在Master重启或出现故障而进行切换的时候，允许出现短暂的多个Master共存却不影响副本之间的一致性。  </p>
<p>在Paxos中，每一个Paxos Instance都需要进行一轮或多轮“Prepare-&gt;Promise-&gt;Propose-&gt;Accept”这样完整的二阶段请求过程来完成对一个提案值的选定，
而多个Instance之间是完全独立的，每个Instance可以自己决定每一个Round的序号，仅仅只需要保证在Instance内部不会出现序号重复即可。为了在保证正确性的前提下尽可能
地的提高算法运行性能，可以让多个Instance共用一套序号分配机制，并将“Prepare-&gt;Promise”合并为一个阶段，具体做法如下。</p>
<ul>
<li>当某个副本节点通过选举成为Master后，就会使用新分配的编号N来广播一个Prepare消息，该Prepare消息会被所有未达成一致的Instance和目前还未开始的Instance共用。</li>
<li><p>当Acceptor接收到Prepare消息后，必须对多个Instance同时做出回应，这通常可以通过将反馈信息封装在一个数据包中来实现。假设最多允许K个Instance同时进行提案值的选定，那么：</p>
<blockquote>
<p>当前至多存在K个未达成一致的Instance，将这些未决的Instance各自最后接收的提案值（若该提案尚未接收任何值。则使用null来代替）封装进一个数据包，并作为Promise消息返回。
同时，判断N是否大于当前Acceptor的highestPromisedNum值（当前已经接受的最大提案编号值），如果大于该值的话，那么就标记这些未决Instance和
所有未来的Instance的highestPromisedNum值为N————这样，这些未决Instance和所有未来Instance都不能再接受任何编号小于N的提案。</p>
</blockquote>
</li>
<li><p>然后Master就可以对所有未决Instance和所有未来Instance分别执行“Propose-&gt;Accept”阶段的处理。值得注意的是，如果当前Master能够一直稳定运行的话，
那么在接下来的算法运行过程中，就不再需要进行“Prepare-&gt;Promise”的处理了。但是，一但Master发现Acceptor返回了一个Reject消息，说明集群中存在另一个Master，
并且试图使用更大的编号发送了Prepare消息。碰到这种情况，当前Master就需要重新分配新的提案编号，并再次进行“Prepare-&gt;Promise”阶段的逻辑处理。</p>
</li>
</ul>
<p>利用上述改进的Paxos算法，在Master稳定运行的情况下，只需要使用同一个编号来依次执行每一个Instance的“Promise-&gt;Accept”阶段逻辑处理。在每个Instance
的运行过程中，一旦接收到多数派的Accept反馈后，就可以将对应的提案值写入本地事务日志并广播COMMIT消息给集群中的其他副本节点，其他副本节点在接收到这个COMMIT消息之后也会
将提案值写入到事务日志中。如果某个副本节点因为宕机或者网络原因没有接收到COMMIT消息，可以主动向集群中的其他副本节点进行查询。因此，我们可以看到，在Chubby的Paxos
算法的实现中，只要维持集群中存在多数派的机器能够正常运行，即使其他机器在任意时刻发生宕机，也能保证已经提交的提案的安全性。  </p>
<p>至此，我们已经实现了一套满足一致性的日志副本，在此基础上就可以在上层实现一个一致的状态机副本，即容错数据库层。初期，使用Berkeley DB作为容错数据库，
这个数据库底层实现了B树数据结构，即存储大量数据的HashMap，将每一个数据节点的节点路径名作为键，同时按照节点路径名进行排序，这就能够使得兄弟节点在排序顺序中相邻，
方便对数据节点的检索。  </p>
<p>后来，Chubby自己实现了一套更为简单的、基于日志预写和数据快照技术的底层数据复制组件。  </p>
<p><strong>数据快照和事务日志回放机制：集群中的某台机器在宕机重启以后，为了恢复状态机的状态，最简单的方法就是将已经记录的所有事务日志重新执行一遍。但这
会有一个明显的问题，就是如果机器上的事务日志已经积累了很多，那么恢复的时间就会非常长，因此需要定期对状态机数据做一个数据快照并将其存入磁盘，
然后就可以将数据快照点之前的事务日志清除。</strong>  </p>
<p>通常副本节点在进行宕机后的恢复过程中，会出现磁盘未损坏和损坏两种情况。前者最为常见，一般通过磁盘上保存的数据库快照和事务日志就可以恢复到之前某个时间点的状态，
之后再向集群中其他正常运行的副本节点索取宕机后缺失的部分数据变更记录，这样即可实现宕机后的数据恢复。另外一种则是磁盘损坏，无法直接从本地数据恢复的情况，
需要从其它副本节点索取全部的状态数据。  </p>
<p>副本节点在完成宕机重启之后，为了安全起见，不会立即参与Paxos Instance流程，而是需要等待检测到K个Paxos Instance流程陈宫完成之后才能开始参与————这样就能够保证
新分配的提案编号不会和自己以前发过的重复。  </p>
<p>最后，为了提高整个集群的性能，还有一个改进之处在于：得益于Paxos算法的容错机制，只要任意时刻保证多数派的机器能够正常运行，那么在宕机瞬间未能真正写入到
磁盘上（只有当真正调用操作系统Flush接口后，数据才能被真正写入物理磁盘中）的那一小部分事务日志也可以通过从其它正常运行的副本上复制来进行获取，因此
不需要实时地进行事务日志的Flush操作，这可以极大地提高事务写入的效率。</p>
<h2 id="1-2-Hypertable"><a href="#1-2-Hypertable" class="headerlink" title="1.2 Hypertable"></a>1.2 Hypertable</h2><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h3><p>使用C++开发的开源、高性能、可伸缩的数据库。只支持增删改查，不支持事务。</p>
<ul>
<li>支持对大量并发请求的处理。</li>
<li>支持对海量数据的管理。</li>
<li>扩展性良好，在保证可用性的前提下，能够通过随意添加集群中的机器来实现水平扩容。</li>
<li>可用性极高，具有非常好的容错性，任何节点的失效，既不会造成系统瘫痪也不会影响数据的完整性。</li>
</ul>
<h3 id="1-2-2-算法实现"><a href="#1-2-2-算法实现" class="headerlink" title="1.2.2 算法实现"></a>1.2.2 算法实现</h3><p>选举Master是根据所有服务器上事务日志的更新时间来确定哪个服务器的数据最新，那么被选举的可能性就越大。</p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>列举了使用Paxos算法的工业实践应用，更好的理解Paxos算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前章提要：&lt;br&gt;主要从理论上讲解了Paxos算法，如何在保证数据一致性的情况下兼顾稳定性和性能也是一个巨大的挑战。从本章开始，我们将结合实际工程实际中的Paxos实现，
来讲解如何真正地使用Paxos算法来解决分布式一致性问题。&lt;/p&gt;
&lt;h1 id=&quot;1-Chubby&quot;
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>二、一致性协议</title>
    <link href="http://www.liwenguang.cn/2017/08/18/zookeeper/2_%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.html/"/>
    <id>http://www.liwenguang.cn/2017/08/18/zookeeper/2_一致性协议.html/</id>
    <published>2017-08-17T16:45:23.000Z</published>
    <updated>2017-08-21T16:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>前章提要：<br>上章我们讲到分布式往往会在系统可用性和数据一致性之间反复权衡，于是就产生了一系列的一致性协议（为什么没有可用性协议？博主认为，数据才是王道）。</p>
<h1 id="1-2PC和3PC"><a href="#1-2PC和3PC" class="headerlink" title="1. 2PC和3PC"></a>1. 2PC和3PC</h1><p>在分布式系统总，每一个机器节点虽然都能够明确地知道自己在进行事务操作过程中的结果是成功或失败，但却无法直接获取到其他分布式节点的操作结果。
因此，当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的ACID特性（某个节点为单位），就需要引入一个称为“协调者（Coordinator）”
的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点被称为“参与者（Participant）”。  </p>
<p>Coordinator负责调度Participant的行为，并最终决定这些Participant是否要把事务真正的提交。基于这个思想，衍生除了二阶段提交和三阶段提交两种协议，
在本节中，我们将重点对这两种分布式事务中涉及的一致性协议进行讲解。</p>
<h2 id="1-1-2PC"><a href="#1-1-2PC" class="headerlink" title="1.1 2PC"></a>1.1 2PC</h2><p>2PC是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能保持
原子性和一致性而设计的算法。</p>
<h3 id="1-1-1-阶段一：提交事务请求"><a href="#1-1-1-阶段一：提交事务请求" class="headerlink" title="1.1.1 阶段一：提交事务请求"></a>1.1.1 阶段一：提交事务请求</h3><ol>
<li>事务询问：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交曹组，并开始等待各参与者的响应。</li>
<li>执行事务：各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。</li>
<li>各参与者向协调者反馈事务询问的响应：如果参与者成功执行了事务操作，那么反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务，
那么就反馈给协调者No响应，表示事务不可以执行。  </li>
</ol>
<p>由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投票表态过程，因此二阶段提交协议的阶段一页被称为“投票阶段”，即各参与者投票
表明是否要继续执行接下去的事务提交操作。</p>
<h3 id="1-1-2-阶段二：执行事务提交"><a href="#1-1-2-阶段二：执行事务提交" class="headerlink" title="1.1.2 阶段二：执行事务提交"></a>1.1.2 阶段二：执行事务提交</h3><p>正常情况，包含以下两种可能：</p>
<h4 id="1-可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。"><a href="#1-可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。" class="headerlink" title=".1 可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。"></a>.1 可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。</h4><h5 id="1-1-发送提交请求：协调者向所有参与者发出Commit请求。"><a href="#1-1-发送提交请求：协调者向所有参与者发出Commit请求。" class="headerlink" title=".1.1 发送提交请求：协调者向所有参与者发出Commit请求。"></a>.1.1 发送提交请求：协调者向所有参与者发出Commit请求。</h5><h5 id="1-2-事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。"><a href="#1-2-事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。" class="headerlink" title=".1.2 事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。"></a>.1.2 事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。</h5><h5 id="1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。"><a href="#1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。" class="headerlink" title=".1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。"></a>.1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。</h5><h5 id="1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。"><a href="#1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。" class="headerlink" title=".1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。"></a>.1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。</h5><h4 id="2-可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"><a href="#2-可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。" class="headerlink" title=".2 可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"></a>.2 可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</h4><h5 id="2-1-发送回滚请求：协调者向所有参与者节点发出Rollback请求。"><a href="#2-1-发送回滚请求：协调者向所有参与者节点发出Rollback请求。" class="headerlink" title=".2.1 发送回滚请求：协调者向所有参与者节点发出Rollback请求。"></a>.2.1 发送回滚请求：协调者向所有参与者节点发出Rollback请求。</h5><h5 id="2-2-事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"><a href="#2-2-事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。" class="headerlink" title=".2.2 事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"></a>.2.2 事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</h5><h5 id="2-3-反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。"><a href="#2-3-反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。" class="headerlink" title=".2.3 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。"></a>.2.3 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。</h5><h5 id="2-4-中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。"><a href="#2-4-中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。" class="headerlink" title=".2.4 中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。"></a>.2.4 中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。</h5><p>以上就是二阶段提交过程中，前后两个阶段分别进行的处理逻辑。简单地讲，二阶段提交将一个事务的处理分成了投票和执行两个阶段，其核心是对每个事务
都采用了先尝试后提交的处理方式，因此也可以将二阶段提交看作一个强一致性的算法。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-2-2-1.png" alt="" title="不同Proposer分别提出多个提案">  </p>
<h3 id="1-1-3-优缺点"><a href="#1-1-3-优缺点" class="headerlink" title="1.1.3 优缺点"></a>1.1.3 优缺点</h3><p>原理简单，实现方便；但是同步阻塞、单点问题、数据不一致、太过保守。</p>
<h4 id="1-同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，"><a href="#1-同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，" class="headerlink" title=".1 同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，"></a>.1 同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，</h4><p>将无法进行其他任何操作。</p>
<h4 id="2-单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，"><a href="#2-单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，" class="headerlink" title=".2 单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，"></a>.2 单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，</h4><p>那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。</p>
<h4 id="3-数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，"><a href="#3-数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，" class="headerlink" title=".3 数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，"></a>.3 数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，</h4><p>导致最终只有部分参与者收到了Commit请求。于是，其他没有收到Commit请求的参与者没有进行事务提交，而收到Commit请求的参与者会进行事务提交，最终数据不一致。</p>
<h4 id="4-太过保守：任何一个节点的失败都会导致整个事务的失败。"><a href="#4-太过保守：任何一个节点的失败都会导致整个事务的失败。" class="headerlink" title=".4 太过保守：任何一个节点的失败都会导致整个事务的失败。"></a>.4 太过保守：任何一个节点的失败都会导致整个事务的失败。</h4><h2 id="1-2-3PC"><a href="#1-2-3PC" class="headerlink" title="1.2 3PC"></a>1.2 3PC</h2><p>研究者在二阶段提交协议的基础上进行了改进，提出了三阶段提交协议。<br>3PC是Three-Phase Commit的缩写，将二阶段提交协议的“提交事务请求”过程分为两个，形成了CanCommit、PreCommit和DoCommit。</p>
<h3 id="1-2-1-阶段一：CanCommit"><a href="#1-2-1-阶段一：CanCommit" class="headerlink" title="1.2.1 阶段一：CanCommit"></a>1.2.1 阶段一：CanCommit</h3><h4 id="1-事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。"><a href="#1-事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。" class="headerlink" title=".1 事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。"></a>.1 事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</h4><h4 id="2-各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。"><a href="#2-各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。" class="headerlink" title=".2 各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。"></a>.2 各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。</h4><h3 id="1-2-2-阶段二：PreCommit"><a href="#1-2-2-阶段二：PreCommit" class="headerlink" title="1.2.2 阶段二：PreCommit"></a>1.2.2 阶段二：PreCommit</h3><h4 id="1-执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。"><a href="#1-执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。" class="headerlink" title=".1 执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。"></a>.1 执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。</h4><h5 id="1-1-发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。"><a href="#1-1-发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。" class="headerlink" title=".1.1 发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。"></a>.1.1 发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。</h5><h5 id="1-2-事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。"><a href="#1-2-事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。" class="headerlink" title=".1.2 事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。"></a>.1.2 事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</h5><h5 id="1-3-各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令："><a href="#1-3-各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：" class="headerlink" title=".1.3 各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令："></a>.1.3 各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：</h5><p>提交（commit）或中止（abort）。</p>
<h4 id="2-中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"><a href="#2-中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。" class="headerlink" title=".2 中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"></a>.2 中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</h4><h4 id="2-1-发送中断请求：协调者向所有参与者节点发出abort请求。"><a href="#2-1-发送中断请求：协调者向所有参与者节点发出abort请求。" class="headerlink" title=".2.1 发送中断请求：协调者向所有参与者节点发出abort请求。"></a>.2.1 发送中断请求：协调者向所有参与者节点发出abort请求。</h4><h4 id="2-2-中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。"><a href="#2-2-中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。" class="headerlink" title=".2.2 中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。"></a>.2.2 中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。</h4><h3 id="1-2-3-阶段三：DoCommit"><a href="#1-2-3-阶段三：DoCommit" class="headerlink" title="1.2.3 阶段三：DoCommit"></a>1.2.3 阶段三：DoCommit</h3><h4 id="1-可能一：执行提交"><a href="#1-可能一：执行提交" class="headerlink" title=".1 可能一：执行提交"></a>.1 可能一：执行提交</h4><h5 id="1-1-发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。"><a href="#1-1-发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。" class="headerlink" title=".1.1 发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。"></a>.1.1 发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。</h5><h5 id="1-2-事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。"><a href="#1-2-事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。" class="headerlink" title=".1.2 事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。"></a>.1.2 事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</h5><h5 id="1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。-1"><a href="#1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。-1" class="headerlink" title=".1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。"></a>.1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。</h5><h5 id="1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。-1"><a href="#1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。-1" class="headerlink" title=".1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。"></a>.1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。</h5><h4 id="2-可能二：中断事务"><a href="#2-可能二：中断事务" class="headerlink" title=".2 可能二：中断事务"></a>.2 可能二：中断事务</h4><h5 id="2-1-发送中断请求：协调者向所有参与者节点发送abort请求。"><a href="#2-1-发送中断请求：协调者向所有参与者节点发送abort请求。" class="headerlink" title=".2.1 发送中断请求：协调者向所有参与者节点发送abort请求。"></a>.2.1 发送中断请求：协调者向所有参与者节点发送abort请求。</h5><h5 id="2-2-事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"><a href="#2-2-事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。" class="headerlink" title=".2.2 事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"></a>.2.2 事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</h5><h5 id="2-3-反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。-1"><a href="#2-3-反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。-1" class="headerlink" title=".2.3 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。"></a>.2.3 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。</h5><h5 id="2-4-中断事务：协调者接收到所有参与者反馈的Ack消息后，中断事务。"><a href="#2-4-中断事务：协调者接收到所有参与者反馈的Ack消息后，中断事务。" class="headerlink" title=".2.4 中断事务：协调者接收到所有参与者反馈的Ack消息后，中断事务。"></a>.2.4 中断事务：协调者接收到所有参与者反馈的Ack消息后，中断事务。</h5><p>需要注意的是，一旦进入阶段三，可能会存在以下两种故障：</p>
<ul>
<li>协调者出现问题。</li>
<li>协调者和参与者之间的网络出现故障。
无论出现哪种情况，参与者都会在等待超时之后，继续进行事务提交。即，默认为允许提交。</li>
</ul>
<h3 id="1-2-3-优缺点"><a href="#1-2-3-优缺点" class="headerlink" title="1.2.3 优缺点"></a>1.2.3 优缺点</h3><p>降低参与者的阻塞范围，出现单点故障后继续达成一致；但是在参与者接收到PreCommit消息后，如果协调者所在的节点和参与者无法正常通信，
该参与者仍然会进行事务的提交，这必然出现数据不一致性。</p>
<h1 id="2-Paxos算法"><a href="#2-Paxos算法" class="headerlink" title="2. Paxos算法"></a>2. Paxos算法</h1><p>我们将重点讲解另一种非常重要的分布式一致性协议：Paxos。Paxos算法是一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式
一致性问题最有效的算法之一。  </p>
<p>我们现在已经知道，在常见的分布式系统中，总会发生诸如机器宕机或网络异常等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，
快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常都不会破坏整个系统的一致性。</p>
<h2 id="2-1-追本溯源"><a href="#2-1-追本溯源" class="headerlink" title="2.1 追本溯源"></a>2.1 追本溯源</h2><p>1982年，Lamport与另两人提出了一种计算容错理论。在理论描述过程中，为了将要所描述的问题形象的表达出来，Lamport设想出了下面这样一个场景：</p>
<blockquote>
<p>拜占庭帝国有许多支军队，不同军队的将军之间必须制定一个统一的行动计划，从而做出进攻或者撤退的决定，同时，各个将军在地理上都是被
分割开来的，只能依靠军队的通讯员来进行通讯。然而，在所有的通讯员中可能会存在叛徒，这些叛徒可以任意篡改消息，从而达到欺骗将军的目的。</p>
</blockquote>
<p>这就是著名的“拜占庭将军问题”。从理论上来说，在分布式计算领域，试图在异步系统和不可靠的通道上来达到一致性状态是不可能的，因此在堆一致性的研究
过程中，都往往假设信道是可靠地。而事实上，大多数系统都是部署在同一个局域网中的，因此消息被篡改的情况非常罕见，另一方面，由于硬件和网络原因而
造成的消息不完整问题，只需一套简单的校验算法即可避免——因此，在实际工程实践中，可以假设不存在拜占庭问题，也即假设所有消息都是完整的，没有被
篡改的。那么，在这种情况下需要什么样的算法来保证一致性呢？  </p>
<p>Lamport在1990年提出了一个理论上的一致性解决方案，同时给出了严格的数学证明。鉴于之前采用故事类比的方式成功的阐述了“拜占庭将军问题”，因此这次Lamport
同样用新娘库地设想除了一个场景来描述这种一致性算法需要解决的问题，及其具体的解决过程：</p>
<blockquote>
<p>在古希腊有一个叫Paxos的小岛，岛上采用议会的形式来通过法令，议会中的议员通过信使进行消息的传递。值得注意的是，议员和信使都是兼职的，
他们随时有可能会离开议会厅，并且信使可能会重复的传递消息，也可能一去不复返。因此，议会协议要保证在这种情况下法令仍然能够正确的产生， 
并且不会出现冲突。</p>
</blockquote>
<p>这就是兼职议会，而Paxos算法名称的由来也是取自提到的Paxos小岛。</p>
<h2 id="2-2-Paxos算法详解"><a href="#2-2-Paxos算法详解" class="headerlink" title="2.2 Paxos算法详解"></a>2.2 Paxos算法详解</h2><p>Paxos作为一种提高分布式系统容错性的一致性算法，一直以来总是被很多人抱怨其算法理论太难理解。</p>
<h3 id="2-2-1-问题描述："><a href="#2-2-1-问题描述：" class="headerlink" title="2.2.1 问题描述："></a>2.2.1 问题描述：</h3><p> 假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：</p>
<ul>
<li>在这些被提出的提案中，只有一个会被选中。</li>
<li>如果没有提案被提出，那么就不会有被选定的提案。</li>
<li><p>当一个提案被选定后，进程应该可以获取被选定的提案信息。</p>
<p>对于一致性来说，安全性需求如下：</p>
</li>
<li>只有被提出的提案才能被选定。</li>
<li>只能由一个值被选定。</li>
<li><p>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个。</p>
<p>在对Paxos算法的讲解过程中，我们不去精确地定义其活性需求，从整体上来说，Paxos算法的目标就是要保证最终有一个提案会被选定，当提案被选定后，
进程最终也能获取到被选定的提案。  </p>
<p>在该一致性算法中，有三种参与角色，我们用Proposer、Acceptor、Learner来表示，在具体的实现中，一个进程可能充当不止一种角色，在这里我们并
不关心进程如何映射到各种角色。假设不同参与者之间可以通过收发消息来进行通信，那么：</p>
</li>
<li>每个参与者以任意的速度执行，可能会因为出错而停止，也可能会重启。同时，即使一个提案被选定后，所有的参与者也都有可能失败或重启，因此除非
哪些失败或重启的参与者可以记录某些信息，否则将无法确定最终的值。</li>
<li>消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏。<h3 id="2-2-2-提案的选定"><a href="#2-2-2-提案的选定" class="headerlink" title="2.2.2 提案的选定"></a>2.2.2 提案的选定</h3>要选定一个唯一提案的最简单方式莫过于只允许一个Accpetor存在，这样的话，Proposer只能发送提案给该Accpetor，Acceptor会选择它接收到的第一个
提案作为被选定的提案。这种解决方式尽管实现起来非常简单，但是却很难让人满意，因为一旦这个Accpetor出现问题，那么整个系统就无法工作了。  </li>
</ul>
<p>因此，应该寻找一种更好的解决方式，例如可以使用多个Acceptor来避免Accpetor的单点问题。现在我们就来看看，在存在多个Acceptor的情况下，如何
进行提案的选取：Proposer向一个Acceptor集合发送提案，同样，集合中的每个Acceptor都可能会批准该提案，当有足够多的Acceptor批准这个提案的时候，
我们就可以认为该提案被选定了。那么，什么是足够多呢？我们假定足够多的Acceptor是整个Acceptor集合的一个子集，并且让这个集合大得可以包含Acceptor
集合中的大多数成员，因为任意炼哥包含大多数Acceptor的子集至少有一个公共成员。另外我们再规定，每一个Acceptor最多只能批准一个提案，那么就能
保证只有一个提案被选定了。</p>
<h3 id="2-2-3-推导过程"><a href="#2-2-3-推导过程" class="headerlink" title="2.2.3 推导过程"></a>2.2.3 推导过程</h3><p>在没有失败和消息丢失的情况下，如果我们希望即使在只有一个提案被提出的情况下，仍然可以选出一个提案，这就暗示了如下的需求。</p>
<blockquote>
<p>P1：一个Acceptor必须批准它收到的第一个提案。</p>
</blockquote>
<p>上面这个需求就引出了另外一个问题：如果有多个提案被不同的Proposer同时提出，这可能会导致虽然每个Acceptor都批准了它收到的第一个提案，但是没有一个
提案是由多数人批准的。可能会现以下两种情况<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-2-2-1.png" alt="" title="不同Proposer分别提出多个提案"><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-2-2-2.png" alt="" title="任意一个Acceptor出现问题"><br>Acceptor接收的提案数量相同，此时无法选定最终的提案了。<br>因此，在P1的基础上，需要再加上一个提案被选定需要由半数以上的Acceptor批准的需求暗示着一个Acceptor必须能够批准不止一个提案。在这里，我们使用一个全局的编号
（这种全局唯一编号的生成并不是Paxos算法需要关注的地方，就算法本身而言，其假设当前已经具备这样的外部组件能够生成一个全局唯一的编号）来标识每一个
被Acceptor批准的提案，当一个具有某Value值的提案被半数以上的Acceptor批准后，我们就认为该Value被选定了，此时我们也认为该提案被选定了。需要注意的是，
此处讲到的提案和Value不是同一个概念了，提案变成了由编号和Value组成的组合体，因此我们以“[编号，Value]”来表示一个提案。（编号多少的提案被选中了，其中value是多少）
根据上面讲到的内容，我们虽然允许多个提案被选定，但同时必须保证所有被选定的提案都具有相同的Value值——这是一个关于提案Value的约定，结合提案
的编号，该约定可以定义如下：</p>
<blockquote>
<p>P2：如果编号为M0、Value值为V0的提案（即[M0、V0]）被选定了，那么所有比编号M0更高的，且被选定的提案，其Value值必须也是V0。</p>
</blockquote>
<p>因为提案的编号是全序的，条件P2就保证了只有一个Value值被选定这一关键安全性属性。同时，一个提案要被选定，其首先必须至少一个Acceptor批准，因此
我们可以通过满足如下条件来满足P2。</p>
<blockquote>
<p>P2a：如果编号为M0、Value值为V0的提案（即[M0、V0]）被选定了，那么所有比编号M0更高的，且被Acceptor批准的提案，其Value值必须也是V0。</p>
</blockquote>
<p>至此，我们仍然需要P1来保证提案会被选定，但是因为通信是异步的，一个提案可能在某个Acceptor还未收到任何提案时就被选定了。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-2-2-3.png" alt="" title="任意一个Acceptor出现问题"><br>如上图，在Acceptor1没有接收到任何提案的情况下，其他4个Acceptor已经批准了来自Proposer2的提案[M0,V1]，而此时，Proposer1产生了一个具有其他Value值的、
编号更高的提案[M1,V2]，并发送给了Acceptor1。根据P1，就需要Acceptor1批准该提案，但是这与P2a矛盾，因此如果要同时满足P1和P2a，需要对P2a进行如下强化：</p>
<blockquote>
<p>P2b：如果一个提案[M0,V0]被选定后，那么之后任何Proposer产生的编号的提案，其Value值都为V0。</p>
</blockquote>
<p>因为一个提案必须在被Proposer提出后才能被Acceptor批准，因此P2b包含了P2a，进而包含了P2。于是，接下去的重点就是论证P2b成立即可：</p>
<blockquote>
<p>假设某个提案[M0,V0]已经被选定了，证明任何编号Mn &gt; M0的提案，其Value值都是V0。</p>
</blockquote>
<h3 id="2-2-4-数学归纳法证明"><a href="#2-2-4-数学归纳法证明" class="headerlink" title="2.2.4 数学归纳法证明"></a>2.2.4 数学归纳法证明</h3><p>略过。</p>
<h3 id="2-2-5-Proposer生成提案"><a href="#2-2-5-Proposer生成提案" class="headerlink" title="2.2.5 Proposer生成提案"></a>2.2.5 Proposer生成提案</h3><p>对于一个Proposer来说，获取哪些已经被通过的提案远比预测未来可能会被通过的提案来得简单。因此，Proposer在产生一个编号为Mn的提案时，
必须要知道当前某一个将要或已经被半数以上Acceptor批准的、编号小于Mn但为最大编号的提案。并且，Proposer会要求所有的Acceptor都不要
再批准任何编号小于Mn的提案——这就引出了如下的提案生成算法。</p>
<h4 id="1-Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应。"><a href="#1-Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应。" class="headerlink" title=".1 Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应。"></a>.1 Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应。</h4><ul>
<li>向Proposer承诺，保证不再批准任何编号小于Mn的提案。</li>
<li>如果Acceptor已经批准过任何提案，那么其就向Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值。</li>
</ul>
<p>我们将该请求称为编号为Mn的提案的Prepare请求。</p>
<h4 id="2-如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn、Value值的Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。"><a href="#2-如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn、Value值的Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。" class="headerlink" title=".2 如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn、Value值的Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。"></a>.2 如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn、Value值的Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。</h4><p>当然还存在另一种情况，就是半数以上的Acceptor都没有批准过任何提案，即响应不包含任何的提案，那么此时Vn值就可以
由Proposer任意选择。</p>
<p>在确定提案之后，Proposer就会将该提案再次发送给某个Acceptor集合，并期望获得它们的批准，我们称此请求为Accept请求。需要注意的一点是，
此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合——这点相信读者也能够明白，任意两个半数以上的Acceptor集合，必定
包含至少一个公共Acceptor。</p>
<h3 id="2-2-6-Acceptor批准提案"><a href="#2-2-6-Acceptor批准提案" class="headerlink" title="2.2.6 Acceptor批准提案"></a>2.2.6 Acceptor批准提案</h3><p>在上文中，我们已经讲解了Paxos算法中Proposer的处理逻辑，下面我们来看看Acceptor是如何批准提案的。  </p>
<p>根据上面的内容，一个Acceptor可能会收到来自Proposer的两种请求，分别是Prepare请求和Accept请求，对这两类请求做出相应的条件分别如下。</p>
<ul>
<li>Prepare请求：Acceptor可以在任何时候响应一个Prepare请求。</li>
<li>Accept请求：在不违背Accept现有承诺的前提下，可以任意响应Accept请求。因此，对Acceptor逻辑处理的约束条件，大体可以定义如下。<blockquote>
<p>P1a：一个Acceptor只要尚未响应过任何编号大于Mn的prepare请求，那么它就可以接受这个编号为Mn的提案。</p>
</blockquote>
</li>
</ul>
<p>从上面这个约束条件中，我们可以看出，P1a包含了P1。同时，值得一提的是，Paxos算法允许Acceptor忽略任何请求而不用担心破坏其算法的安全性。</p>
<h3 id="2-2-7-算法优化"><a href="#2-2-7-算法优化" class="headerlink" title="2.2.7 算法优化"></a>2.2.7 算法优化</h3><p>在上面的内容中，我们分别从Proposer和Acceptor对提案的生成和批准两方面来讲解了Paxos算法在提案选定过程中的算法细节，同时也在提案的编号全局唯一
的前提下，获得了一个满足安全性需求的提案选定算法，接下来我们再对这个初步算法做一个小优化。尽可能地忽略Prepare请求：</p>
<blockquote>
<p>假设一个Acceptor收到了一个编号为Mn的prepare请求，但此时该Acceptor已经对编号大于Mn的prepare请求做出了响应，因此它肯定不会再批准
任何新的编号为Mn的提案，那么狠显然，Acceptor就没有必要对这个Prepare请求做出响应，于是Acceptor可以炫册忽略这样的Prepare请求。同时
Acceptor也可以忽略掉那些它已经批准过的提案的Prepare请求。</p>
</blockquote>
<p>通过这个优化，每个Acceptor只需要记住它已经批准的提案的最大编号以及它已经做出Prepare请求响应的提案的最大编号，以便在出现故障或节点重启的情况下，
也能保证P2c的不变性。而对于Proposer来说，只要它可以保证不会产生具有相同编号的提案，那么就可以丢弃任意的提案以及它所有的运行时状态信息。</p>
<h3 id="2-2-8-算法陈述"><a href="#2-2-8-算法陈述" class="headerlink" title="2.2.8 算法陈述"></a>2.2.8 算法陈述</h3><h4 id="1-阶段一："><a href="#1-阶段一：" class="headerlink" title=".1 阶段一："></a>.1 阶段一：</h4><ol>
<li>Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。</li>
<li>如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案
作为响应反馈给Proposer，同时Acceptor会承诺不会再批准任何编号小于Mn的提案。  <blockquote>
<p>举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1、2、…、5和7，那么该Acceptor在接收到一个编号为8的
Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。</p>
</blockquote>
</li>
</ol>
<h4 id="2-阶段二："><a href="#2-阶段二：" class="headerlink" title=".2 阶段二："></a>.2 阶段二：</h4><ol>
<li>如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn，Vn]提案的Accept请求给Acceptor。
注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。</li>
<li>如果Acceptor收到这个针对[Mn，Vn]提案的Accep请求，只要改Acceptor尚未对编号大于Mn的Prepare请求做出响应，它就可以通过这个提案。</li>
</ol>
<p>当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如上所述的算法运行，就一定能够保证算法执行的正确性。
值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证
其在提案选定上的正确性，事实上，如果某个Proposer已经在试图 生成编号更大的提案，那么丢弃一些旧的提案未尝不是一个好的选择。
因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，
以便该Proposer也能够将该提案进行丢弃——这和上面“算法优化”部分中提到的提案丢弃是一致的。</p>
<h3 id="2-2-9-提案的获取"><a href="#2-2-9-提案的获取" class="headerlink" title="2.2.9 提案的获取"></a>2.2.9 提案的获取</h3><p>在上文中，我们已经介绍了如何来选定一个提案，下面我们再来看看如何让Learner获取提案，大体可以有以下几种方案。</p>
<h4 id="1-方案一："><a href="#1-方案一：" class="headerlink" title=".1 方案一："></a>.1 方案一：</h4><p>Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该
提案发送给所有的Learner。<br>很显然，这种做法虽然可以让Learner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Learner逐个进行一次通信，通信的次数至少为二者个数的乘积。  </p>
<h4 id="2-方案二："><a href="#2-方案二：" class="headerlink" title=".2 方案二："></a>.2 方案二：</h4><p>另一种可行的方案是，我们可以让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner（下文中我们将这样的Learner称为“主Learner”），
在不考虑拜占庭奖金问题的前提下，我们假定Learner之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主learner被通知一个提案
已经被选定时，它会负责通知其它的Learner。  </p>
<p>在这种方案中，Acceptor首先会将得到批准的提案发送给主Learner，再由其同步给其他Learner，因此较方案一而言，方案二虽然需要多一个步骤才能将
提案通知到所有的Learner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。  </p>
<h4 id="3-方案三："><a href="#3-方案三：" class="headerlink" title=".3 方案三："></a>.3 方案三：</h4><p>在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大，
即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。
这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。</p>
<h3 id="2-2-10-通过选取主Proposer保证算法的活性"><a href="#2-2-10-通过选取主Proposer保证算法的活性" class="headerlink" title="2.2.10 通过选取主Proposer保证算法的活性"></a>2.2.10 通过选取主Proposer保证算法的活性</h3><p>根据前面的内容坚决，我们已经基本了解Paxos算法的核心逻辑，下面我们再来看看Paxos算法在实际运作过程中的一些细节。假设存在这样一种极端情况，
有两个Proposer依次提出了一系列编号递增的议案，但是最终都无法被选定，具体流程如下：</p>
<blockquote>
<p>Proposer P1提出了一个编号为M1的提案，并完成了上述阶段一的流程。但与此同时，另外一个Propoesr P2提出了一个编号为M2的提案，同样也完成了
阶段一的流程，于是Acceptor已经承诺不再批准编号小于M2的提案了。因此，当P1进入阶段二的时候，其发出的Accept请求将被Acceptor忽略，
于是P1再次进入阶段一并提出了一个编号为M3的提案，而这又导致P2在第二阶段的Accept请求被忽略，以此类推，提案的选定过程将陷入死循环。</p>
</blockquote>
<p>为了保证Paxos算法流程的可持续性，以避免陷入上述提到的“死循环”，就必须选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，
只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准。当然，如果Proposer发现当前
算法流程中已经有一个编号更大的提案被提出或正在接受批准，那么它会丢弃当前这个编号较小的提案，并最终能够选出一个编号足够大的提案。因此，
如果系统中有足够多的组件（包括Propsoer、Acceptor和其他网络通信组件）能够正常工作，那么通过选择一个主Proposer，整套Paxos算法流程就能够保持活性。</p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>2PC和3PC：1.牧师分别问新郎和新娘：你是否愿意……不管生老病死……（投票阶段）。<br>2.当新郎和新娘都回答愿意后（锁定一生的资源，只要有一个没有反应，这场结婚就失败）。（投票阶段）<br>3.牧师就会说：我宣布你们……（执行阶段）。<br>存在的问题：1.阻塞问题：如果新郎回答原意，新娘没反应，则整个结婚就阻塞。（投票阶段之后增加眼神交流阶段（3PC的额外阶段），之后才真正承诺一生一世不分离即锁定资源）。<br>2.单点问题：如果牧师没反应，整个结婚就失败。（3PC的超时机制，给牧师5秒反应时间）  </p>
<p>主要从协议设计和原理实现角度详细讲解了二阶段提交协议、三阶段提交协议和Paxos这三种典型的一致性算法。其中二阶段提交协议解决了分布式事务的原子性问题，
保证了分布式事务的多个参与者要么都执行成功，要么都执行失败。但是，在二阶段解决部分分布式事务问题的同时，依然存在一些难以解决的诸如同步阻塞、
无限期等待问题。三阶段提交协议则是在二阶段提交协议的基础上，添加了PreCommit过程，从而避免了二阶段提交协议中的无限期等待问题。而Paxos算法支持
分布式节点角色之间的轮换，这极大地避免了分布式单点的出现，因此Paxos算法既解决了无限期等待问题，是目前来说最优秀的分布式一致性协议之一。<br><a href="http://video.tudou.com/v/XMTc4NjM4Nzc1Mg==.html" target="_blank" rel="external">传送门，视频30分钟讲解paxos的演变</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前章提要：&lt;br&gt;上章我们讲到分布式往往会在系统可用性和数据一致性之间反复权衡，于是就产生了一系列的一致性协议（为什么没有可用性协议？博主认为，数据才是王道）。&lt;/p&gt;
&lt;h1 id=&quot;1-2PC和3PC&quot;&gt;&lt;a href=&quot;#1-2PC和3PC&quot; class=&quot;heade
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>一、分布式架构</title>
    <link href="http://www.liwenguang.cn/2017/08/17/zookeeper/1_%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84.html/"/>
    <id>http://www.liwenguang.cn/2017/08/17/zookeeper/1_分布式架构.html/</id>
    <published>2017-08-17T04:52:20.000Z</published>
    <updated>2017-08-17T15:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-从集中式到分布式"><a href="#1-从集中式到分布式" class="headerlink" title="1. 从集中式到分布式"></a>1. 从集中式到分布式</h1><h2 id="1-1-集中式的特点"><a href="#1-1-集中式的特点" class="headerlink" title="1.1 集中式的特点"></a>1.1 集中式的特点</h2><p>所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点，并且整个系统的所有业务单元都部署在这个中心节点上，
系统的所有功能均由其集中处理。也就是说，在集中式系统中，每个终端或客户端机器仅仅负责数据的录入和输出，而数据的存储与控制处理完全
交由主机来完成。  </p>
<p>最大的特点就是部署结构简单。由于集中式系统往往基于底层性能卓越的大型主机，因此无须考虑如何对服务进行多个节点的部署，也就不用考虑多个
节点之间的分布式协作问题。</p>
<h2 id="1-2-分布式的特点"><a href="#1-2-分布式的特点" class="headerlink" title="1.2 分布式的特点"></a>1.2 分布式的特点</h2><blockquote>
<p>分布式系统是一个硬件或者软件组成分布在不同的网络计算上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</blockquote>
<p>一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，都会有如下几个特征：</p>
<ul>
<li>分布性：分布式系统中的多台计算机在空间上随意分布。</li>
<li>对等性：分布式系统中的计算机没有主/从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。
副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务，
我们往往会对数据和服务进行副本处理。不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取到该数据，另一类副本是
服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。</li>
<li>并发性：同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等，如何准确并高效地协调分布式并发操作也成为了分布式
系统架构与设计中最大的挑战之一。</li>
<li>缺乏全局时钟：一个典型的分布式系统是由一系列在空间上随意分布的多个进程组成的，具有明显的分布性，这些进程之间通过交换下次来进行相互通信。
因此，在分布式系统中，很难定义两个时间的顺序，原因就是因为分布式系统缺乏一个全局的时钟序列控制。</li>
<li>故障总是会发生：组成分布式系统的所有计算机，都有可能发生任何形式的故障。任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发生！</li>
</ul>
<h2 id="1-3-分布式环境的各种问题"><a href="#1-3-分布式环境的各种问题" class="headerlink" title="1.3 分布式环境的各种问题"></a>1.3 分布式环境的各种问题</h2><h3 id="1-3-1-通信异常"><a href="#1-3-1-通信异常" class="headerlink" title="1.3.1 通信异常"></a>1.3.1 通信异常</h3><p>分布式引入了网络因素，而由于网络本身的不可靠性，因此每次网络通信都会伴随网络不可用的风险，网络光纤、路由器和DNS等。因此消息丢失和消息延迟变得非常普遍。</p>
<h3 id="1-3-2-网络分区"><a href="#1-3-2-网络分区" class="headerlink" title="1.3.2 网络分区"></a>1.3.2 网络分区</h3><p>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信，
而另一些节点则不能——我们将这个现象称为网络分区。网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本
需要整个分布式系统才能完成的功能，包括对数据的事务处理，这就对<strong>分布式一致性提出了非常大的挑战</strong>（某个复杂业务原本需要多个机器完成，现在被一个机器
执行）。</p>
<h3 id="1-3-3-三态"><a href="#1-3-3-三态" class="headerlink" title="1.3.3 三态"></a>1.3.3 三态</h3><p>分布式系统的每一次请求与响应，存在特有的“三态”概念，即成功、失败与超时。超时的现象，通常有以下两种情况：</p>
<ul>
<li>由于网络原因，请求并没有被成功地发送到接收方，在发送过程就发生了消息丢失现象。</li>
<li>请求成功的被接收方接收后，并进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象。（rabitMQ的解决方案是，消费者（接收方）开始处理消息前发送响应A，
消费者（接收方）处理完成消息后发送响应B，生产者（发送方）必须得到AB两个响应才能确定消息成功被处理了）</li>
</ul>
<h1 id="2-从ACID到CAP-BASE"><a href="#2-从ACID到CAP-BASE" class="headerlink" title="2. 从ACID到CAP/BASE"></a>2. 从ACID到CAP/BASE</h1><h2 id="2-1-ACID"><a href="#2-1-ACID" class="headerlink" title="2.1 ACID"></a>2.1 ACID</h2><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元（Unit）。</p>
<h3 id="2-1-1-原子性（Atomicity）"><a href="#2-1-1-原子性（Atomicity）" class="headerlink" title="2.1.1 原子性（Atomicity）"></a>2.1.1 原子性（Atomicity）</h3><p>要么全部成功执行，要么全部不执行。</p>
<h3 id="2-1-2-一致性（Consistency）"><a href="#2-1-2-一致性（Consistency）" class="headerlink" title="2.1.2 一致性（Consistency）"></a>2.1.2 一致性（Consistency）</h3><p>事务的运行被迫中断时，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于不一致的状态。</p>
<h3 id="2-1-3-隔离性（Isolation）"><a href="#2-1-3-隔离性（Isolation）" class="headerlink" title="2.1.3 隔离性（Isolation）"></a>2.1.3 隔离性（Isolation）</h3><p>并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。SQL规范定义了4个事务隔离级别：</p>
<ul>
<li>读未提交（Read Uncommitted）：A事务更新过程中，从1更新到10，B事务能获取过程中间值，获取到2，3等值。（脏读）</li>
<li>读已提交（Read Committed）：A事务更新过程中，从1更新到10，B事务只能获取最终的值10。</li>
<li>可重复读（Repeatable Read）：A事务更新过程中，从1更新到10，B事务先获取了1，后来B事务中有个操作重新获取了一次值为10。（幻影读）</li>
<li>串行化（Serializable）：事务只能串行执行，不能并发。</li>
</ul>
<h3 id="2-1-4-持久性（Durability）"><a href="#2-1-4-持久性（Durability）" class="headerlink" title="2.1.4 持久性（Durability）"></a>2.1.4 持久性（Durability）</h3><p>事务一旦提交，对数据库对应数据的状态变更就应该被永久保存下来。</p>
<h2 id="2-1-分布式事务"><a href="#2-1-分布式事务" class="headerlink" title="2.1 分布式事务"></a>2.1 分布式事务</h2><p>设想一个最典型的分布式事务场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务，另一个则是目标银行提供的存款
服务，这两个服务本身是无状态并且是互相独立的，共同构成了一个完整的分布式事务。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么
就必须回滚到取款前的状态，否则用户可能会发现自己的钱不翼而飞了。  </p>
<p>我们可以看到，一个分布式事务可以看作是由多个分布式的操作序列组成的，例如上面例子中的取款服务和存款服务，通常可以把这一系列分布式的操作序列称为
子事务。因为，分布式事务也可以被定义为一种嵌套型的事务，同时也就具有了ACID事务特性。但由于在分布式事务中，各个子事务的执行时分布式的，
因此要实现一种能够保证ACID特性的分布式事务处理系统就显得格外复杂。</p>
<h2 id="2-3-CAP和BASE理论"><a href="#2-3-CAP和BASE理论" class="headerlink" title="2.3 CAP和BASE理论"></a>2.3 CAP和BASE理论</h2><p>ACID是属于单机系统的理论，分布式有属于自己的理论，即CAP和BASE。</p>
<h3 id="2-3-1-CAP定理"><a href="#2-3-1-CAP定理" class="headerlink" title="2.3.1 CAP定理"></a>2.3.1 CAP定理</h3><p>一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）这三个基本需求，最多只能同时
满足其中的两项。</p>
<h4 id="1-Consistency"><a href="#1-Consistency" class="headerlink" title=".1 Consistency"></a>.1 Consistency</h4><p>在分布式环境下，数据在多个副本之间是否能够保持一致性，当某个副本执行更新操作后，应该保证系统的数据仍然处于一致的状态。如果做到一个数据项的更新
操作执行成功后，所有的用户都可以读取到最新的值，那么这样的系统就被认为具有强一致性。</p>
<h4 id="2-Availability"><a href="#2-Availability" class="headerlink" title=".2 Availability"></a>.2 Availability</h4><p>对于用户的每一个操作请求总是能够在有限的时间内返回结果。划重点：<strong>有限的时间内、返回结果</strong>。</p>
<ul>
<li>有限的时间内：对于用户的一个艹做请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。
比如，对于一个在线搜索引擎来说，通常在0.5秒内需要给出用户搜索关键词对应的检索结果，而对于一个面向HIVE的海量数据查询平台来说，正常一次数据
检索时间可能在20秒，这是正常的，系统必须存在一个合理的响应时间。</li>
<li>返回结果：要求系统在完成堆用户请求的处理后，返回一个正常的结果，而不是返回系统错误。</li>
</ul>
<h4 id="3-Partition-tolerance"><a href="#3-Partition-tolerance" class="headerlink" title=".3 Partition tolerance"></a>.3 Partition tolerance</h4><p>分布式系统在遇到任何网络分区故障的时候（节点间的故障），仍然需要保证对外提供满足一致性和可用性的服务，除非整个网络环境发生了故障。</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title=".4 总结"></a>.4 总结</h4><ul>
<li>AC：所有的数据都放在一个分布式节点上。（谈什么分布式？）</li>
<li>PC：系统正在维修，请等待。（要么可用，要么直接不能访问）</li>
<li>AP：放弃数据的强一致性，保留数据额最终一致性。（双11xx商品正在被5126人浏览，可能每个人看到的数字都不一样，但是系统最终会让所有人看到一样的数字）</li>
</ul>
<h3 id="2-3-2-BASE理论"><a href="#2-3-2-BASE理论" class="headerlink" title="2.3.2 BASE理论"></a>2.3.2 BASE理论</h3><p>基于CAP定理结合实际演化而来，即Basically Available（基本可用）、Soft state（软状态）、Eventually consistency（最终一致性）。</p>
<h4 id="1-Basically-Available"><a href="#1-Basically-Available" class="headerlink" title=".1 Basically Available"></a>.1 Basically Available</h4><p>分布式在出现不可预知故障的时候，允许损失部分可用性：</p>
<ul>
<li>响应时间上的损失：搜索正常是0.5秒返回用户，出现故障变成2秒。</li>
<li>功能上的损失：网上购物在双11时选择购买可能会跳转到排队页面。</li>
</ul>
<h4 id="2-Soft-state"><a href="#2-Soft-state" class="headerlink" title=".2 Soft state"></a>.2 Soft state</h4><p>允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h4 id="3-Eventually-consistency"><a href="#3-Eventually-consistency" class="headerlink" title=".3 Eventually consistency"></a>.3 Eventually consistency</h4><p>强调数据最终数据能够达到一致，而不需要实时保证系统数据的强一致性。
在实际工程实践中，最终一致性存在以下五类主要变种。</p>
<h5 id="3-1-因果一致性（Causal-consistency）"><a href="#3-1-因果一致性（Causal-consistency）" class="headerlink" title=".3.1 因果一致性（Causal consistency）"></a>.3.1 因果一致性（Causal consistency）</h5><p>进程A更新完某个数据项后通知了进程B，那么进程B之后对该数据的访问都应该能够获取到进程A更新后的最新纸，并且如果进程B要对该数据项进行更新操作的话，
务必基于进程A更新后的最新值。而进程C的数据访问则没有这样的限制。</p>
<h5 id="3-2-读己之所写（Read-your-writes）"><a href="#3-2-读己之所写（Read-your-writes）" class="headerlink" title=".3.2 读己之所写（Read your writes）"></a>.3.2 读己之所写（Read your writes）</h5><p>进程A更新了一个数据项，它自己总是能够访问到更新过的最新值。特殊的因果一致性（A进程通知了A进程）。</p>
<h5 id="3-3-会话一致性（Session-consistency）"><a href="#3-3-会话一致性（Session-consistency）" class="headerlink" title=".3.3 会话一致性（Session consistency）"></a>.3.3 会话一致性（Session consistency）</h5><p>系统能保证在同一个有效的会话中实现“读己之所写”的一致性，即客户端能够在同一绘画中始终读取到该数据项的最新值。</p>
<h5 id="3-4-单调读一致性（Monotonic-read-consistency）"><a href="#3-4-单调读一致性（Monotonic-read-consistency）" class="headerlink" title=".3.4 单调读一致性（Monotonic read consistency）"></a>.3.4 单调读一致性（Monotonic read consistency）</h5><p>如果一个进程从系统读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</p>
<h5 id="3-5-单调写一致性（Monotonic-write-consistency）"><a href="#3-5-单调写一致性（Monotonic-write-consistency）" class="headerlink" title=".3.5 单调写一致性（Monotonic write consistency）"></a>.3.5 单调写一致性（Monotonic write consistency）</h5><p>系统保证来自同一个进程的写操作被顺序地执行。</p>
<h5 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title=".3.6 总结"></a>.3.6 总结</h5><p>最终一致性并不是只有那些大型分布式系统才涉及的特性，许多关系型数据库都采用了最终一致性模型，采用同步和异步方式来实现主备数据复制技术。</p>
<ul>
<li>在同步方式中，数据的复制过程通常是更新事务的一部分，因此在书屋完成后，主备数据库的数据就会达到一致。</li>
<li>在异步方式中，备库的更新往往会存在延时，这取决于事务日志在主备数据库之间传输的时间长达，如果传输时间过长或者甚至在日志传输过程中出现异常导致
无法及时将事务应用到备库上，那么很显然，从备库读取的数据将是旧的，就出现了数据不一致的情况。</li>
</ul>
<p>但是，无论采用重试、人为修正，关系型数据库还是能够保证最终数据达到一致性——这就是系统提供最终一致性保证的经典案例。  </p>
<p>总的来说，BASE理论面向大型高可用可扩展的分布式系统，和传统事务的ACID特性是相反的，不同于ACID的强一致性模型，而是通过强一致性和高可用性的
平衡，最终达到一致性。因此在具体的分布式系统架构设计过程中，ACID和BASE理论往往会结合一起使用用来面对不同的业务场景的要求。</p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h1><p>分布式架构发展过程中的ACID-&gt;CAP-&gt;BASE等分布式事务与一致性方面的经典理论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-从集中式到分布式&quot;&gt;&lt;a href=&quot;#1-从集中式到分布式&quot; class=&quot;headerlink&quot; title=&quot;1. 从集中式到分布式&quot;&gt;&lt;/a&gt;1. 从集中式到分布式&lt;/h1&gt;&lt;h2 id=&quot;1-1-集中式的特点&quot;&gt;&lt;a href=&quot;#1-1-集中式的特
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="从Paxos到Zookeeper分布式一致性原理与实践" scheme="http://www.liwenguang.cn/categories/readNote/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>十、深入理解Session与Cookie</title>
    <link href="http://www.liwenguang.cn/2017/08/17/deepknowjavaweb/10_Deep_Know_SessionAndCookie.html/"/>
    <id>http://www.liwenguang.cn/2017/08/17/deepknowjavaweb/10_Deep_Know_SessionAndCookie.html/</id>
    <published>2017-08-16T16:37:45.000Z</published>
    <updated>2017-08-29T15:12:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章概要：<br>当我们的一个应用系统有几百台服务器时，如何解决Session在多台服务器之间共享的问题？它们还有一些安全问题，如Cookie被盗、Cookie伪造等问题应如何避免？Session与Cookie的作用都是为了保持访问用户与后端服务器的交互状态。例如，使用Cookie来传递信息时，随着Cookie个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如Cookie占用200个字节，如果一天的PV有几亿，那么它要占用多少带宽？所以有大访问量时希望用Session，但是Session的致命弱点是不容易在多台服务器之间共享，这也限制了Session的使用。</p>
<h1 id="1-理解Cookie"><a href="#1-理解Cookie" class="headerlink" title="1. 理解Cookie"></a>1. 理解Cookie</h1><p>Cookie的作用通俗地说就是当一个用户通过HTTP访问一个服务器时，这个服务器会将一些Key/Value键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器时，数据又被完整地带回给服务器。  </p>
<p>当初W3C设计Cookie时实际考虑的是为了记录用户在一段时间内访问Web应用的行为路径。由于HTTP是一种无状态协议，当用户的一次访问请求结束后，后端服务器就无法知道下一次来访问的还是不是上次访问的用户。例如，在一个很短的时间内，如果与用户相关的数据被频繁访问，可以针对这个数据做缓存，这样可以大大提高数据的访问性能。Cookie的作用正是如此，由于是同一个客户端发出的请求，每次发出的请求都会带有第一次访问时，服务端设置的信息，这样服务端就可以根据Cookie值来划分访问的用户了。</p>
<h2 id="1-1-Cookie属性项"><a href="#1-1-Cookie属性项" class="headerlink" title="1.1 Cookie属性项"></a>1.1 Cookie属性项</h2><p>当前Cookie有两个版本：Version0和Version1，它们有两种设置响应头的标识，分别是“Set-Cookie”和“Set-Cookie2”。它们属性项有些不同。  </p>
<p>Version0属性项：</p>
<table>
<thead>
<tr>
<th>属性项</th>
<th>属性项介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td>设置要保存的Key/Value，注意这里的NAME不能和其它属性项的名字一样</td>
</tr>
<tr>
<td>Expires</td>
<td>过期时间</td>
</tr>
<tr>
<td>Domain</td>
<td>生成该Cookie的域名</td>
</tr>
<tr>
<td>Path</td>
<td>该Cookie是在当前哪个路径下生成的</td>
</tr>
<tr>
<td>Secure</td>
<td>如果设置了这个属性，那么只会在SSH连接时才会回传该Cookie</td>
</tr>
<tr>
<td>Expires</td>
<td>过期时间</td>
</tr>
</tbody>
</table>
<p>在Java Web的Servlet规范并不支持Set-Cookie2响应头，在实际应用中Set-Cookie2的一些属性项却可以设置在Set-Cookie中。博主在查看Cookie源码，发现是支持的：
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-2.png" alt="" title="JDK1.7"><br>另外也可以从源码可以得知，一般所说的Cookie键值对，都是值NAME和VALUE属性，其实Cookie还有其他的属性，通过Get/Set方法进行获取和设置。
另外下面是博主在使用Chrome浏览器查看的Cookie：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-1.png" alt="" title="Chrome浏览器的Cookie"></p>
<h2 id="1-2-Cookie如何工作"><a href="#1-2-Cookie如何工作" class="headerlink" title="1.2 Cookie如何工作"></a>1.2 Cookie如何工作</h2><p>当我们用如下方式创建Cookie时：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">getCookie</span><span class="params">(Cookie[] cookies, String key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</div><div class="line">            <span class="keyword">if</span> (cookie.getName().equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> cookie.getValue();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> </span>&#123;</div><div class="line">    Cookie[] cookies = req.getCookies();</div><div class="line">    String userName = getCookie(cookies, <span class="string">"userName"</span>);</div><div class="line">    String userAge = getCookie(cookies, <span class="string">"userAge"</span>);</div><div class="line">    <span class="keyword">if</span> (userName == <span class="keyword">null</span>) &#123;</div><div class="line">        res.addCookie(<span class="keyword">new</span> Cookie(<span class="string">"userName"</span>, <span class="string">"liwenguang"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (userAge == <span class="keyword">null</span>) &#123;</div><div class="line">        res.addCookie(<span class="keyword">new</span> Cookie(<span class="string">"userAge"</span>, <span class="string">"22"</span>));</div><div class="line">    &#125;</div><div class="line">    res.getHeaders(<span class="string">"Set-Cookie"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下几点需要注意：</p>
<ul>
<li>所创建Cookie的NAME不能和Set-Cookie或者Set-Cookie2的属性项值一样。</li>
<li>所创建Cookie的NAME和VALUE的值不能设置成非ASCII字符，如果要使用中文，可以通过URLEncoder将其编码。</li>
<li>当NAME和VALUE的值出现一些TOKEN字符（如“\”、“，”等）时，构建返回头会将该Cookie的Version自动设置为1。</li>
<li>当在该Cookie的属性项中出现Version为1的属性项时，构建HTTP响应头同样会将Version设置为1。</li>
</ul>
<h2 id="1-3-使用Cookie的限制"><a href="#1-3-使用Cookie的限制" class="headerlink" title="1.3 使用Cookie的限制"></a>1.3 使用Cookie的限制</h2><p>任何语言对Cookie的操作，其实都是让浏览器对Cookie的操作，Cookie的浏览器的特性，而浏览器对Cookie有数量限制（50个/每个域名），总大小限制（4096，Chrome没有这个限制）。</p>
<h1 id="2-理解Session"><a href="#2-理解Session" class="headerlink" title="2 理解Session"></a>2 理解Session</h1><p>前面已经介绍了Cookie可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，如果Cookie很多，则无形地增加了客户端
与服务端的数据传输量，而Session的出现正是为了解决这个问题。  </p>
<p>同一个客户端每次和服务端交互时，不需要每次都传回所有的Cookie值，而是只要传回一个ID，这个ID是客户端第一次访问服务端时生成的，而且每个客户端是唯一的。
这样每个客户端就有了一个唯一的ID，客户端只要传回这个ID就行了，这个ID通常是NAME为JSESIONID的一个Cookie。</p>
<h2 id="2-1-Session与Cookie"><a href="#2-1-Session与Cookie" class="headerlink" title="2.1 Session与Cookie"></a>2.1 Session与Cookie</h2><p>下面详解讲一下Session是如何基于Cookie来工作的。实际上有以下三种方式可以让Session正常工作。</p>
<ul>
<li>基于URL Path Parameter，默认支持。</li>
<li>基于Cookie，如果没有修改Context容器的Cookies标识，则默认也是支持的。</li>
<li>基于SSL，默认不支持，只有connector.getAttribute(“SSLEnabled”)为TRUE时才支持。</li>
</ul>
<p>在第一种情况，当浏览器不支持Cookie功能时，浏览器会将用户的SessionCookieName重写到用户请求的URL参数中，传递格式如/path/Servlet;name=value;name2=value2?Name3=value3，其中“Servlet；”后面的K-V就是要传递的Path Parameters，服务器会从这个Path Parameters中拿到用户配置的SessionCookieName。关于这个SessionCookieName，如果在web.xml中配置session-config配置项，其cookie-config下的name属性就是这个SessionCookieName的值。如果没有配置sessio-config配置项，默认的SessionCookieName就是大家熟悉的“JSESSIONID”。需要说明的一点是，与Session关联的Cookie与其他Cookie没有什么不同。接着Request根据这个SessionCookieName到Parameters中拿到Session ID并设置到request.setRequestedSessionId中。  </p>
<p>请注意，如果客户端也支持Cookie，则Tomcat仍然会解析Cookie中的Session ID，并会覆盖URL中的Session ID。  </p>
<p>如果是第三种情况，则会根据javax.servlet.request.ssl_session属性值设置Session ID。</p>
<h2 id="2-2-Session如何工作"><a href="#2-2-Session如何工作" class="headerlink" title="2.2 Session如何工作"></a>2.2 Session如何工作</h2><p>有了Session ID，服务端就可以创建HttpSession对象了，第一次触发通过<code>request.getSession()</code>方法。如果当前的Session ID还没有对应的HttpSession对象，那么就创建一个新的，并将这个对象加到org.apache.catalina.Manager的session容器中保存。Manager类将管理所有Session生命周期，Session过期将被回收，服务器关闭，Sessoin将被序列化到磁盘等。只要这个HttpSession对象存在，用户就可以根据Session ID来获取这个对象，也就做到了对状态的保持。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-3.png" alt="" title="Session工作的时序图"><br>从Request中获取的Session对象保存在org.apache.catalina.Manager类中，它的实现类是org.apache.catalina.session.StandardManager，通过requestedSessionId从StandardManager的Sessions集合取出对应的StandardSession对象。由于一个requestedSessionId对应一个访问的客户端，所以一个客户端也就对应了一个StandardSession对象，这个对象正是保存我们创建的Session值的。下面我们看一下StandardManager这个类是如何管理StandardSession的生命周期的。  </p>
<p>StandardManager类负责Servlet容器中所有的StandardSession对象的生命周期管理。当Servlet容器重启或关闭时，StandardManager负责持久化没有过期的StandardSession对象，它会将所有的StandardSession对象持久化到一个以“SESSIONS。ser”为文件名的文件中。到Servlet容器重启时，也就是StandardManager初始化时，它会重新读取这个文件，解析出所有Session对象，重新保存在StandardManager的sessions集合中。  </p>
<p>当Servlet容器关闭时StandardManager类会调用unload方法将session集合中的StandardSession对象写到“SESSIONS.ser”文件中，然后在启动时再重新恢复，注意要持久化保存Servlet容器中的Session对象，必须调用Servlet容器的stop的start命令，而不能直接结束（kill）Servlet容器的进程。
因为直接结束进程，Servlet容器没有机会调用unload方法来持久化这些Session对象。  </p>
<p>另外，在StandardManager的sessions集合中的StandardSession对象并不是永远保存的，否则Servlet容器的内存将容易被消耗尽，所以必须给每个Session对象定义一个有效时间，超过这个时间则Session对象将被清除。在Tomcat中这个有效时间是60s（maxInactiveInterval属性通知），超过60s该Session将会过期。检查每个Session是否失效是Tomcat的一个后台线程中完成的。  </p>
<p>除了后台进程检查Session是否失效外，当调用<code>request.getSession()</code>时也会检查该Session是否过期。值得注意的是，<code>request.getSession()</code>方法调用的StandardSession永远都会存在，即使与这个客户端关联的Session对象已经过期。如果过期，则又会重新创建一个全新的StandardSession对象，但是以前设置的Session值将会丢失。如果你取到了Session对象，但是通过<code>session.getAttribute</code>取不到前面设置的Session值，请不要奇怪，因为很可能已经失效了，请检查以下<manager pathname="" maxinactiveinterval="60">中<code>maxInactiveInterval</code>配置项的值，如果不想让Session过期则可以设置为-1。但是你要仔细评估一下，网站的访问量和设置的Session的大小，防止将你的Servlet容器内存撑爆。如果不想自动创建Session对象，也可以通过<code>request.getSession(bolean create)</code>方法来判断与该客户端关联的Session对象是否存在。</manager></p>
<h1 id="3-Cookie安全问题"><a href="#3-Cookie安全问题" class="headerlink" title="3 Cookie安全问题"></a>3 Cookie安全问题</h1><p>Cookie通过把所有要保存的数据通过HTTP的头部从客户端传递到服务端，又从服务端传回到客户端，所有的数据都存储在客户端的浏览器里，所以这些Cookie数据可以被访问到，通过浏览器插件可以对Cookie进行修改等。  </p>
<p>相对而言Session的安全性要高很多，因为Session是将数据保存在服务端，只是通过Cookie传递一个SessionID而已，所以Session更适合存储用户隐私和重要的数据。</p>
<h1 id="4-分布式Session框架"><a href="#4-分布式Session框架" class="headerlink" title="4 分布式Session框架"></a>4 分布式Session框架</h1><h2 id="4-1-Cookie存在哪些问题"><a href="#4-1-Cookie存在哪些问题" class="headerlink" title="4.1 Cookie存在哪些问题"></a>4.1 Cookie存在哪些问题</h2><ul>
<li>客户端Cookie存储限制</li>
<li>Cookie管理的混乱，每个应用系统都自己管理每个应用使用的Cookie会导致混乱，由于通常应用系统都在同一个域名下，Cookie又有上面一条提到的限制，所以统一管理很容易出现Cookie超出限制的情况。</li>
<li>不安全，虽然通过设置HttpOnly属性防止一些私密Cookie被客户端访问，但是仍然不能保证Cookie无法被篡改。为了保证Cookie的私密性通常会对Cookie进行加密，但是维护这个加密Key也是一件麻烦的事情，无法保证定期更新加密Key也是会带来安全性问题的一个重要因素。</li>
</ul>
<h2 id="4-2-Cookie-Session可以解决哪些问题"><a href="#4-2-Cookie-Session可以解决哪些问题" class="headerlink" title="4.2 Cookie+Session可以解决哪些问题"></a>4.2 Cookie+Session可以解决哪些问题</h2><p>下面是分布式Session框架可以解决的问题：</p>
<ul>
<li>Session配置的统一管理。</li>
<li>Cookie使用的监控和统一规范管理。</li>
<li>Session存储的多元化。</li>
<li>Session配置的动态修改。</li>
<li>Session加密key的定期修改。</li>
<li>充分的容灾机制，保持框架的使用稳定性。</li>
<li>Session各种存储的监控和报警支持。</li>
<li>Session框架的可扩展性，兼容更多的Session机制如wapSession。</li>
<li>跨域名Session与Cookie如何共享的问题。现在同一个网站可能存在多个域名，如何将Session和Cookie在不同的域名之间共享是一个具有挑战性的问题。</li>
</ul>
<h2 id="4-3-总体实现思路"><a href="#4-3-总体实现思路" class="headerlink" title="4.3 总体实现思路"></a>4.3 总体实现思路</h2><p>为了达成上面所说的几个目标，我们需要一个服务订阅服务器，在应用启动时可以从这个订阅服务器订阅这个应用需要的可写Session项和可写Cookie项，这些配置的Session和Cookie可以限制这个应用能够使用哪些Session和Cookie，甚至可以通知Session和Cookie可读或可写。这样可以精确地控制哪些应用可以操作哪些Session和Cookie，可以有效控制Session的安全性和Cookie的数量。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-4.png" alt="" title="Session框架架构图"><br>如Session的配置项可以为如下形式：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sessions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">session</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>sessionID<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">cookiekey</span>&gt;</span>sessionID<span class="tag">&lt;/<span class="name">cookiekey</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">lifeCycle</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">lifeCycle</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">base64</span>&gt;</span>true<span class="tag">&lt;/<span class="name">base64</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">session</span>&gt;</span></div><div class="line">    .......</div><div class="line"><span class="tag">&lt;/<span class="name">sessions</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Cookie的配置可以为如下形式：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cookies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">cookie</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>cookie<span class="tag">&lt;/<span class="name">key</span>&gt;</span>    </div><div class="line">        <span class="tag">&lt;<span class="name">lifeCycle</span>&gt;</span>10000<span class="tag">&lt;/<span class="name">lifeCycle</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>1<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/wp<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">domain</span>&gt;</span>liwenguang.website<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">decrypt</span>&gt;</span>false<span class="tag">&lt;/<span class="name">decrypt</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">httpOnly</span>&gt;</span>false<span class="tag">&lt;/<span class="name">httpOnly</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">cookie</span>&gt;</span></div><div class="line">    ......</div><div class="line"><span class="tag">&lt;/<span class="name">cookies</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>统一通过订阅服务器推送配置可以有效地几种管理资源，所以可以省去每个应用都来配置Cookie，简化Cookie的管理。如果应用要使用一个新增的Cookie，则可以通过一个统一的平台来申请，申请通过才将这个配置项增加到订阅服务器。如果是一个所有应用都要使用的全局Cookie，那么只需要将这个Cookie通过订阅服务器统一推送过去就行了，省去了要在每个应用中手动增加Cookie的配置。  </p>
<p>关于这个订阅服务器现在有很多开源的配置服务器，如ZooKeeper集群管理服务器，可以统一管理所有服务器的配置文件。  </p>
<p>由于应用是一个集群，所以不可能将创建的Session都保存在每台应用服务器的内存中，因为如果每台服务器有几十万的访问用户，那么服务器的内存可能不够用，即使内存够用，这些Session也无法同步到这个应用的所有服务器中。所以要共享这些Session必须将它们存储在一个分布式缓存中，可以随时写入和读取，而且性能要很好才能满足要求。当前能满足这个要求的系统有很多，如MemCache或者淘宝的开源分布式缓存系统Tair都是很好的选择。  </p>
<p>解决了配置和存储问题，下面看一下如何存取Session和Cookie。  </p>
<p>既然是一个分布式Session的处理框架，必然会重新实现HttpSession的操作接口，使得应用操作Session的对象都是我们实现的InnerHttpSession对象，这个操作必须在进入应用之前完成，所以可以配置一个filter拦截用户的请求。  </p>
<p>先看一下如何封装HttpSession对象和拦截请求，如下时序图： 
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-5.png" alt="" title="HttpSession拦截请求时序图"><br>我们可以在应用的web.xml中配置一个SessionFilter，用于在请求到达MVC框架之前封装HttpServletRequest和HttpServletResponse对象，并创建我们自己的InnerHttpSession对象，把它设置到request和response对象中。这样应用系统通过request.getHttpSession()返回的就是我们创建的InnerHttpSession对象了，我们可以拦截response的addCookies设置的Cookie。  </p>
<p>在时序图中，应用创建的所有Session对象都会保存在InnerHttpSession对象中，当用户的这次访问请求完成时，Session框架将会把这个InnerHttpSession的所有内容再更新到分布式缓存中，以便于这个用户通过其它服务器再次访问这个应用系统。另外，为了保证一些应用对Session稳定性的特殊要求，可以将一些非常关键的Session再存储到Cookie中，如当分布式缓存存在问题时，可以将部分Session存储到Cookie中，这样即使分布式缓存出现问题也不会影响关键业务的正常运行。</p>
<h2 id="4-4-增加Session跨域实现"><a href="#4-4-增加Session跨域实现" class="headerlink" title="4.4 增加Session跨域实现"></a>4.4 增加Session跨域实现</h2><p>还有一个非常重要的问题就是如何处理跨域名来共享Cookie的问题。我们知道Cookie是有域名限制的，也就是在一个域名下的Cookie不能被另一个域名访问，所以如果在一个域名下已经登录成功，如何访问到另外一个域名的应用且保证登录状态仍然有效，对这个问题大型网站应该经常会遇到。如何解决这个问题呢？
下面介绍一种处理方式，流程图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-6.png" alt="" title="跨域名同步session"><br>访问域名A时服务器A获得了session，用户访问域名B时，如果发现服务器B没有session，则302重定向跳转到中转服务器C（C你可以理解成专门取Session的域），服务器C获得了session后，则再进行302重定向到A服务器，写入session，从而完成了session跨域。（如今，大部分都是实现的单点登录SSO，来解决子系统间的跨域问题，让子系统共享顶级域名的Session、Cookie等）。</p>
<h1 id="5-Cookie压缩"><a href="#5-Cookie压缩" class="headerlink" title="5 Cookie压缩"></a>5 Cookie压缩</h1><p>Cookie在HTTP的头部，所以通常的gzip和deflate针对HTTP Body的压缩不能压缩Cookie，如果Cookie的量非常大，则可以考虑将Cookie也做压缩，压缩方式是将Cookie的多个k/v对看成普通的文本，做文本压缩。压缩算法同样可以使用gzip和deflate算法，但是需要注意的一点是，根据Cookie的规范，在Cookie中不能包含控制字符，仅能包含ASCII码为34~126的可见字符。所以要将压缩后的结果再进行转码，可以进行Base32或者Base64编码。
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用DeflaterOutputStream压缩后再用BASE64编码</span></div><div class="line">Cookie c = getCookieObject(<span class="string">""</span>);</div><div class="line">HttpServletResponse res = getResponse();</div><div class="line">ByteArrayOutputStream bos  = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">DeflaterOutputStream dos = <span class="keyword">new</span> DeflaterOutputStream(bos);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    dos.write(c.getValue().getBytes());</div><div class="line">    dos.close();</div><div class="line">    System.out.println(<span class="string">"before compress length:"</span> + c.getValue().length());</div><div class="line">    String compress = <span class="keyword">new</span> sun.misc.BASE64Encoder().encode(bos.toByteArray());</div><div class="line">    res.addCookie(<span class="keyword">new</span> Cookie(<span class="string">"compress"</span>, compress));</div><div class="line">    System.out.println(<span class="string">"after compress length:"</span> + compress.getBytes().length);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用BASE64解码后再用InflaterInputStream解压</span></div><div class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">byte</span>[] compress = <span class="keyword">new</span> sun.misc.BASE64Decoder().decodeBuffer(<span class="keyword">new</span> String(c.getValue().getBytes()));</div><div class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(compress);</div><div class="line">    InflaterInputStream inflater = <span class="keyword">new</span> InflaterInputStream(bis);</div><div class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">while</span> ((count = inflater.read(b)) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        out.write(b, <span class="number">0</span>, count);</div><div class="line">    &#125;</div><div class="line">    inflater.close();</div><div class="line">    System.out.println(out.toByteArray());</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="6-表单重复提交问题"><a href="#6-表单重复提交问题" class="headerlink" title="6 表单重复提交问题"></a>6 表单重复提交问题</h1><p>要防止表单重复提交，就要标识用户的每一次访问请求，使得每一次访问对服务端来说都是唯一确定的。为了标识用户的每次访问请求，可以在用户请求一个表单域时增加一个隐藏表单项，这个表单项每次都是唯一的token，如：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-7.png" alt="" title="表单重复提交"><br>当用户第一次请求表单页面时生成唯一的token，并存储到用户Session中，当用户第二次请求表单页面时再生成唯一的token，覆盖Session，这样就能保证每次都只能通过请求表单页面来提交表单。</p>
<h1 id="7-多终端Session统一"><a href="#7-多终端Session统一" class="headerlink" title="7 多终端Session统一"></a>7 多终端Session统一</h1><p>当前大部分网站都有了无线端，对无线端的Cookie如何处理也是很多程序员必须考虑的问题。<br>在无线端发展初期，后端的服务系统未必和PC的服务系统是统一的，这样就涉及在一端调用多个系统时如何做到服务端Session共享的问题了。有两个明显的例子：<br>一个是在无线端可能会通过手机访问无线服务端系统，如果它们两个的登录系统没有统一的话，将会非常麻烦，可能会出现二次登录的情况；<br>另一个是在手机上登录以后再在PC上同样访问服务端数据，Session能否共享就决定了客户端是否要再次登录。  </p>
<p>针对这两种情况，目前都有理由的解决方案。  </p>
<ul>
<li>多端共享Session
多端共享Session必须要做的工作是不管是无线端还是PC端，后端的服务系统必须统一会话架构，也就是两边的登录系统必须要基于一致的会员数据结构、Cookie与Session的统一。也就是不管是PC端登录还是无线端登录，后面对应的数据结构和存储要统一，写到客户端的Cookie也必须一样，这是前提条件。  </li>
</ul>
<p>那么如何做到这一点？就是要按照我们在前面所说的实现分布式的Session框架。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-8.png" alt="" title="服务端统一Session示意图"><br>上面服务端统一Session后，在同一个终端上不管是访问哪个服务端都能做到登录状态统一。例如不管是Native还是内嵌Webview，都可以拿统一的Session ID去服务端验证登录状态。</p>
<ul>
<li>多终端登录
目前很多网站都会出现无线端和PC端多端登录的情况，例如可以通过扫码登录等。这些是如何实现的呢？<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-10-1-9.png" alt="" title="多终端登录示意图"><br>这里手机端在扫码之前必须是已经登录的状态，因为这样才能获取到到底是谁将要登录的信息，同时扫码的二维码也带有一个特定的标识，标识是这个客户端
通过手机端登陆了。当手机端扫码成功后，会在服务端设置这个二维码对应的标识为已经登录成功，这时PC客户端会通过将“心跳”请求发送到服务端，来验证是否已经登录成功，这样就称为一种便捷的登录方式。（博主以微信扫码登录为例，每次微信PC端的二维码都是带有一个唯一的标识，当你用登录的手机微信扫码之后，手机将你已登录的微信信息获取，并发送给微信服务端，微信服务端将二维码的唯一标识以及手机微信的账号信息绑定，发送给微信PC端，其中，微信PC二维码客户端类似Watch了某个ZK的节点进行监听，这样避免客户端每隔一段时间发送心跳）。</li>
</ul>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>Cookie和Session都是为了保持用户访问的连续状态，之所以要保持这种状态，一方面是为了方便业务实现，另一方面就是简化服务端的程序设计，提高访问性能，但是也带来了安全问题、应用的分布式部署带来的Session的同步问题以及跨域名Session的同步问题（通过单点登录避免）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章概要：&lt;br&gt;当我们的一个应用系统有几百台服务器时，如何解决Session在多台服务器之间共享的问题？它们还有一些安全问题，如Cookie被盗、Cookie伪造等问题应如何避免？Session与Cookie的作用都是为了保持访问用户与后端服务器的交互状态。例如，使用Co
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://www.liwenguang.cn/categories/readNote/deepJavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>九、Servlet工作原理解析</title>
    <link href="http://www.liwenguang.cn/2017/08/17/deepknowjavaweb/9_Servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html/"/>
    <id>http://www.liwenguang.cn/2017/08/17/deepknowjavaweb/9_Servlet工作原理解析.html/</id>
    <published>2017-08-16T16:12:30.000Z</published>
    <updated>2017-08-16T16:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-从Servlet容器说起"><a href="#1-从Servlet容器说起" class="headerlink" title="1. 从Servlet容器说起"></a>1. 从Servlet容器说起</h1><p>Servlet和Servlet容器的关系像子弹和枪，枪是为子弹而生的，而子弹又让枪有了杀伤力。为了适应工业化生产，他们是相互独立发展，通过标准化接口来相互协作。  </p>
<p>Servlet容器种类多，各有各的优缺点，我们以Tomcat为例介绍Servlet容器是如何管理Servlet的。  </p>
<p>在Tomcat的容器等级中，Context容器直接管理Servlet在容器中的包装类Wrapper，所以Context容器如何运作将直接影响Servlet的工作方式。<br>分四个等级，真正管理Servlet的容器是Context容器，一个Context对应一个Web工程，Tomcat中WEB容器配置文件：conf/context.xml中的<context>节点配置
Context容器，你可以配置多个。</context></p>
<h1 id="2-Servlet容器的启动过程"><a href="#2-Servlet容器的启动过程" class="headerlink" title="2. Servlet容器的启动过程"></a>2. Servlet容器的启动过程</h1><p>现在很多博客已经把Tomcat解析很清晰了，就不再多累赘编写了。<br>另外由于博主一直使用Jetty，因此以后待研究Tomcat或者Jetty。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-从Servlet容器说起&quot;&gt;&lt;a href=&quot;#1-从Servlet容器说起&quot; class=&quot;headerlink&quot; title=&quot;1. 从Servlet容器说起&quot;&gt;&lt;/a&gt;1. 从Servlet容器说起&lt;/h1&gt;&lt;p&gt;Servlet和Servlet容器的关系
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://www.liwenguang.cn/categories/readNote/deepJavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>内置函数</title>
    <link href="http://www.liwenguang.cn/2017/08/16/SQL/MySQL/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>http://www.liwenguang.cn/2017/08/16/SQL/MySQL/内置函数/</id>
    <published>2017-08-16T08:37:20.000Z</published>
    <updated>2017-08-16T08:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 数字类的函数------------------------------------------------------------------------------</span></div><div class="line"><span class="comment">-- 返回最小的不小于X的整数</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">CEIL</span>(<span class="number">1.1</span>)</div><div class="line"><span class="keyword">select</span> <span class="keyword">CEILING</span>(<span class="number">-1.1</span>)</div><div class="line"><span class="comment">-- 进制转换，值N，以from的进制，输出为to进制</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">CONV</span>(<span class="string">'a'</span>,<span class="number">16</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">-- 计算出循环冗余校验数字</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">CRC32</span>(<span class="string">'MySQL'</span>)</div><div class="line"><span class="comment">-- 返回最大的不大于X的整数</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">FLOOR</span>(<span class="number">2.5</span>)</div><div class="line"><span class="comment">-- 隔断小数点，技巧：后面如果是'en_US'，则实现的四舍五入</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">FORMAT</span>(<span class="number">123456987.537</span>,<span class="number">0</span>,<span class="string">'en_US'</span>);</div><div class="line"><span class="keyword">select</span> <span class="keyword">FORMAT</span>(<span class="number">123456987.437</span>,<span class="number">0</span>);</div><div class="line"><span class="comment">-- 十六进制，如果是Number则返回该数字的十进制，如果是String，则每个字符转化ASCII的16进制表示</span></div><div class="line"><span class="comment">-- 数字的相反函数：CONV(HEX(255),16,10)，字符的相反函数：UNHEX(HEX('abc'))  </span></div><div class="line"><span class="keyword">select</span> <span class="keyword">HEX</span>(<span class="number">255</span>)</div><div class="line"><span class="keyword">select</span> <span class="keyword">HEX</span>(<span class="string">'abc'</span>)</div><div class="line"><span class="keyword">select</span> <span class="keyword">UNHEX</span>(<span class="keyword">HEX</span>(<span class="string">'中国'</span>))</div><div class="line"><span class="comment">-- 获取余数</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">MOD</span>(<span class="number">18</span>, <span class="number">5</span>)</div><div class="line"><span class="comment">-- 获取X的Y次方</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">POW</span>(<span class="number">2</span>, <span class="number">-1</span>)</div><div class="line"><span class="keyword">select</span> <span class="keyword">POWER</span>(<span class="number">2</span>, <span class="number">-1</span>)</div><div class="line"><span class="comment">-- 返回-1、0、1</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">SIGN</span>(<span class="number">54</span>)</div><div class="line"><span class="comment">-- 获取非负数的平方根</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">SQRT</span>(<span class="number">5</span>)</div><div class="line"><span class="keyword">select</span> <span class="keyword">SQRT</span>(<span class="number">-5</span>)</div><div class="line"><span class="comment">-- 直接截断小数点</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">TRUNCATE</span>(<span class="number">-215.211</span>,<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment">-- 日期和时间类的函数------------------------------------------------------------------------</span></div><div class="line"><span class="comment">-- 获取当前的年月日</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">now</span>(), <span class="keyword">CURDATE</span>()</div><div class="line"><span class="comment">-- 增加时间</span></div><div class="line"><span class="keyword">select</span> ADDDATE(<span class="keyword">CURDATE</span>(),<span class="built_in">INTERVAL</span> <span class="number">10</span> <span class="keyword">DAY</span>)</div><div class="line"><span class="comment">-- 时区转换，需要设置时区</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">CONVERT_TZ</span>(<span class="string">'2017-01-02 12:21:30'</span>,<span class="string">'GMT'</span>,<span class="string">'MET'</span>)</div><div class="line"><span class="comment">-- 比较日期，前面减去后面</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">DATEDIFF</span>(<span class="string">'2017-11-30 12:30'</span>,<span class="string">'2017-11-29 13'</span>)</div><div class="line"><span class="comment">-- INTERVAL，具体参数参见：http://imysql.com/mysql-refman/5.7/functions.html#function_date-add</span></div><div class="line"><span class="keyword">select</span> <span class="string">'2017-01-01 12:12:12'</span> + <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">SECOND</span></div><div class="line"><span class="comment">-- 日期格式化，具体参数参见：http://imysql.com/mysql-refman/5.7/functions.html#function_date-format</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">DATE_FORMAT</span>(<span class="string">'2017-01-01 22:12:32'</span>,<span class="string">'%W %M %Y'</span>)</div><div class="line"><span class="comment">-- 日期减法</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">DATE_SUB</span>(<span class="string">'2017-01-01'</span>,<span class="built_in">INTERVAL</span> <span class="number">2</span> <span class="keyword">DAY</span>)</div><div class="line"><span class="comment">-- 获取星期</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">DAYNAME</span>(<span class="string">'2007-02-03'</span>)</div><div class="line"><span class="keyword">select</span> <span class="keyword">DAYOFWEEK</span>(<span class="string">'2017-02-03'</span>)</div><div class="line"><span class="comment">-- 获取某个月的最后一天</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">LAST_DAY</span>(<span class="string">'2013-02-05 12:32:21'</span>)</div><div class="line"><span class="comment">-- 输入天数，获取年月日</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">MAKEDATE</span>(<span class="number">2017</span>,<span class="number">45</span>)</div><div class="line"><span class="comment">-- 获取月份差</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">PERIOD_DIFF</span>(<span class="number">200802</span>,<span class="number">200911</span>)</div><div class="line"><span class="comment">-- 获取季度</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">QUARTER</span>(<span class="string">'2017-02-05'</span>)</div><div class="line"><span class="comment">-- 秒转化时间</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">SEC_TO_TIME</span>(<span class="number">2354</span>)</div><div class="line"><span class="comment">-- 字符串转化时间</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">'a09:12:30'</span>,<span class="string">'a%h:%i:%s'</span>)</div><div class="line"></div><div class="line"><span class="comment">-- 配合GROUP BY的函数------------------------------------------------------------------------</span></div><div class="line"><span class="comment">-- 求平均</span></div><div class="line"><span class="keyword">AVG</span>([<span class="keyword">DISTINCT</span>] expr)</div><div class="line"><span class="comment">-- 求和</span></div><div class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> expr,[expr...])</div><div class="line"><span class="comment">-- 字段连接, with rollup将额外多出一条记录用于汇总</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, event_day, <span class="keyword">GROUP_CONCAT</span>(dimension_value <span class="keyword">ORDER</span> <span class="keyword">BY</span> dimension_value <span class="keyword">DESC</span> SEPARATOR <span class="string">'`'</span>) </div><div class="line"><span class="keyword">FROM</span> sqq_report.member_dimension_index_day </div><div class="line"><span class="keyword">where</span> tenant_id = <span class="string">'9001'</span> <span class="keyword">AND</span> event_day = <span class="number">20170815</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> event_day <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
    
    </summary>
    
      <category term="SQL" scheme="http://www.liwenguang.cn/categories/SQL/"/>
    
      <category term="MySQL" scheme="http://www.liwenguang.cn/categories/SQL/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>八、JVM内存管理</title>
    <link href="http://www.liwenguang.cn/2017/08/14/deepknowjavaweb/8_JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html/"/>
    <id>http://www.liwenguang.cn/2017/08/14/deepknowjavaweb/8_JVM内存管理.html/</id>
    <published>2017-08-14T15:14:12.000Z</published>
    <updated>2017-08-16T15:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-物理内存与虚拟内存"><a href="#1-物理内存与虚拟内存" class="headerlink" title="1. 物理内存与虚拟内存"></a>1. 物理内存与虚拟内存</h1><p>所谓物理内存就是RAM（随机存储器）。在计算机中，还有一个存储单元叫寄存器，它用于存储计算单元执行指令（如浮点、整数等运算时）的中间结果。
寄存器的大小决定了一次计算可使用的最大数值。（博主直接理解成内存条，内存条也是RAM的一种）  </p>
<p>连接处理器和RAM或者连接处理器和寄存器的是：地址总线，这个地址总线的宽度影响了物理地址的索引范围，因为总线的宽度决定了处理器一次可以从寄存器
或者内存中获取多少个bit。同时也决定了处理器最大可以寻址的地址空间，如32位地址总线可以寻址的范围为0x0000 0000~0xffff ffff。这个范围
是2^32=4294967296个内存位置，每个地址会引用一个字节，所以32位总线宽度可以有4GB的内存空间。通常情况下，地址总线和寄存器或者RAM有相同的位数，因为这样更容易传输数据。  </p>
<p>不管是什么系统，我们要运行程序，都要向操作系统先申请内存地址。通常操作系统管理内存的申请空间是按照进程来管理的，每个进程拥有一段独立的
地址空间，每个进程之间不会相互重合，操作系统也会保证每个进程只能访问自己的内存空间。这主要从程序的安全性来考虑，也便于操作系统来管理物理内存。  </p>
<p>其实上面所说的进程的内存空间的独立主要是指逻辑上独立，也就是这个独立是由操作系统来保证的，但是真正的物理空间是不是只能由一个进程来使用就
不一定了。因为随着程序越来越庞大和设计的多任务性，物理内存无法满足程序的需求，在这种情况下就有了<strong>虚拟内存</strong>的出现。  </p>
<p>虚拟内存的出现使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上共享，在逻辑上它们仍然是不能相互访问的。虚拟地址不但可以让进程
共享物理内存、提高内存利用率，而且还能够扩展内存的地址空间，如一个虚拟地址可能被映射到一段物理内存、文件或者其他可以寻址的存储上。  </p>
<p>一个进程在不活动的情况下，操作系统将这个物理内存中的数据移到一个磁盘文件中（也就是通常Windows系统上的页面文件，或者Linux系统上的交换分区），
而真正高效的物理内存留给正在活动的程序使用。在这种情况下，在我们重新唤醒一个很长时间没有使用的程序时，磁盘会吱吱作响，并且会有一个短暂的
停顿得到印证，这时操作系统又会把磁盘上的数据重新交互到物理内存中。但是我们必须要避免这种情况的经常出现，如果操作系统频繁地交互物理内存的
数据和磁盘数据，则效率将会非常低，尤其在Linux服务器上，我们要关注Linux中swap的分区的活跃度。如果swap分区被频繁使用，系统将会非常缓慢，
很可能意味着物理内存已经验证不足或者某些程序没有及时释放内存（物理内存可以理解为内存条大小）。  </p>
<ul>
<li>程序-&gt;虚拟内存-&gt;物理内存，如果你的内存条是8G，虚拟内存可能是大于8G，因此虚拟内存在某些情况下将磁盘也算了进去（某个程序一直处于后台，就被
放入了磁盘，方便用户更好的利用真正的内存）。</li>
<li>另外，虚拟内存隔绝了程序和物理内存的交互，程序以为是连续的内存地址，实际在物理内存中并不是连续的，这样就可以高效的利用物理内存的碎片。</li>
</ul>
<h1 id="2-内核空间与用户空间"><a href="#2-内核空间与用户空间" class="headerlink" title="2. 内核空间与用户空间"></a>2. 内核空间与用户空间</h1><p>一个计算机通常有一定大小的内存空间，如使用的计算机是4GB的地址空间，但是程序并不能完全使用这些地址空间，因为这些地址空间被划分为内核空间和
用户空间。程序只能使用用户空间的内存，这里所说的使用是指程序能够申请的内存空间，并不是程序真正访问的地址空间。  </p>
<p>内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者连接硬件资源等的程序逻辑。为何需要内存空间和用户空间的划分呢？很显然
和前面所说的每个进程都独立使用属于自己的内存一样，为了保证安全，访问硬件资源只能由操作系统来发起。用户需要访问硬件资源，如网络连接等，
需要调用操作系统提供的接口实现，这个调用接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间的切换，通常的网络传输也是一次系统调用，
通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再从内核空间复制到用户空间，供用户程序使用 。这种从内核空间到用户空间的数据复制
很费时，以效率换取的安全稳定。  </p>
<p>内核空间和用户空间的大小如何分配也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行，这要平衡一下。  </p>
<p>如果是一台登录服务器，要分配更多的内核空间，因为每个登录用户操作系统都会初始化一个用户进程，这个进程大部分都在内核空间里运行。<br>Window32位操作系统默认内核：用户=1:1，即各有2GB，而在Linux32位则是1:3。</p>
<h1 id="3-在Java中哪些组件需要使用内存"><a href="#3-在Java中哪些组件需要使用内存" class="headerlink" title="3. 在Java中哪些组件需要使用内存"></a>3. 在Java中哪些组件需要使用内存</h1><p>Java启动后作为一个进程运行在操作系统中，那么这进程有哪些部分需要分配内存空间呢？</p>
<h2 id="1-Java堆"><a href="#1-Java堆" class="headerlink" title="1. Java堆"></a>1. Java堆</h2><p>用于存储Java对象的内存区域，堆的大小在JVM启动时就一次向操作系统申请完成，通过-Xmx和-Xms两个选项来控制大小，Xmx表示堆的最大大小，Xms表示
初始大小。一旦分配完成，堆的大小固定，不能在内存不够时再向操作系统重新申请，同时当内存空闲时也不能将多余的空间交还给操作系统。  </p>
<p>在Java堆中内存空间的管理由JVM来控制，对象创建由Java应用程序控制，但是对象所占的空间释放由管理堆内存的垃圾收集器来完成。根据GC算法的不同，
内存回收的方式和时机也会不同。</p>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><p>JVM运行实际程序的实体是线程，当然线程需要内存空间来存储一些必要的数据，每个线程创建时JVM都会为它创建一个堆栈，堆栈的大小根据不同的JVM实现而不同，
通常在256KB~756KB之间。  </p>
<p>线程所占用空间相对堆空间来说比较下。但是如果线程过多，线程堆栈的总内存使用量可能也非常大。当前有很多应用程序根据CPU的核书来分配创建的线程数，
如果运行的应用程序的线程数量比可用于处理它们的处理器数量多，效率通常很低。</p>
<h2 id="3-类和类加载器"><a href="#3-类和类加载器" class="headerlink" title="3. 类和类加载器"></a>3. 类和类加载器</h2><p>在Java中的类和加载类的类加载器本身同样需要存储空间，在Sun JDK它们也被存储在Java堆中，这个区域叫做永久代（PermGen区）。  </p>
<p>JVM是按需来加载类的，曾经有个疑问：JVM如果要加载一个jar包是否要把这个jar包中的所有类都加载到内存中？显然不是的。</p>
<p>JVM只会加载那些在你的应用程序中明确使用的类到内存中。要查看JVM到底加载了哪些类，可以在启动参数上加上<code>-verbose:class</code>。</p>
<blockquote>
<p>博主在idea的vm options加上这个之后，运行一个Demo，发现加载了很多很多rt.jar的类，日志输出很多。</p>
</blockquote>
<p>理论上使用的Java类越多，需要占用的内存也会越多，还有一种情况是可能重复加载同一个类。通常情况下JVM只会加载一个类到内存一次，
但是如果是自己实现的类加载器会出现重复加载的情况，如果PermGen区不能对已经失效的类做卸载，可能会导致PermGen区内存泄漏。所以徐需要注意
PermGen区的内存回收问题。通常一个类能够被卸载，有如下条件需要满足：</p>
<ul>
<li>该类所有的实例都已经被GC。</li>
<li>加载该类的ClassLoader实例已经被GC。</li>
<li>该类的java.lang.Class对象没有在任何地方被引用。</li>
</ul>
<p>需要注意的是，JVM所创建的3个默认类加载器都不可能满足这些条件，因此，任何系统类（如java.lang.String）或者通过应用程序类加载器加载的任何应用
程序类都不能在运行时释放。</p>
<h2 id="4-NIO"><a href="#4-NIO" class="headerlink" title="4. NIO"></a>4. NIO</h2><p>基于通道和缓冲区来执行I/O的新方式。使用java.nio.ByteBuffer.allocateDirect()分配内存，这个方法分配的内存是本机内存而不是Java堆上的内存，
这也进一步说明每次分配内存时会调用操作系统的os::malloc()函数。另一方面直接ByteBuffe产生的数据如果和网络或者磁盘交互都在操作系统的内核
空间发生，不需要将数据复制到Java内存中，很显然这种I/O操作要比一般的从操作系统的内和空间到Java堆上的切换操作快得多，如果你的IO频繁发送
很小的数据，这种系统调用的开销可能会抵消数据在内核空间和用户空间复制带来的好处（即，如果频繁IO小数据，就不用NIO了）。  </p>
<p>直接ByteBuffer对象会自动清理本机缓冲区，但这个过程只能作为Java堆GC的一部分来执行，因此它们不会自动响应施加在本机堆上的压力。
GC仅在Java堆被填满，以致于无法为堆分配请求提供服务时发生，或者在Java应用程序中显示请求时发生。当前在很多NIO框架中都在代码中显式调用System.gc()
来释放NIO持有的内存。但是这种方式会影响应用程序的性能，因为会增加GC的次数，一般通过设置<code>-XX:+dISABLEeXPLICITgc</code>来控制System.gc()的影响，但是
又会导致NIO direct memory内存泄漏问题。</p>
<h2 id="5-JNI"><a href="#5-JNI" class="headerlink" title="5. JNI"></a>5. JNI</h2><p>JNI技术使得本机代码（如C）可以调用Java方法，也就是通常所说的native memory。实际上Java运行时本身也依赖于JNI代码来实现类库功能，如
文件操作、网络IO操作或者其他系统调用。所以JNI也会增加Java运行时的本机内存占用。</p>
<h1 id="4-JVM内存结构"><a href="#4-JVM内存结构" class="headerlink" title="4. JVM内存结构"></a>4. JVM内存结构</h1><p>JVM是如何使用内存的？<br>JVM按照运行时数据的存储结构来划分内存结构的，JVM在运行Java程序时，将它们划分成几种不同格式的数据，分别存储在不同的区域，这些数据统一称为
运行时数据（Runtime Data）。运行数据包括Java程序本身的数据信息和JVM运行Java程序需要的额外数据信息，如要记录当前程序指令执行的指针。</p>
<ul>
<li>PC寄存器数据</li>
<li>Java栈</li>
<li>堆</li>
<li>方法区</li>
<li>本地方法区</li>
<li>运行时常量池</li>
</ul>
<h2 id="1-PC寄存器"><a href="#1-PC寄存器" class="headerlink" title="1. PC寄存器"></a>1. PC寄存器</h2><p>PC寄存器严格来说是一个数据结构，它用于保存当前正在执行的程序的内存地址。同时Java陈旭是多线程执行的，所以不可能一直都按照线性执行下去，当
有多个线程交叉执行时，被中断线程的程序当前执行到哪条的内存地址必然要保存下来，以便于它被恢复执行时再按照被中断时的指令地址继续执行下去。  </p>
<p>但是JVM规范只定义了Java方法需要记录指针信息，而对于Native方法，并没有要求记录执行的指针地址。</p>
<h2 id="2-Java栈"><a href="#2-Java栈" class="headerlink" title="2. Java栈"></a>2. Java栈</h2><p>Java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的Java栈，在这个Java栈中又会含有多个栈帧，这些栈帧是与每个方法
关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些内部变量（局部变量）、操作栈和方法返回值等信息。  </p>
<p>每当一个方法执行完成时，这个战争就会弹出栈帧的元素作为这个方法的返回值，并清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是
当前正在执行的方法，PC寄存器也会指向这个地址。只有这个活动的栈帧本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，
与之对应的一个新的栈帧又被创建，这个新创建的栈帧又被放大Java栈的顶部，变为当前的活动栈帧。同样现在只有这个栈帧的本地变量才能被使用，当
在这个栈帧中所有指令执行完成时这个栈帧移出Java栈，刚才的那个栈帧又变成活动栈帧，前面的栈帧的返回值又变为这个栈帧的操作数。如果前面的栈帧
没有返回值，那么当前的栈帧的操作栈的操作数没有变化。  </p>
<p>由于Java栈是与Java线程对应起来的，这个数据不是线程共享的，所以不用关心数据一致性以及同步锁的问题。</p>
<h2 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h2><p>堆是存储Java对象的地方，它是JVM管理Java对象的核心存储区域，堆是Java程序员最应该关心的，因为它是我们的应用程序与内存关系最密切的存储区域。<br>每一个存储在堆中的Java对象都会是这个对象的类的一个副本，它会复制包括继承自它父类的所有非静态属性。<br>堆是被所有Java线程所共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p>
<h2 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h2><p>JVM方法区是用于存储类结构信息的地方，如果在第7章介绍的将一个class文件解析成JVM能识别的几个部分，这些不同的部分在这个class被加载到JVM时，
会被存储在不同的数据结构中，其中的常量池、域、方法数据、方法体、构造函数、包括类中的专用方法、实例初始化、接口初始化都存储在这个区域。  </p>
<p>方法区这个存储区域也属于后面介绍的Java堆中的一部分，也就是我们通常所说的Java堆的永久区。这个区域可以被所有的线程共享，并且它的大小可以通过参数来设置。<br>这个方法区存储区域的大小一般的程序启动后的一段时间内就是固定的了，JVM运行一段时间后，需要加载的类通常都已经加载到JVM中了，但是有一种情况是需要注意的，
那就是项目中如果存在<strong>对类的动态编译</strong>，而且是同样一个类的多次编译，那么需要观察方法区的大小是否能满足类存储。  </p>
<p>方法区这个区域有点特殊，由于它不像其他Java堆一样会频繁的被GC回收，它存储的信息相对比较稳定，但是它仍然占用了Java堆的空间，所以仍然会被JVM的GC
回收器管理。在一些特殊的场合下，有时通常需要缓存一块内容，这个内容也很少变动，但是如果把它置于Java堆中它会不停的被GC扫描，知道经过很长的
时间后会进入Old区。在这种情况下，通常是能够控制这个缓存区域中数据的生命周期的，我们不希望它被JVM内存管理，但是又希望它在内存中。面对这种情况，
淘宝正在开发一种技术用于在JVM中分配另外一个内存存储区域，它不需要GC回收器来回收，但是可以和其他内存中对象一样来使用。</p>
<h2 id="5-运行时常量池"><a href="#5-运行时常量池" class="headerlink" title="5. 运行时常量池"></a>5. 运行时常量池</h2><p>在JVM规范中是这样定义运行时常量池这个数据结构的：<code>Runtime Constant Pool</code>代表运行时每个class文件中的常量表。它包括几种常量：编译器的数字常量、
方法或者域的引用（在运行时解析）。<code>Runtime Constant Pool</code>的功能类似于传统编程语言的符号表，尽管它包含的数据比典型额符号表要丰富得多。
每个<code>Runtime Constant Pool</code>都是JVM的<code>Method area</code>中分配的，每个Class或者Interface的<code>Constant Pool</code>都是在JVM创建class或接口时创建的。  </p>
<p>这个常量池和前面方法区的常量池是否是一回事？答案是肯定的。它是方法区额一部分，所以它的存储也受方法区的规范约束，如果常量池无法分配，
同样会抛出OutOfMemoryError。</p>
<h2 id="6-本地方法栈"><a href="#6-本地方法栈" class="headerlink" title="6. 本地方法栈"></a>6. 本地方法栈</h2><p>本地方法栈是为JVM运行Native方法准备的空间，和前面介绍的Java栈的作用是类似的，由于很多Native方法都是用C语言实现的，所以它通常又叫C栈，
还有JVM利用JIT技术时会将一些Java方法重新编译为Native Code代码，这些编译后的本地代码通常也是利用这个栈来跟踪方法的执行状态的。  </p>
<p>在JVM规范中没有对这个区域的严格限制，它可以由不同的JVM实现者自由实现，但是它和其他存储区一样会抛出OutOfMemoryError和StackOverflowError。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>此图镇楼：<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-8-1-1.jpg" alt="内存模型" title="内存模型"></p>
<h1 id="5-JVM内存分配策略"><a href="#5-JVM内存分配策略" class="headerlink" title="5. JVM内存分配策略"></a>5. JVM内存分配策略</h1><h2 id="1-通常的内存分配策略"><a href="#1-通常的内存分配策略" class="headerlink" title="1. 通常的内存分配策略"></a>1. 通常的内存分配策略</h2><p>操作系统的三种内存分配策略：</p>
<ul>
<li>静态内存分配</li>
<li>栈内存分配</li>
<li>堆内存分配</li>
</ul>
<p>静态内存分配是指在程序编译时就能确定每个数据在运行时的粗出空间需求，因此在编译时就可以给它们分配固定的内存空间。这种分配策略不允许在程序
代码中有可变数据结构（如可变数组）的存在，也不允许有嵌套或者递归的结构出现，因为它们都会导致编译程序无法计算准确的存储空间需求。  </p>
<p>栈式内存分配也可称为动态存储分配，是由一个类似于堆栈的运行栈来实现的。和静态内存分配相反，在栈式内存方案中，程序对数据区的需求在编译时是完全未知的，
只有到运行时才能知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区大小才能够为其分配内存。和我们所熟知的数据结构中的栈一样，
栈式内存分配按照先进后出的原则进行分配。  </p>
<p>堆内存分配，当程序真正运行到相应代码时才会知道空间大小。</p>
<h2 id="2-Java中的内存分配详解"><a href="#2-Java中的内存分配详解" class="headerlink" title="2. Java中的内存分配详解"></a>2. Java中的内存分配详解</h2><p>Java内存分配主要基于堆和栈。  </p>
<p>Java栈的分配是和线程绑定在一起的，当我们创建一个线程时，很显然，JVM就会为这个线程创建一个新的Java栈，一个线程的方法的调用和返回对应于这个
Java栈的压栈和出栈。当线程激活一个Java方法时，JVM就会在线程的Java堆栈里新压入一个栈帧，这个帧自然成了当前帧。在此方法执行期间，
这个帧将用来保存参数、局部变量、中间计算过程和其它数据。  </p>
<p>栈中主要存放了一些基本类型的变量数据（int、short、long、byte、float、double、boolean、char）和引用。<strong>存取速度比堆要快、仅次于寄存器，
栈数据可以共享。缺点是，存在栈中的数据大小与生存期必须是确定的，这也导致缺乏了其灵活性</strong>。  </p>
<p><strong>每个Java应用都唯一对应一个JVM实例，每个实例唯一对应一个堆</strong>。应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用程序所有的线程共享。
在Java中分配堆内存是自动初始化，所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都
分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的引用而已。  </p>
<p>Java的堆是一个运行时数据区，它们不需要程序代码来显式地释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，
因为它是在运行时动态分配内存的。但缺点是，由于要在运行时动态分配内存，存取速度较慢。  </p>
<p>从堆和栈的功能和作用来通俗地比较，<strong>堆主要用来存放对象，栈主要用来执行程序</strong>，这种不同主要是由堆和栈的特点决定的。  </p>
<p>在编程中，如C/C++中，所有的方法调用都是通过栈拉进行的，所有的局部变量】形参都是从栈中分配内存空间的。实际上也不是什么分配，只是从栈顶向上用就行，
就好像工厂中的传送带一样，栈指针会自动指引你到放东西的位置，你所要做的只是把东西放下来就行。在退出函数时，修改栈指针就可以把栈中的内容销毁。
这样的模式速度最快，当然要用来运行程序了。注意：在分配时，如为一个即将要调用的程序模块分配数据区时，应事先知道这个数据区的大小，也就是说虽然分配
是在程序运行时进行的，但是分配的大小是确定的、不变的，而这个“大小多少”是在编译时确定的，而不是在运行时。  </p>
<p><strong>堆在应用程序运行时请求操作系统给自己分配内存，由于操作系统管理内存分配，所以在分配和销毁都要占用时间，因此用堆的效率非常低</strong>。但是堆的优先在于编译器
不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长时间，因此，用堆保存数据时会得到更大的灵活性。事实上，由于面向对象的多态性，
堆内存分配是必不可少的，因为多态变量所需的存储空间只有在运行时创建对象之后才能确定。在C++中，要求创建一个对象时，只需要new命令编制相关的代码即可。
执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价–<strong>在堆里分配存储空间会花掉更长的时间</strong></p>
<h1 id="6-JVM内存回收策略"><a href="#6-JVM内存回收策略" class="headerlink" title="6. JVM内存回收策略"></a>6. JVM内存回收策略</h1><h2 id="1-静态内存分配和回收"><a href="#1-静态内存分配和回收" class="headerlink" title="1. 静态内存分配和回收"></a>1. 静态内存分配和回收</h2><p>在编译时就能够确定需要的内存空间，当程序被加载时系统把内存一次性分配给它。
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">staticData</span><span class="params">(<span class="keyword">int</span> arg_)</span> </span>&#123;</div><div class="line">    String s = <span class="string">"String"</span>;</div><div class="line">    <span class="keyword">long</span> l_ = <span class="number">1</span>;</div><div class="line">    Long lg = <span class="number">1L</span>;</div><div class="line">    Object o = <span class="keyword">new</span> Object();</div><div class="line">    Integer i = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中参数arg<em>、l</em>是原生的数据类型，s、lg、o、i是指向对象的引用。其中int分配4个字节，long分配8个字节，对象的引用占用4个字节，所以这个方法
占用的静态内存空间是：4+4+8+4+4+4=28个字节。  </p>
<p>静态内存空间当这段代码运行结束时回收，根据第七章的介绍，我们知道这些静态内存空间是在Java栈上分配的，当这个方法运行结束时，对应的栈帧也就撤销，
所以分配的静态内存空间也就回收了。</p>
<h2 id="2-动态内存分配和回收"><a href="#2-动态内存分配和回收" class="headerlink" title="2. 动态内存分配和回收"></a>2. 动态内存分配和回收</h2><p>在前面的例子中变量lg和i存储与值虽然与l<em>和arg</em>变量一样，但是它们存储的位置是不一样的，后者是原生数据类型，它们存储在Java栈中，方法执行结束
就会消失，而前者是对象类型，它们存储在Java堆中，它们是可以被共享的。变量l<em>和lg的内存空间大小也不一样，l</em>在Java栈中被分配8个字节，而lg
被分配4个字节的<strong>地址指针空间</strong>，这个地址指针指向这个对象在堆中的地址。很显然在堆中Long类型数字1肯定不止8个字节，所以Long代表的数字肯定比
long类型占用的空间要大很多。  </p>
<p>在Java中对象的内存空间是动态分配的，所谓的动态分配就是在程序执行时才知道要分配的存储空间大小，而不是在编译时就能够确定的。lg代表的Long对象，
只有JVM在解析Long类时才知道在这个类中有哪些信息，这些信息都是哪些类型，然后再为这些信息分配相应的存储空间存储相应的值。而这个对象什么时候
被回收也是不确定的，只有等到这个对象不再使用时才会被回收。  </p>
<p>内存的分配是在对象创建时发生的，而内存的回收是以对象不再引用为前提的。</p>
<h2 id="3-如何检测垃圾"><a href="#3-如何检测垃圾" class="headerlink" title="3. 如何检测垃圾"></a>3. 如何检测垃圾</h2><p>垃圾收集器必须能够完成两件事：</p>
<ul>
<li>正确地检测出垃圾对象。</li>
<li>能够释放垃圾对象占用 的内存空间。</li>
</ul>
<p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-8-1-2.png" alt="活动对象" title="活动对象"><br>除了f和h对象之外，其它都可以称为活动对象，因为它们都可以被根对象集合达到。  </p>
<p>那么这个根对象集合中又都是些什么呢？虽然根对象集合和JVM的具体实现也有关系，但是大都会包含如下一些元素：</p>
<ul>
<li>在方法中局部变量区的对象的引用：如在前面的staticData方法中定义的lg和o等对象的引用就是根对象集合中的一个根对象，这些根对象直接存储在栈帧的局部变量区中。</li>
<li>在Java操作栈中的对象引用：有些对象是直接在操作栈中持有的，所以操作栈肯定也包含根对象集合。（博主：即Java栈中除了native栈）</li>
<li>在常量池中的对象引用：每个类都会包含一个常量池，这些常量池也会包含很多对象引用，如表示类名的字符串就保存在堆中，那么常量池中只会持有这个
字符串对象引用。</li>
<li>在本地方法中持有的对象引用：有些对象被传入本地方法中，这些对象是不会被释放。</li>
<li>类的Class对象：当每个类被JVM加载时都会创建一个代表这个类的唯一数据类型的Class对象，而这个Class对象也同样存放在堆中，当这个类不再被
使用时，在方法区中类数据和这个Class对象同样需要被回收。</li>
</ul>
<h2 id="4-基于分代的垃圾收集算法"><a href="#4-基于分代的垃圾收集算法" class="headerlink" title="4. 基于分代的垃圾收集算法"></a>4. 基于分代的垃圾收集算法</h2><p>将对象按照寿命长短来分组，分为年轻代和年老代，新创建的对象被分在年轻代，如果对象经过几次回收后仍然存活，那么再把这个对象划分到年老代。
年老代的手机频度不像年轻代那么频繁。这样就减少了每次垃圾收集时所要扫描的对象的数量，从而提高了垃圾回收效率。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-8-1-3.png" alt="基于分代的堆结构" title="基于分代的堆结构">  </p>
<ul>
<li>Young区又分为Eden区和两个Survivor，其中所有新创建的对象都在Eden区，当Eden区满后会触发minor GC将Eden区仍然存活的对象复制到其中一个
Survivor区，另外一个Survivor区中的存活对象也复制到这个Survivor中，以保证始终有一个Survivor区是空的。</li>
<li>Old区存储的是Young区的Survivor满后触发minor GC后仍然存活的对象，当Eden区满后将对象放到Survivor区中，如果Survivor区仍然存不下这些
对象，GC收集器会将这些对象直接存放到Old区。如果在Survivor区中的对象足够老，也直接存放到Old区。如果Old区也满了，将会触发Full GC，回收整个
堆内存。</li>
<li>Perm区存放的主要是类的Class对象，如果一个类被频繁地加载，也可能会导致Perm区满，Perm区的垃圾回收也是由Full GC触发的。</li>
</ul>
<p>Sun建议堆中Young区的大小为整个堆的1/4，而Young区中Survivor区一般设置为整个Young区的1/8。  </p>
<p>GC收集器对这些区采用的垃圾收集器算法也不一样，Hotspot提供了三类垃圾收集算法：</p>
<ul>
<li>Serial Collector</li>
<li>Parallel Collector</li>
<li>CMS Collector</li>
</ul>
<h3 id="1-Serial-Collector"><a href="#1-Serial-Collector" class="headerlink" title="1. Serial Collector"></a>1. Serial Collector</h3><p>串行收集器是JVM在client模式下默认的GC方式。可以通过JVM配置参数<code>-XX:+UseSerialGC</code>来指定GC使用该收集算法。我们指定所有的对象都在Young区
的Eden中创建，但是如果创建的对象超过Eden区的总大小，或者超过了<code>PretenureSizeThreshold</code>配置参数配置的大小，就只能在Old区分配了。  </p>
<p>当Eden空间不足时就触发了Minor GC，触发Minor GC时首先会检查之前每次Minor GC时晋升到Old区的平均对象大小是否大小Old区的剩余空间，如果大于，
则将直接触发Full GC，如果小于，则要看<code>-XX:-HandlePromotionFailure</code>参数的值。如果为true，仅触发Minor GC，否则再触发一次Full GC。  </p>
<p>JVM在做GC时由于是船形的，所以这些动作都是单线程完成的，在JVM中的其他应用程序全部停止。</p>
<h3 id="2-Parallel-Collector"><a href="#2-Parallel-Collector" class="headerlink" title="2. Parallel Collector"></a>2. Parallel Collector</h3><p>根据Minor GC和Full GC的不同分为三种，分别是ParNewGC、ParallelGC、ParallelOldGC。</p>
<h4 id="1-ParNewGC"><a href="#1-ParNewGC" class="headerlink" title="1. ParNewGC"></a>1. ParNewGC</h4><p>通过<code>-XX:+UseParNewGC</code>参数来指定，它的对象分配和回收策略与Serial Collector类似，只是回收的线程不是单线程的，而是多线程并行回收。在
Parallel Collector中还有一个<code>UseAdaptiveSizePolicy</code>配置参数，这个参数是用来动态控制Eden、From Space和To Space的TenuringThreshold
大小的，即控制哪些对象经过多少次回收后可以直接放入Old区。</p>
<h4 id="2-ParallelGC"><a href="#2-ParallelGC" class="headerlink" title="2. ParallelGC"></a>2. ParallelGC</h4><p>在Server下默认的GC方式，可以通过<code>-XX:+UseParallelGC</code>参数来强制指定，并行回收的线程数可以通过<code>-XX:ParallelGCThreads</code>来指定，
这个值有个计算公式，如果CPU核书小于8，线程数可以和核书一样，如果大于8，值为3+(core*5)/8。  </p>
<p>当在Eden区中申请内存空间时，如果Eden区不够，那么看当前申请的空间是否大于等于Eden的一半，如果大于则这次申请直接在Old中分配，如果小于则触发
Minor GC。在触发GC之前首先会检查每次晋升到Old区的平均大小是否大于Old区的剩余空间，如大于则再触发Full GC。在这次触发GC后仍然会按照这个规则重新检查一次。
也就是如果满足上面这个规则，Full GC会执行两次。</p>
<h4 id="3-ParallelOldGC"><a href="#3-ParallelOldGC" class="headerlink" title="3. ParallelOldGC"></a>3. ParallelOldGC</h4><p>可以通过<code>-XX:UseParallelOldGC</code>参数来强制指定。它和ParallelGC有何不同呢？其实不同之处在Full GC上，前者Full GC进行的动作为清空整个Heap
堆中的垃圾对象，清楚Perm区中已经被卸载的类信息，并进行压缩。而后者是清楚Heap堆中的部分垃圾对象，并进行部分的空间压缩。  </p>
<p><strong>GC垃圾回收都是以多线程方式进行的，同样也将暂停所有的应用程序</strong>。</p>
<h3 id="3-CMS-Collector"><a href="#3-CMS-Collector" class="headerlink" title="3. CMS Collector"></a>3. CMS Collector</h3><p>它既不是上面所说的Minor GC，也不是Full GC，它是基于这两种GC之间的一种GC。它的触发规则是检查Old区或者Perm区的使用率，当达到一定比例就会
触发CMS GC，触发时会收回Old区中的内存空间。  </p>
<p>触发CMS GC时回收的只是Old区或者Perm区的垃圾对象，在回收时和前面所说的Minor GC和Full GC基本没有关系。</p>
<h1 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>中间有很多原作者用于分析真实场景JVM异常的实例，但是由于博主并没有达到那个高度，就并没有列出来。</p>
<ul>
<li>JVM的内存：PC寄存器、Java栈、堆、方法区、运行时常量池、本地方法栈，以及栈是线程安全的。</li>
<li>堆的划分用于GC效率：Young（Eden，Survivor（From、To））、Old、Perm。</li>
<li>垃圾回收算法：Serial Collector、ParallelC Collector、CMS Collector（Old、Perm）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-物理内存与虚拟内存&quot;&gt;&lt;a href=&quot;#1-物理内存与虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;1. 物理内存与虚拟内存&quot;&gt;&lt;/a&gt;1. 物理内存与虚拟内存&lt;/h1&gt;&lt;p&gt;所谓物理内存就是RAM（随机存储器）。在计算机中，还有一个存储单
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://www.liwenguang.cn/categories/readNote/deepJavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机初始化部署</title>
    <link href="http://www.liwenguang.cn/2017/08/14/hadoop/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://www.liwenguang.cn/2017/08/14/hadoop/虚拟机初始化部署/</id>
    <published>2017-08-14T14:45:23.000Z</published>
    <updated>2017-08-15T04:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-虚拟机设置静态IP"><a href="#1-虚拟机设置静态IP" class="headerlink" title="1. 虚拟机设置静态IP"></a>1. 虚拟机设置静态IP</h1><p>使用VMware12安装CentOS 64位，安装一台之后，并进行设置好静态IP。<br>详细地址：<a href="http://blog.csdn.net/readiay/article/details/50866709" target="_blank" rel="external">http://blog.csdn.net/readiay/article/details/50866709</a><br>主要通过查看VMware12的网关、网段，并且设置虚拟机的IP、网关、子网掩码。</p>
<blockquote>
<p>设置网卡：<code>/etc/sysconfig/network-scripts/ifcfg-xxx</code>,xxx可能不同。<br>设置主机名：<code>/etc/sysconfig/network</code>。<br>设置DNS：<code>/etc/resolv.conf</code>。<br>这步完成，虚拟机可以上网，使用SecureCRT主机可以登录虚拟机。</p>
</blockquote>
<h1 id="2-虚拟机进行拷贝"><a href="#2-虚拟机进行拷贝" class="headerlink" title="2. 虚拟机进行拷贝"></a>2. 虚拟机进行拷贝</h1><p>增加用户hadoop之后。进行拷贝，拷贝出两个虚拟机用作从机，并重新设置网卡以及主机名。并使用<code>ssh localhost</code>命令在虚拟机互相登录。  </p>
<h1 id="3-使用公钥登录"><a href="#3-使用公钥登录" class="headerlink" title="3. 使用公钥登录"></a>3. 使用公钥登录</h1><p>使用root账号，在第一个机器输入<code>ssh-keygen</code>，生成ssh公钥私钥，然后使用<code>ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.xxx.x</code>
发送到指定的某个机器，就可以直接使用ssh登录而不用输入密码了，因为有三台，<code>ssh-keygen</code>需要每台输入，而后面的命令需要每台输入两次，用于
连接两台电脑。<br>详细地址：<a href="http://blog.topspeedsnail.com/archives/6985" target="_blank" rel="external">http://blog.topspeedsnail.com/archives/6985</a>
<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/hadoop/hadoop-1.png" alt=""></p>
<h1 id="4-配置hosts文件"><a href="#4-配置hosts文件" class="headerlink" title="4. 配置hosts文件"></a>4. 配置hosts文件</h1><p>在第一步设置了主机名之后，接着在每台虚拟机中，设置hosts文件，以后ssh连接直接输入别名，不用输入IP。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/hadoop/hadoop-2.png" alt=""></p>
<h1 id="5-配置Java到环境变量"><a href="#5-配置Java到环境变量" class="headerlink" title="5. 配置Java到环境变量"></a>5. 配置Java到环境变量</h1><p><a href="http://www.jianshu.com/p/cde3083fc42d" target="_blank" rel="external">http://www.jianshu.com/p/cde3083fc42d</a></p>
<h1 id="6-设置请求转发"><a href="#6-设置请求转发" class="headerlink" title="6. 设置请求转发"></a>6. 设置请求转发</h1><p>我们需要主机去访问虚拟机的服务，详情设置：<a href="http://graybull.is-programmer.com/posts/36941.html" target="_blank" rel="external">http://graybull.is-programmer.com/posts/36941.html</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-虚拟机设置静态IP&quot;&gt;&lt;a href=&quot;#1-虚拟机设置静态IP&quot; class=&quot;headerlink&quot; title=&quot;1. 虚拟机设置静态IP&quot;&gt;&lt;/a&gt;1. 虚拟机设置静态IP&lt;/h1&gt;&lt;p&gt;使用VMware12安装CentOS 64位，安装一台之后，并进
    
    </summary>
    
      <category term="linux" scheme="http://www.liwenguang.cn/categories/linux/"/>
    
      <category term="hadoop" scheme="http://www.liwenguang.cn/categories/linux/hadoop/"/>
    
    
  </entry>
  
  <entry>
    <title>七、JVM体系结构与工作方式</title>
    <link href="http://www.liwenguang.cn/2017/08/12/deepknowjavaweb/7_JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.html/"/>
    <id>http://www.liwenguang.cn/2017/08/12/deepknowjavaweb/7_JVM体系结构与工作方式.html/</id>
    <published>2017-08-12T09:57:12.000Z</published>
    <updated>2017-08-13T15:58:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JVM体系结构"><a href="#1-JVM体系结构" class="headerlink" title="1. JVM体系结构"></a>1. JVM体系结构</h1><p>前言：<br>JVM能够跨计算机体系结构来执行Java字节码，主要是由于JVM屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，
使得与平台相关的耦合统一由JVM提供者来实现。</p>
<h2 id="1-何谓JVM"><a href="#1-何谓JVM" class="headerlink" title="1. 何谓JVM"></a>1. 何谓JVM</h2><p>JVM的全称是Java Virtual Machine(Java虚拟机)，它通过模拟一个计算机来达到一个计算机所具体的计算功能。
我们先来看看一个真实的计算机如何才能具备计算的功能。</p>
<ul>
<li>指令集，这个计算机能够识别的计算语言的命令集合.</li>
<li>计算单位，即能够识别并且控制指令执行的功能模块。</li>
<li>寻址方式，地址的位数、最小地址和最大地址范围，以及地址的运行规则。</li>
<li>寄存器定义，包括操作数寄存器、变址寄存器、控制寄存器等的定义、数量和使用方式。</li>
<li>存储单元，能够存储操作数和保存操作结构的单元，如内核级缓存、内存和磁盘等。</li>
</ul>
<p>在上面的几个部分中，与代码执行最密切的还是指令集部分。<br>什么是指令集？有何作用？所谓指令集就是在CPU中用来计算和控制计算机系统的一套指令的集合，每一种新型的CPU在设计时都规定了
一系列与其他硬件电路相配合的指令系统。而指令集的先进与否也关系到CPU的性能发挥，它是体现CPU性能的一个重要标志。<br>在当前计算机中有哪些指令集？从主流的体系结构上分为精简指令集(Reduced Instruction Set Computing, RISC)和复杂指令集
(Complex Instrction Set Computing, CISC)。<br>当前使用的桌面操作系统中基本上使用的都是CISC，如x86架构的的CPU都使用CISC。除了这两种指令集之外Intel和AMD公司还在它们
的基础上开发出了很多扩展指令集，包括多媒体扩展指令，以及3D处理性能开发的指令集等。<br>指令集与汇编语言有什么关系？指令集是可以直接被机器识别的机器码，也就是它必须以二进制格式存在于计算机中。而汇编语言是能够
被人识别的指令，汇编语言在顺序和逻辑上是与机器指令一一对应的。换句话说，汇编语言是为了让人能够更容易地记住机器指令而使用
的助记符。每一条汇编指令都可以直接翻译成一个机器指令，如MOVAX,1234H这条汇编语言对应的机器指令码为B83412。当然也不是所有
的汇编语言都有对应的机器指令，如nop指令。<br>指令集与CPU架构有何联系？如Intel与AMD的CPU的指令集是否兼容？也就是CPU的结构是否会影响指令集？答案都是肯定的。学过汇编语言
的人都知道在汇编语言中都是对寄存器和段的直接操作的命令，这些寄存器和段等芯片都是架构的一部分，所以不同的芯片架构设计一定会
对应到不同的机器指令集合。但是现在不同的芯片厂商往往都会采用兼容的方式来兼容其它不同架构的指令集。如AMD会兼容32为Intel的
x86系统架构的CPU，而当AMD开发出了支持64位指令的x86-64架构时，Intel又迫于压力不得不兼容这种架构而起了另外一个名字EM64T。<br>这种压力来自什么地方？当然是垄断了操作系统的微软，由于现在操作系统是管理计算机的真正入口，几乎所有的程序都要通过操作系统来调用，
所以如果操作系统不支持某种芯片的指令集，用户的程序是不可能执行的。这种情况也存在于我们国家自己设计的龙芯CPU，龙芯CPU不得不使用基于
MIPS架构的指令集(RISC)，因为目前有直接支持MIPS架构的操作系统(Linux)。如果没有操作系统和应用软件，再好的CPU也没有使用价值。
当然在一些很少用到的大型机方面不存在这个问题。<br>回到JVM的主题中来，JVM和实体机到底有何不同呢？大体有如下几点。</p>
<ul>
<li>一个抽象规范，这个规范就约束了JVM到底是什么，它有那些组成部分。</li>
<li>一个具体的实现，所谓具体的实现就是不同的厂商按照这个抽象的规范，用软件或者软件和硬件结合的方式在相同或者不同的平台上的具体实现。</li>
<li>一个运行中的实例，当用其运行一个Java程序时，它就是一个运行中的实例，每个运行中Java程序都是一个JVM实例。</li>
</ul>
<p>JVM和实体机一样也必须有一套合适的指令集，这个指令集能够被JVM解析执行。这个指令集我们称为JVM字节码指令集，
符合class文件规范的字节码都可以被JVM执行。</p>
<h2 id="2-JVM体系结构详解"><a href="#2-JVM体系结构详解" class="headerlink" title="2. JVM体系结构详解"></a>2. JVM体系结构详解</h2><p>除了指令集，JVM还需要哪些组成部分：</p>
<ul>
<li>类加载器，在JVM启动时或者在类运行时将需要的class加载到JVM中。</li>
<li>执行引擎，执行引擎的任务是负责执行class文件中包含的字节码指令，相当于实际机器上的CPU。</li>
<li>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者PC指针的记录器等。</li>
<li>本地方法调用，调用C或C++实现的本地方法的代码返回结果。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-1.png" alt="JVM体系结构"></li>
</ul>
<h3 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h3><p>在深入分析ClassLoader时我们详细分析了ClassLoader的工作机制，这里需要说明的是，每个被JVM装载的类型都有一个对应的java.lang.Class类的实例
来表示该类型，该实例可以唯一标识被JVM装载的class类，要求这个实例和其他类的实例一样都存放在Java的堆中。</p>
<h3 id="2-执行引擎"><a href="#2-执行引擎" class="headerlink" title="2. 执行引擎"></a>2. 执行引擎</h3><p>执行引擎是JVM的核心部分，执行引擎的作用就是解析JVM字节码指令，得到执行结果。在《Java虚拟机规范》中详细地定义了执行引擎遇到每条
字节码指令时应该处理什么，并且应该得到什么结果。但是并没有规定执行引擎应该如何或取什么方式处理而得到这个结果。
因为执行引擎具体采取什么方式由JVM的实现厂家自己去实现，是直接解释执行还是采用JIT技术或转成本地代码去执行，还是采用寄存器这个芯片
模式去执行都可以。所以执行引擎的具体实现有很大的发挥空间，如SUN的hotspt是基于栈的执行引擎，而Google的Dalvik是基于寄存器的执行引擎。<br>执行引擎也就是执行一条条代码的一个流程，而代码都是包含在方法体内的，所以执行引擎本质上就是执行一个个方法所串起来的流程，
对应到操作系统中一个执行流程是一个Java进程还是一个Java线程呢？很显然是后者，因为一个Java进程可以有多个同时执行的执行流程。
这样说来每个Java县城就是一个执行引擎的实例，那么在一个JVM实例中就会同时有多个执行引擎在工作，这些执行引擎有的在执行用户的程序，
有的在执行JVM内存的程序（如Java垃圾收集器）。</p>
<h3 id="3-Java内存管理"><a href="#3-Java内存管理" class="headerlink" title="3. Java内存管理"></a>3. Java内存管理</h3><p>执行引擎在执行一段程序时需要存储一些东西，如操作码需要的操作数，操作码的执行结果需要保存。class类的字节码还有类的对象等信息都需要在执行
引擎执行之前就准备好。一个JVM实例会有一个方法区、Java堆、Java栈、PC寄存器和本地方法区。其中方法区和Java堆时所有线程共享的，
也就是可以被所有的执行引擎实例访问。每个新的执行引擎实例被创建时会为这个执行引擎创建一个Java栈和一个PC寄存器，
如果当前正在执行一个Java方法，那么在当前的这个Java栈中保存的是该线程中方法调用的状态，包括方法的参数、方法的局部变量、方法的返回值
以及运算的中间结果等。而PC寄存器会指向即将执行的下一条指令。<br>如果是本地方法调用，则存储在本地方法调用栈中或者特定实现中的某个内存区域中。</p>
<h1 id="2-JVM工作机制"><a href="#2-JVM工作机制" class="headerlink" title="2. JVM工作机制"></a>2. JVM工作机制</h1><h2 id="1-机器如何执行代码"><a href="#1-机器如何执行代码" class="headerlink" title="1. 机器如何执行代码"></a>1. 机器如何执行代码</h2><p>在分析JVM的执行引擎如何工作之前，我们不妨先看看在普通的实体机上程序是如何执行的。前面已经分析了计算机只接受机器执行，其他高级语言首先必须
经过编译器编译成机器指令才能被计算机正确执行，所以从高级语言到机器语言之间必须要有个翻译的过程，我们知道机器语言一般都是和硬件平台密切相关
的，而高级语言一般都是屏蔽所有底层的硬件平台甚至包括软件平台（如操作系统）的。高级语言之所以能屏蔽这些底层硬件架构的差异就是因为有中间的
一个转换环节，这个转换环节就是便宜，与硬件耦合的麻烦就交给了编译器，所以不同的硬件平台通常需要的编译器也是不同的。在当前这种环境下我们所
说的不同的硬件平台已经被更上一层的软件平台所代替了，这个软件平台就是操作系统，与其说不同的硬件平台的差异还不如说操作系统之间的差异，因为
现在的操作系统几乎完全向用户屏蔽了硬件，所以我们说编译器和操作系统的关系非常密切会更加容易让人理解。如C语言在Windows下的编译器为Microsoft C,
而在linux下通常是gcc，当然还有很多不同厂家的编译器，这些编译器都和操作系统关系不大，只是在实现上有些差异。<br>通常一个程序从编写到执行会经历以下一些阶段：</p>
<ul>
<li>源代码(source code) -&gt; 预处理器(preprocessor) -&gt; 编译器(compiler) -&gt; 汇编程序(assembler) -&gt; 目标代码(object code) -&gt; 链接器
(Linker) -&gt; 可执行程序(executables)  </li>
</ul>
<p>除了源代码和最后的可执行程序，中间的所有环节都是由现代意义上的编译器统一完成的，如在Linux平台下我们通常安装一个软件需要经过
configure、make、make install、make clean这4个步骤来完成。</p>
<ul>
<li>configure：为这个程序在当前的操作系统环境下选择合适的编译器来编译这个程序代码，也就是为这个程序代码选择合适的编译器和一些环境参数。</li>
<li>make：自然就是对程序代码进行编译操作了，它会将源码编译成可执行的目标文件。</li>
<li>make install：将已经编译好的可执行文件安装到操作系统指定或者默认的安装目录下。</li>
<li>make clean：用于删除编译时临时产生的目录或文件。</li>
</ul>
<p>值得注意的是，我们通常所说的编译器都是将某种高级语言直接编译成可执行的目标机器语言（实际上在某种操作系统中是需要动态链接的目标二进制文件：
在Windows下是dynamic link library，DDL；在Linux下是Shared Library，SO库）。但是实际上还有一些编译器是将一种高级语言编译成
另一种高级语言，或者将低级语言编译成高级语言（反编译），或者将高级语言编译成虚拟机目标语言，如Java编译器等。<br>再回到如何让机器（不管是实体机还是虚拟机）执行代码的主题，不管是何种指令集都只有集中最基本的元素：加、减、乘、求余、求模等。
这些运算又可以进一步分解成二进制位运算：与、或、异或等。这些运算又通过指令来完成，而指令的核心目标就是确定需要运算的种类（操作码）
和运算需要的数据（操作数），以及从哪里（寄存器或栈）获取操作数、将运算结果存放到什么地方（寄存器或是栈）等。这种不同的操作
方式又将指令划分为：一地址指令、二地址指令、三地址指令和零地址指令等n地址指令。相应的指令集会有对应的架构实现，如基于寄存器
的架构实现或基于栈的架构实现，这里的基于寄存器或者栈都是指在一个指令中的操作数是如何存取的。</p>
<h2 id="2-JVM为何选择基于栈的架构"><a href="#2-JVM为何选择基于栈的架构" class="headerlink" title="2. JVM为何选择基于栈的架构"></a>2. JVM为何选择基于栈的架构</h2><p>JVM执行字节码指令是基于栈的架构，也就是所有的操作数必须先入栈，然后根据指令中的操作码选择从栈顶弹出若干个元素进行计算后再将结果压入栈中。
在JVM中操作数可以存放在每一个栈帧中国的一个本地变量集中，即在每个方法调用时就会给这个方法分配一个本地变量集，这个本地变量集在编译时就已经
确定，所以操作数入栈可以直接是常量入栈或者从本地变量集中取一个变量压入栈中。这和一般的基于寄存器的操作有所不同，一个操作需要频繁的入栈和出栈，
如进行一个加法运算，如果啷个操作数都在本地变量中，那么一个加法操作就要有5次栈操作，分别是将两个操作数从本地变量入栈（2次入栈操作），再将
两个操作数出栈用于加法运算（2次出栈），再将加法结果压入栈顶（1次入栈）。如果是基于寄存器的话，一般只需要将两个操作数存入寄存器进行加法运算后
再将结果存入其中一个寄存器即可，不需要这么多的数据移动的操作。那么为什么JVM还要基于栈来设计呢？<br>JVM为何要基于栈来设计有几个理由。一个是JVM要设计成与平台无关的。而平台无关性就是要保证在没有或者有很少的寄存器的机器上也要同样能正确的执行
Java代码。例如，在80x86的机器上寄存器就是没有规律的，很难针对某一款机器设计通用的基于寄存器的指令，所以基于寄存器的架构很难做到通用。在
手机操作系统方面，Google的Android平台上的Dalvik VM就是基于特定芯片（ARM）设计的基于寄存器的架构，这样在特定芯片上实现基于寄存器的架构
可能更多考虑性能，但是也牺牲了跨平台的移植性，当然在当前的手机上这个需求还不是最迫切的。<br>还有一个理由是为了指令的紧凑性，因为Java的字节码可能在网络上传输，所以class文件的大小也是设计JVM字节码指令的一个重要因素，如在class文件
中字节码除了处理两个表示跳转的指令外，其他都是字节对齐的，操作码可以只占一个字节大小，这都是为了尽量让编译后的class文件更加紧凑。为了提高
字节码在网络上的传输效率。Sun设计了一个Jar包的压缩工具Pack2000，它可以将多个class文件中的重复的常量池的信息进行合并，如一般在每个calss文件
中都含有“Ljava/lang/String;”，那么多个class文件中的常量就可以共用，从而起到减少数据量的作用。  </p>
<h2 id="3-执行引擎的架构设计"><a href="#3-执行引擎的架构设计" class="headerlink" title="3. 执行引擎的架构设计"></a>3. 执行引擎的架构设计</h2><p>每当创建一个新的线程时，JVM会为这个线程创建一个Java栈，同时会为线程分配一个PC寄存器，并且这个PC寄存器会指向这个线程的第一行可执行代码。
每当调用一个新方法时会在这个栈上创建一个新的栈帧数据结构，这个栈帧会保留这个方法的一些元信息，如在这个方法中定义的局部变量、
一些用来支持常量池的解析、正常方法返回及异常处理机制等。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-2.png" alt="Java执行部件"><br>JVM在调用某些指令时可能需要使用到常量池中的一些常量，或者是获取常量代表的数据或者这个数据指向的实例化对象，而这些信息都存储在所有线程共享
的方法区和Java堆中。</p>
<h2 id="4-执行引擎的执行过程"><a href="#4-执行引擎的执行过程" class="headerlink" title="4. 执行引擎的执行过程"></a>4. 执行引擎的执行过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> c = (a+b) * <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中main的字节码指令如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-3.png" alt="字节码指令"><br>对应到执行引擎的各执行部件如下所示：（注意：原书图的标记有问题，这里仍然使用错误的标记易于理解）<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-4.png" alt="初始化"><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-5.png" alt="前四条指令，入栈，出栈存储；入栈，出栈存储"><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-6.png" alt="第4、5条指令执行之后，顺序入栈"><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-7.png" alt="第6条指令执行之后，栈顶放入3"><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-8.png" alt="第7条指令执行之后"><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-9.png" alt="第10条指令执行之后，30将进入局部变量"><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-10.png" alt="第11条执行之后"></p>
<h2 id="5-JVM方法调用栈"><a href="#5-JVM方法调用栈" class="headerlink" title="5. JVM方法调用栈"></a>5. JVM方法调用栈</h2><p>JVM的方法调用分两种：一种是Java方法调用，另一种是本地方法调用。本地方法调用由于各个虚拟机的实现不太相同(因为跨平台)，所以这里主要介绍Java的方法调用情况。
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> c = math(a, b) / <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (a + b) * <span class="number">10</span>;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-11.png" alt=""><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-7-1-12.png" alt=""><br>调用细节就不贴图了，记住一点，任何的数据都要入栈，进入存储到变量区时，都要出栈。PC寄存器存储的是下一条指令的指针。</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ul>
<li>计算机的体系结构：指令集（机器语言）、计算单元（控制指令）、寻址方式（地址的位数，寻址范围）、寄存器、存储单元（存储操作数和保存操作结构）。</li>
<li>class(通过ClassLoader类加载器后)-&gt;执行引擎(内存、方法区、堆、栈、PC寄存器)-&gt;调用本地方法接口(native)</li>
<li>JVM和DVM（Dalvik）的核心区别在于，一个基于栈一个基于寄存器，为什么Sun和Google设计的不一样？后者相对来说，执行效率更高，但是前者真正实现
了跨平台，后者是每个APP都是一个VM，就相当于一个操作系统里面运行了多个DVM，而Sun是，一个操作系统运行一个JVM里面运行多个java程序。（相对
而言，Dalvik是可以预加载（Zygote）的，更叼一点，只不过Dalvik为了增加效率（毕竟运行在手机中），在运行时，不同应用是共享相同的类（打开QQ相机，
你再打开微信相机试试？），而JVM里面的程序，打包之后，运行之后，是真正的独立的程序，即便在包里使用了相同的类，运行都是独立加载的。
<a href="https://www.zhihu.com/question/20207106" target="_blank" rel="external">这里有更加详细的解答，博主也是抽出的简单精华。</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JVM体系结构&quot;&gt;&lt;a href=&quot;#1-JVM体系结构&quot; class=&quot;headerlink&quot; title=&quot;1. JVM体系结构&quot;&gt;&lt;/a&gt;1. JVM体系结构&lt;/h1&gt;&lt;p&gt;前言：&lt;br&gt;JVM能够跨计算机体系结构来执行Java字节码，主要是由于JVM屏
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://www.liwenguang.cn/categories/readNote/deepJavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>六、深入分析ClassLoader工作机制</title>
    <link href="http://www.liwenguang.cn/2017/08/10/deepknowjavaweb/6_%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.html/"/>
    <id>http://www.liwenguang.cn/2017/08/10/deepknowjavaweb/6_深入分析ClassLoader工作机制.html/</id>
    <published>2017-08-10T15:19:20.000Z</published>
    <updated>2017-08-11T17:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ClassLoader的等级加载机制"><a href="#1-ClassLoader的等级加载机制" class="headerlink" title="1. ClassLoader的等级加载机制"></a>1. ClassLoader的等级加载机制</h1><ol>
<li>如何保证不同等级的会员通过不同的会员接待室进入会场？<br>有可能有些会员并不能正确的找到接待自己的接待室，也有可能有些会员冒充更高级的会员身份混进去，所以必须要有机制能够保证所有会员都被正确的接待室接待进入会场，而且一个会员只能被一个接待室接待，不能出现被两个接待室
重复接待的情况。如何设计这个接待规则呢？  </li>
<li>ClassLoader就设计了这样一种接待机制，即上级(双亲)委托接待机制。<br>任何一个会员到达任何一个会员接待室时，这个接待室首先会检查这个会员P是否已经被自己A接待过，如果已经接待过，则拒绝本次接待，如果自己没有接待过，那么会向上B询问这个会员是否应该在
上一级的更高级别的接待室B接待，上级接待室B会根据它们的接待规则，检查这个会员是否被自己B接待过，如果接待过，将已经接待的结果反馈下一级A，
如果也没有接待过，则向上一级询问这个会员P是否应该在上一级的更高级别的接待室接待，一直这样接待，直到有一级接待室接待或者告诉它
下一级这个会员不是自己接待的结果；  </li>
<li>如果这个会员来到的这个接待室A得到它上一级B的接待室反馈认为这个会员没有被接待，并且也不应该由它们BC接待，这个接待室A将会正式
接待这个会员，并发入会证明，这个会员就被定义为这个接待室等级的会员。  </li>
<li>整个JVM平台提供三层ClassLoader，这三层ClassLoader可以分为两种类型，可以理解为：为接待室服务的接待室和为会员服务的接待室两种。</li>
</ol>
<h2 id="1-BootstrapClassLoader"><a href="#1-BootstrapClassLoader" class="headerlink" title="1. BootstrapClassLoader"></a>1. BootstrapClassLoader</h2><p>这个ClassLoader就是接待室服务自身的，它主要加载JVM自身工作需要的类，这个ClassLoader完全是由JVM自己控制的，需要加载哪个类、
怎么加载都由JVM自己控制，别人也访问不到这个类，所以这个ClassLoader是不遵守前面介绍的加载规则的，它仅仅是一个类的加载工具而已，
既没有更高一级的父加载器，也没有子加载器。</p>
<h2 id="2-ExtClassLoader"><a href="#2-ExtClassLoader" class="headerlink" title="2. ExtClassLoader"></a>2. ExtClassLoader</h2><p>这个类加载器有点特殊，它是JVM自身的一部分，但是它的血统不是很纯正，它并不是JVM亲自实现的，我们可以理解为这个类加载器是那些与这个大会合作单位的员工会员，
这些会员既不是JVM内部的，也和普通的外部会员不同，所以就由这个类即在其来加载。它服务的特定目标在<code>System.getProperty(&quot;java.ext.dirs&quot;)</code>目录下。</p>
<h2 id="3-AppClassLoader"><a href="#3-AppClassLoader" class="headerlink" title="3. AppClassLoader"></a>3. AppClassLoader</h2><p>这个类加载器就是专门为接待会员服务的，它的父类是ExtClassLoader。它服务的目标是广大普通会员，所有在<code>System.getProperty(&quot;java.class.path&quot;)</code>
目录下的类都可以被这个类加载器加载，这个目录就是我们经常用到的classpath。</p>
<p>如果我们要实现自己的类加载器，不管你是直接实现抽象类ClassLoader，还是继承URLClassLoader类，或者其他子类，它的父加载器都是AppClassLoader，
因为不管调用哪个父类构造器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器。而getSystemClassLoader()方法获取
到的正是AppClassLoader。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-6-1-1.png" alt="应用中类加载器的等级层次"><br>很多文章在介绍ClassLoader的等级结构时把Bootstrap ClassLoader也列在ExtClassLoader的上一级中，其实BootstrapClassLoader并不属于JVM的类等级层次，
因为BootstrapClassLoader并没有遵守ClassLoader的加载规则。另外BootstrapClassLoader并没有子类。<br>ExtClassLoader的父类也不是BootstrapClassLoader，ExtClassLoader并没有父类，我们在应用中能提取到的顶层父类是ExtClassLoader。<br>ExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，它们是Launcher类的内部类。<br>如果在Java应用中没有定义其他ClassLoader，那么除了<code>System.getProperty(&quot;java.ext.dirs&quot;)</code>目录下的类是由ExtClassLoader加载外，
其他类都由AppClassLoader加载。<br>JVM加载class文件到内存由两种方式。</p>
<ul>
<li>隐式加载：即不在代码里调用ClassLoader来加载所需要的类，而是通过JVM来自动加载所需要的类到内存的方式。例如，当我们在类中继承或者引用某个类时，
JVM在解析当前这个类时发现引用的类不在内存中，那么就会自动将这么类加载到内存中。</li>
<li>显式加载：即调用<code>this.getClass().getClassLoader().loadClass()</code>或者<code>Class.forName()</code>，或者我们自己实现的ClassLoader的findClass()方法等。<blockquote>
<p>ClassLoader().loadClass()底层是loadClass(name, false),即只加载不解析。而Class.forName()底层是forName0(className, true, ClassLoader.getClassLoader(caller), caller)，
即初始化。注意：在Java中，类装载分三步，对应三种状态，即：加载-&gt;链接(校验、准备、解析)-&gt;初始化。第一种对应的加载后，第二种对应的时链接后。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-6-1-2.png" alt="类装载"><br>例如：即要对驱动初始化才能使用就使用的后者加载Class.forName(“com.mysql.jdbc.Driver”)。</p>
</blockquote>
</li>
</ul>
<h1 id="2-如何加载class文件"><a href="#2-如何加载class文件" class="headerlink" title="2. 如何加载class文件"></a>2. 如何加载class文件</h1><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-6-1-3.png" alt="JVM加载类">  </p>
<ul>
<li>找到.class文件，并把这个文件包含的字节码加载到内存中。</li>
<li>字节码验证、Class类数据结构分析、内存分配，符号表的链接。</li>
<li>[类中静态属性和初始化赋值][1]，以及静态块的执行等。</li>
</ul>
<h2 id="1-加载字节码到内存"><a href="#1-加载字节码到内存" class="headerlink" title="1. 加载字节码到内存"></a>1. 加载字节码到内存</h2><p>抽象类ClassLoader中并没有定义如何去加载，让子类具体实现找到指定类并把它的字节码加载到内存需要的子类中，
例如：URLClassLoader如何实现的findClass()方法，这个类底层通过URLClassPath取得要加载的class文件字节流，
而这个URLClassPath定义了到哪里去找这个class文件，如果找到了这个class文件，再读取它的byte字节流，通过
调用defineClass()方法来创建类对象。<br>URL数组是创建URLClassPath对象的必要条件。</p>
<h2 id="2-验证与解析"><a href="#2-验证与解析" class="headerlink" title="2. 验证与解析"></a>2. 验证与解析</h2><ul>
<li>字节码验证：确保格式正确、行为正确。</li>
<li>类准备：准备类中定义的字段、方法和实现接口所必须的数据结构</li>
<li>解析：类装入器装入类所引用的其他所有累。如超类(父类)、接口、字段、方法签名、方法中使用的本地变量。</li>
</ul>
<h2 id="3-初始化Class对象"><a href="#3-初始化Class对象" class="headerlink" title="3. 初始化Class对象"></a>3. 初始化Class对象</h2><p>在类中包含的静态初始化器都被执行，在这一阶段末尾静态字段被初始化为默认值。</p>
<h1 id="3-常见加载类错误分析"><a href="#3-常见加载类错误分析" class="headerlink" title="3. 常见加载类错误分析"></a>3. 常见加载类错误分析</h1><h2 id="1-ClassNotFoundException"><a href="#1-ClassNotFoundException" class="headerlink" title="1. ClassNotFoundException"></a>1. ClassNotFoundException</h2><p>JVM要加载指定文件的字节码到内存时，并没有找到这个文件对应的字节码文件，即.class文件不存在。解决的办法就是检查
在当前的classpath目录下有没有指定的文件存在。可通过以下命令：<br><code>this.getClass().getClassLoader().getResource(&quot;&quot;).toString()</code><br>获取之后结果，让我大吃一惊，这不是我用idea设置的output文件夹么，原来idea设置的output文件夹有这个作用！</p>
<h2 id="2-NoClassDefFoundError"><a href="#2-NoClassDefFoundError" class="headerlink" title="2.NoClassDefFoundError"></a>2.NoClassDefFoundError</h2><p>确保每个类引用的类都在当前的classpath下面。</p>
<h2 id="3-UnsatisfiedLinkError"><a href="#3-UnsatisfiedLinkError" class="headerlink" title="3. UnsatisfiedLinkError"></a>3. UnsatisfiedLinkError</h2><p>常见在JVM启动时，JVM中的某个lib删除了，可能会报这个错误（并这个lib中包含native标示的方法）。</p>
<h2 id="4-ClassCastException"><a href="#4-ClassCastException" class="headerlink" title="4. ClassCastException"></a>4. ClassCastException</h2><ul>
<li>对于普通对象，对象必须是目标类的实例或目标类的子类的实例。如果目标类是接口，那么 会把它当作实现了该接口的一个子类。</li>
<li><p>对于数组类型，目标类型必须是数组类型或java.lang.Object、java.lang.Cloneable、java.io.Serializable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>&#125;;</div><div class="line">Object b = a;</div><div class="line">Cloneable c = a;</div><div class="line">Serializable d = a;</div><div class="line">System.out.println(b + <span class="string">","</span> + c + <span class="string">","</span> + d);</div><div class="line"><span class="comment">//output:[Ljava.lang.Integer;@78e03bb5,[Ljava.lang.Integer;@78e03bb5,[Ljava.lang.Integer;@78e03bb5</span></div></pre></td></tr></table></figure>
</li>
<li><p>建议先使用instanceof检查是不是目标类型，再进行强制类型转换。</p>
</li>
</ul>
<h2 id="5-ExceptionInInitializerError"><a href="#5-ExceptionInInitializerError" class="headerlink" title="5. ExceptionInInitializerError"></a>5. ExceptionInInitializerError</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map m = <span class="keyword">new</span> HashMap()&#123;</div><div class="line">        &#123;</div><div class="line">            m.put(<span class="string">"a"</span>,<span class="string">"2"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sss</span><span class="params">()</span> </span>&#123;</div><div class="line">    Integer s = (Integer) m.get(<span class="string">"a"</span>);</div><div class="line">    System.out.println(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化类的时候，给静态属性m赋值出现了异常导致抛出错误。</p>
<h1 id="4-常用ClassLoader分析"><a href="#4-常用ClassLoader分析" class="headerlink" title="4. 常用ClassLoader分析"></a>4. 常用ClassLoader分析</h1><p>基于对Tomcat的源码分析，对部署在Tomcat的Servlet的项目，执行
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</div><div class="line"><span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</div><div class="line">    System.out.println(classLoader.getClass().getCanonicalName());</div><div class="line">    classLoader = classLoader.getParent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Tomcat本身自己实现了WebappClassLoader，会优先检查WebappClassLoader加载到额缓存，而不是JVM的findLoaderClass缓存。<br>并设置WebappClassLoadera的加载路径为WEB-INF/classes目录，查找文件的字节码，然后保存类的元信息，方便下次查找。
（前提是被查找的类再BootstrapClassLoader、ExtClassLoader、AppClassLoader等父加载器都反馈为不为他们加载）。</p>
<h1 id="5-如何实现自己的ClassLoader"><a href="#5-如何实现自己的ClassLoader" class="headerlink" title="5. 如何实现自己的ClassLoader"></a>5. 如何实现自己的ClassLoader</h1><p>ClassLoader能够完成的事情：</p>
<ul>
<li>在自定义路径下查找定义的class类文件，也许我们需要的class文件并不总在已经设置好的ClassPath下面，那么我们
必须想办法来找到这个类，这时，就需要自己实现一个ClassLoader。</li>
<li>对我们自己的要加载的类做特殊处理，如保证通过网络传输的类的安全性，可以将类经过加密后再传输，再加载到JVM
之前需对类的字节码再解码，这个过程就可以在自定义的ClassLoader中实现。</li>
<li>可以定义类的实现机制，我们可以检查已经加载的class文件是否被修改，如果修改了，可以重新加载这个类，从而实现
类的热部署。</li>
</ul>
<h2 id="1-加载自定义路径下的class文件"><a href="#1-加载自定义路径下的class文件" class="headerlink" title="1. 加载自定义路径下的class文件"></a>1. 加载自定义路径下的class文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String classPath;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String packageName = <span class="string">"com.lwg.classknow"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.classPath = classPath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        <span class="keyword">if</span> (name.startsWith(packageName)) &#123;</div><div class="line">            <span class="comment">// 这里写从自己的缓冲中寻找，找到就直接返回。</span></div><div class="line">            <span class="keyword">byte</span>[] classData = getData(name);</div><div class="line">            <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 这里写放入自己的缓存中，或者注册到一个Bean管理器，统一管理等。</span></div><div class="line">                <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getData(String className) &#123;</div><div class="line">        String path = classPath + File.separator + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">// 如果是通过某种加密的文件，则这么可以进行特殊的解密</span></div><div class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(path);</div><div class="line">            ByteArrayOutputStream stream = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> ((num = is.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">                stream.write(buffer, <span class="number">0</span>, num);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> stream.toByteArray();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</div><div class="line">        PathClassLoader loader = <span class="keyword">new</span> PathClassLoader(<span class="string">"C:\\lwg\\lwg\\out\\production\\lwg"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class cus = loader.findClass(<span class="string">"com.lwg.classknow.classloader.ssss"</span>);</div><div class="line">            System.out.println(cus); <span class="comment">//output:class com.lwg.classknow.classloader.ssss</span></div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有直接继承URLClassLoader(下面代码没有经过验证):
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLPathClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String packageName = <span class="string">"com.lwg.classknow.classloader"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">URLPathClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(urls, parent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        Class&lt;?&gt; clz = findLoadedClass(name);</div><div class="line">        <span class="keyword">if</span> (clz != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> clz;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!packageName.startsWith(name)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findClass(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException </span>&#123;</div><div class="line">        URLPathClassLoader loader = <span class="keyword">new</span> URLPathClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(<span class="string">"http://www.xxx.com"</span>)&#125;, <span class="keyword">null</span>);</div><div class="line">        loader.findClass(<span class="string">"com.lwg.classknow.classloader.ssss"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="6-实现类的热部署"><a href="#6-实现类的热部署" class="headerlink" title="6. 实现类的热部署"></a>6. 实现类的热部署</h1><p>JVM在加载类之前会检查请求的类是否已经被加载起来，也就是要调用findLoaderClass()方法查看是否能偶返回类实例。如果类已经加载过来，再调用
loadClass()将会导致类冲突。但是JVM标示一个类是否是同一个类会有两个条件。</p>
<ul>
<li>类的完整类名是否一样，这个类名包括类所在的包名。</li>
<li>加载这个类的ClassLoader是否是同一个实例。<br>所以要实现类的热部署可以创建不同的ClassLoader的实例对象，然后通过对这个不同的实例对象来加载同名的类。</li>
</ul>
<p>使用不同的ClassLoader实例加载同一个类，会不会导致JVM的PermGen区无限增大？答案是否定的，因为我们的ClassLoader对象也会和其他对象一样，
当没有对象再引用它以后，也会被JVM回收。但是需要注意的一点是，被这个ClassLoader加载的类的字节码会保存在JVM的PermGen区，这个数据一般
只是在执行Full GC时才会被回收的，所以如果在你的应用中都是大量的动态类加载，Full GC又不是太频繁，也要注意PermGen区的大小，防止内存溢出。</p>
<h1 id="7-Java应不应该动态加载类"><a href="#7-Java应不应该动态加载类" class="headerlink" title="7. Java应不应该动态加载类"></a>7. Java应不应该动态加载类</h1><p>我想大家都知道用Java有一个痛处，就是修改一个类，必须要重启一遍，很费时。于是就想能不能来个动态类的加载而不需要重启JVM，如果你了解JVM
的工作机制，就应该放弃这个念头。<br>Java的优势正是基于共享对象的机制，达到信息的高度共享，也就是通过保存并持有对象的状态而省去类信息的重复创建和回收。我们知道对象一旦被创建，
这个对象就可以被人持有和引用。<br>假如，我们能够动态加载一个对象进入JVM，但是如何做到JVM中对象的平滑过渡？几乎不可能！虽然在JVM中对象只有一份，在理论上可以直接诶替换这个
对象，然后更新Java栈中所有对原对象的引用关系。看起来好像对象可以被替换了，但是这仍然不可行，因为它违反了JVM的设计原则，对象的引用关系
只有对象的创建者持有和使用，JVM不可以干预对象的引用关系，因为JVM并不知道对象是怎么被使用的，这就涉及JVM并不知道对象的运行时类型
而只知道编译时类型。<br>假如一个对象的属性结构被修改，但是在运行时其他对象可能仍然引用该属性。<br>虽然完全的无障碍的替换时不现实的，但是如果你非要那么做，也还是可以。前面的分析造成不能动态提供类对象的关键是，对象的状态被保存了，
并且被其他对象引用了，一个简单的解决方法就是不保存对象的状态，对象被创建使用后被释放掉，下次修改后，对象也就是新的了。<br>这就是JSP，动态的加载类，所有其他解释型语言都是如此。</p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>ClassLoader的基本工作机制，以及双亲委派机制的解释，自己创建ClassLoader以及热部署的原理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-ClassLoader的等级加载机制&quot;&gt;&lt;a href=&quot;#1-ClassLoader的等级加载机制&quot; class=&quot;headerlink&quot; title=&quot;1. ClassLoader的等级加载机制&quot;&gt;&lt;/a&gt;1. ClassLoader的等级加载机制&lt;/h1
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://www.liwenguang.cn/categories/readNote/deepJavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>五、深入class文件结构</title>
    <link href="http://www.liwenguang.cn/2017/08/10/deepknowjavaweb/5_%E6%B7%B1%E5%85%A5class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html/"/>
    <id>http://www.liwenguang.cn/2017/08/10/deepknowjavaweb/5_深入class文件结构.html/</id>
    <published>2017-08-10T14:06:20.000Z</published>
    <updated>2017-08-10T15:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JVM指令集简介"><a href="#1-JVM指令集简介" class="headerlink" title="1. JVM指令集简介"></a>1. JVM指令集简介</h1><p>前言：<br>从底层讲解Java为什么是“一次编译导出运行”，以及一个class文件的内容。<br>在分析class文件之前我们先学会使用Oolong汇编语言，它能将class文件的二进制表示的结构形式先转化成能够理解的汇编语言。下载Oolong.jar
包后将其放在jdk的lib目录下，然后增加一个CLASSPATH精准的指向该Oolong.jar目录。
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lwg.classknow;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"junshan say: Hello World"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在当前class文件目录下，命令行输入:<code>java COM.sootNsmoke.oolong.Gnoloo Message.class</code>即可获得Message.j文件，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">.source Message.java</div><div class="line">.class public super com/lwg/classknow/Message</div><div class="line">.super java/lang/Object</div><div class="line"></div><div class="line"></div><div class="line">.method public &lt;init&gt; ()V</div><div class="line">.limit stack 1</div><div class="line">.limit locals 1</div><div class="line">.var 0 is this Lcom/lwg/classknow/Message; from l0 to l5</div><div class="line">.line 3</div><div class="line">l0:    aload_0</div><div class="line">l1:    invokespecial java/lang/Object/&lt;init&gt; ()V</div><div class="line">l4:    return</div><div class="line"></div><div class="line">.end method</div><div class="line"></div><div class="line">.method public static main ([Ljava/lang/String;)V</div><div class="line">.limit stack 3</div><div class="line">.limit locals 1</div><div class="line">.var 0 is args [Ljava/lang/String; from l0 to l14</div><div class="line">.line 5</div><div class="line">l0:    getstatic java/lang/System/out Ljava/io/PrintStream;</div><div class="line">l3:    ldc &quot;junshan say: Hello World&quot;</div><div class="line">l5:    iconst_0</div><div class="line">l6:    anewarray java/lang/Object</div><div class="line">l9:    invokevirtual java/io/PrintStream/printf (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;</div><div class="line">l12:    pop</div><div class="line">.line 6</div><div class="line">l13:    return</div><div class="line"></div><div class="line">.end method</div></pre></td></tr></table></figure></p>
<p>汇编比较复杂，就不深究了，但是要知道，跨平台其实是JVM的跨平台，.java-&gt;.class-&gt;JVM(跨平台)-&gt;机器码(平台)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JVM指令集简介&quot;&gt;&lt;a href=&quot;#1-JVM指令集简介&quot; class=&quot;headerlink&quot; title=&quot;1. JVM指令集简介&quot;&gt;&lt;/a&gt;1. JVM指令集简介&lt;/h1&gt;&lt;p&gt;前言：&lt;br&gt;从底层讲解Java为什么是“一次编译导出运行”，以及一个c
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://www.liwenguang.cn/categories/readNote/deepJavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>四、Javac编译原理</title>
    <link href="http://www.liwenguang.cn/2017/08/08/deepknowjavaweb/4_Javac%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.html/"/>
    <id>http://www.liwenguang.cn/2017/08/08/deepknowjavaweb/4_Javac编译原理.html/</id>
    <published>2017-08-08T02:21:21.000Z</published>
    <updated>2017-08-10T14:03:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Javac是什么"><a href="#1-Javac是什么" class="headerlink" title="1. Javac是什么"></a>1. Javac是什么</h1><p>前言：<br>Java语言与Java语言规范，Java虚拟机有Java虚拟机规范，如何让Java的语法规则适应Java虚拟机的语法规范呢？它的任务就是
由Javac编译器完成的，将Java语言规范转化为Java虚拟机语言规范，完成“翻译”工作。
Javac是一种编译器，将一种语言规范转化成另外一种语言规范。虽然机器码执行非常高效，但是对人不友好，开发这个代码
的成本远远高于省下的机器的执行成本，所以才有了编译器的出现，有了编译器才有可能出现这么多的高级编程语言。<br>关于具体的机器，平台，Javac是不管的，这是JVM的事情，Javac的任务就是将Java源代码语言先转化成JVM能够识别的
一种语言，然后由JVM将JVM语言再转化为当前这个机器能够识别的机器语言。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-4-1-1.png" alt="Javac"><br>表面上Javac的任务就是将Java源码编译成Java字节码，也就是JVM能够识别的二进制码，即.java-&gt;.class的转化
而实际上Java的源码转为一连串二进制数字，这些二进制数字是有格式的，只有JVM能够正确识别它们表达的意思。</p>
<h1 id="2-Javac编译器的基本结构"><a href="#2-Javac编译器的基本结构" class="headerlink" title="2. Javac编译器的基本结构"></a>2. Javac编译器的基本结构</h1><p>必须要先知道一个编译器完成一个语言规范到另一种语言规范的转化需要哪些步骤，如何完成这些步骤，也就是这个编译器
的基本结构是什么。  </p>
<ul>
<li>词法分析：首先，读取源代码，一个字节为一节地都进来，找出这些字节中哪些是我们定义的语法关键字，如Java中的if、else等关键词：
要识别哪些if是合法的关键词，哪些不是，这个步骤就是词法分析过程。<br>词法分析的结构就是从源代码中找出一些规范化的Token流，就像在人类预言中，一句话中哪些是词语，哪些是标点符号，哪些是
动词，哪些是名词等。  </li>
<li>语法分析：接着就是对Token流进行语法分析，即检查是不是符合Java语言规范，如if的后面是不是紧跟着一个布尔判断表达式。就像人类<br>语言是不是有主谓宾。<br>语法分析的结果就是形成一个符合Java语言规范的抽象语法树，对这棵语法树我们可以在后面按照新的规则再重新组织。<br>语法分析之后的结果是符合规范的。</li>
<li>词义分析：的结果就是将复杂的语法转化成最简单的语法，对应到Java中，如将foreach转成for循环结构，还有注
解等，最后形成一个注解过后的抽象语法树，这棵语法树更接近目标语言的语法规则。  </li>
<li>代码生成器：就是最后生成符合Java虚拟机规范的字节码了。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-4-1-2.png" alt="Javac组件"><br>即：主要四个模块：词法分析器、语法分析器、词义分析器、代码生成器。</li>
</ul>
<h1 id="3-Javac工作原理分析"><a href="#3-Javac工作原理分析" class="headerlink" title="3. Javac工作原理分析"></a>3. Javac工作原理分析</h1><h2 id="1-词法分析器"><a href="#1-词法分析器" class="headerlink" title="1. 词法分析器"></a>1. 词法分析器</h2><p>从源文件的第一个字符开始，按照Java语法规范依次找出package、import、类定义以及属性和方法定义等，最后生成一个Token流。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-4-1-3.png" alt="Token流"><br>其中有两个关键点：</p>
<ul>
<li>Javac是如何分辨这一个个Token的呢？例如，它怎么知道package就是一个Token.PACKAGE,而不是用户自定义的Token.
IDENTIFIEDR的名称呢?</li>
<li>Javac是如何分辨一个Token的，如compile这个词就是一个Token，为什么不是com或者comp抑或compi等，也就是Javac是如何知道
哪些字符组合在一起就是一个Token的呢？</li>
</ul>
<p>答案是：Java有特定的语法规则，即空格分词，第一个是package，一行结束最后必然是}或者;等。<br>而Token类似一个key、value的数据结构，PACKAGE:package。</p>
<h2 id="2-语法分析器"><a href="#2-语法分析器" class="headerlink" title="2. 语法分析器"></a>2. 语法分析器</h2><p>获得了Token流，接着，获取每个token的值，根据Java语法规则，进行顺序的，使用不同的解析方法进行解析，例如发现这个Token是import，则使用import语法分析，检查是否有static关键字
等，判断是否静态引入。<br>接着进行类的解析，包括interface、class、enum等，分别进行语法分析。<br>最后进行classBody的解析，即按照变量定义解析、方法定义解析和内部类定义解析进行的。这个过程比较复杂，将结果保存再list集合中，最后添加到class（假如是class）树中。<br>例如下面的class和语法树的对应关系：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yufa</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c = a + <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-4-1-4.png" alt="class对应的语法树"><br>部分节点在图中省略了。最后这个类节点加入到这个类对应的包路径的顶层节点中：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-4-1-5.png" alt="包语法树"></p>
<h2 id="3-语义分析器"><a href="#3-语义分析器" class="headerlink" title="3. 语义分析器"></a>3. 语义分析器</h2><p>我们需要将树进行细化，例如：添加默认的构造函数，检查变量在使用前是否初始化，将一些常量进行合并处理，检查操作变量类型是否匹配，
检查checked exception异常是否已经捕获或抛出，解除Java的语法糖等等，还有符号，有专门的类进行完成。<br>还有专门进行处理annotation（注解）分析，以及变量的自动转化，包装等。<br>内部类是如何解析的呢？
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yuyi</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Inner inner = <span class="keyword">new</span> Inner();</div><div class="line">        inner.print();</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"print"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后被解析成：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yuyi</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yuyi</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Yuyi$Inner inner = <span class="keyword">new</span> Yuyi$Inner(<span class="keyword">this</span>);</div><div class="line">        inner.print();</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yuyi</span>$<span class="title">Inner</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> Yuyi <span class="keyword">this</span>$<span class="number">0</span>;</div><div class="line">    </div><div class="line">    Yuyi$Inner(<span class="keyword">final</span> Yuyi <span class="keyword">this</span>$<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"print"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内部类会有外部类对象的引用，并且会独立出来。</p>
<h2 id="4-代码生成器"><a href="#4-代码生成器" class="headerlink" title="4. 代码生成器"></a>4. 代码生成器</h2><h1 id="4-设计模式解析之访问者模式"><a href="#4-设计模式解析之访问者模式" class="headerlink" title="4. 设计模式解析之访问者模式"></a>4. 设计模式解析之访问者模式</h1><p>遍历语法树，都会进行不同的处理工作，同时也对这棵语法树进行进一步处理。实际采用的访问者模式设计，每次遍历都是
一次访问者的执行过程。<br>访问者，得到被访问者的实例，并进行操作。
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(JCCompiletionUnit_tree jcCompiletionUnitTree)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(JCIf_tree jcIfTree)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attr_visitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(JCCompiletionUnit_tree jcCompiletionUnitTree)</span> </span>&#123;</div><div class="line">        jcCompiletionUnitTree.length  = <span class="number">2</span>;</div><div class="line">        System.out.println(<span class="string">"Attr_visitor修改Unit_tree"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(JCIf_tree jcIfTree)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Attr_visitor修改JCIf_tree"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enter_visitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(JCCompiletionUnit_tree jcCompiletionUnitTree)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter_visitor修改Unit_tree"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(JCIf_tree jcIfTree)</span> </span>&#123;</div><div class="line">        jcIfTree.length = <span class="number">3</span>;</div><div class="line">        System.out.println(<span class="string">"Enter_visitor修改Unit_tree"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>被访问者，有个接受访问者的方法，接着将自己放入到这个被访问者中，比较绕：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> Integer length;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tree</span> <span class="params">(Integer length)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLength</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(Integer length)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JCIf_tree</span> <span class="keyword">extends</span> <span class="title">Tree</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JCIf_tree</span><span class="params">(Integer length)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"被访问者的JCIf方法"</span>);</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JCCompiletionUnit_tree</span> <span class="keyword">extends</span> <span class="title">Tree</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JCCompiletionUnit_tree</span><span class="params">(Integer length)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"被访问者的unit方法"</span>);</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是主函数：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line"></div><div class="line">    List&lt;Tree&gt; trees = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Tree tree)</span> </span>&#123;</div><div class="line">        trees.add(tree);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Visitor visitor)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Tree tree : trees) &#123;</div><div class="line">            tree.accept(visitor);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVisitorPattrn</span><span class="params">()</span></span>&#123;</div><div class="line">        Visitor attr_visitor = <span class="keyword">new</span> Attr_visitor();</div><div class="line">        Demo demo = <span class="keyword">new</span> Demo();</div><div class="line">        Tree jcCompiletionUnit_tree = <span class="keyword">new</span> JCCompiletionUnit_tree(<span class="number">0</span>);</div><div class="line">        Tree jcif_tree = <span class="keyword">new</span> JCIf_tree(<span class="number">0</span>);</div><div class="line">        demo.add(jcCompiletionUnit_tree);</div><div class="line">        demo.add(jcif_tree);</div><div class="line">        demo.print(attr_visitor);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>基于编译器原理，讲解Javac的编译以及使用的设计模式，访问者模式，遍历语法树。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Javac是什么&quot;&gt;&lt;a href=&quot;#1-Javac是什么&quot; class=&quot;headerlink&quot; title=&quot;1. Javac是什么&quot;&gt;&lt;/a&gt;1. Javac是什么&lt;/h1&gt;&lt;p&gt;前言：&lt;br&gt;Java语言与Java语言规范，Java虚拟机有Java虚
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/readNote/"/>
    
      <category term="深入分析Java_Web技术" scheme="http://www.liwenguang.cn/categories/readNote/deepJavaWeb/"/>
    
    
  </entry>
  
</feed>
