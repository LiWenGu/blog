<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[八、JVM内存管理]]></title>
    <url>%2F2017%2F08%2F14%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9AJVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 物理内存与虚拟内存所谓物理内存就是RAM（随机存储器）。在计算机中，还有一个存储单元叫寄存器，它用于存储计算单元执行指令（如浮点、整数等运算时）的中间结果。 寄存器的大小决定了一次计算可使用的最大数值。连接处理器和RAM或者处理器和寄存器的是地址总线，这个地址总线的宽度影响了物理地址的索引范围，因为总线的宽度决定了处理器一次可以从寄存器 或者内存中获取多少个bit。同时也决定了处理器最大可以寻址的地址空间，如32位地址总线可以寻址的范围为0x0000 0000~0xffff ffff。这个范围 是2^32=4294967296个内存位置，每个地址会引用一个字节，所以32位总线宽度可以有4GB的内存空间。通常情况下，地址总线和寄存器或者RAM有相同的位数，因为这样更容易传输数据。不管是什么系统，我们要运行程序，都要向操作系统先申请内存地址。通常操作系统管理内存的申请空间是按照进程来管理的，每个进程拥有一段独立的 地址空间，每个进程之间不会相互重合，操作系统也会保证每个进程只能访问自己的内存空间。这主要从程序的安全性来考虑，也便于操作系统来管理物理内存。其实上面所说的进程的内存空间的独立主要是指逻辑上独立，也就是这个独立是由操作系统来保证的，但是真正的物理空间是不是只能由一个进程来使用就 不一定了。因为随着程序越来越庞大和设计的多任务性，物理内存无法满足程序的需求，在这种情况下就有了虚拟内存的出现。虚拟内存的出现使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上共享，在逻辑上它们仍然是不能相互访问的。虚拟地址不但可以让进程 共享物理内存、提高内存利用率，而且还能够扩展内存的地址空间，如一个虚拟地址可能被映射到一段物理内存、文件或者其他可以寻址的存储上。一个进程在不活动的情况下，操作系统将这个物理内存中的数据移到一个磁盘文件中（也就是通常Windows系统上的页面文件，或者Linux系统上的交换分区）， 而真正高效的物理内存留给正在活动的程序使用。在这种情况下，在我们重新唤醒一个很长时间没有使用的程序时，磁盘会吱吱作响，并且会有一个短暂的 停顿得到印证，这时操作系统又会把磁盘上的数据重新交互到物理内存中。但是我们必须要避免这种情况的经常出现，如果操作系统频繁地交互物理内存的 数据和磁盘数据，则效率将会非常低，尤其在Linux服务器上，我们要关注Linux中swap的分区的活跃度。如果swap分区被频繁使用，系统将会非常缓慢， 很可能意味着物理内存已经验证不足或者某些程序没有及时释放内存（物理内存可以理解为内存条大小）。 2. 内核空间与用户空间一个计算机通常有一定大小的内存空间，如使用的计算机是4GB的地址空间，但是程序并不能完全使用这些地址空间，因为这些地址空间被划分为内核空间和 用户空间。程序只能使用用户空间的内存，这里所说的使用是指程序能够申请的内存空间，并不是程序真正访问的地址空间。内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者连接硬件资源等的程序逻辑。为何需要内存空间和用户空间的划分呢？很显然 和前面所说的每个进程都独立使用属于自己的内存一样，为了保证安全，访问硬件资源只能由操作系统来发起。用户需要访问硬件资源，如网络连接等， 需要调用操作系统提供的接口实现，这个调用接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间的切换，通常的网络传输也是一次系统调用， 通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再从内核空间复制到用户空间，供用户程序使用 。这种从内核空间到用户空间的数据复制 很费时，以效率换取的安全稳定。内核空间和用户空间的大小如何分配也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行，这要平衡一下。如果是一台登录服务器，要分配更多的内核空间，因为每个登录用户操作系统都会初始化一个用户进程，这个进程大部分都在内核空间里运行。Window32位操作系统默认内核：用户=1:1，即各有2GB，而在Linux32位则是1:3。 3. 在Java中哪些组件需要使用内存x 1. Java堆2. 线程3. 类和类加载器4. NIO5. JNI]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[虚拟机初始化部署]]></title>
    <url>%2F2017%2F08%2F14%2Fhadoop%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[1. 虚拟机设置静态IP使用VMware12安装CentOS 64位，安装一台之后，并进行设置好静态IP。详细地址：http://blog.csdn.net/readiay/article/details/50866709主要通过查看VMware12的网关、网段，并且设置虚拟机的IP、网关、子网掩码。 设置网卡：/etc/sysconfig/network-scripts/ifcfg-xxx,xxx可能不同。设置主机名：/etc/sysconfig/network。设置DNS：/etc/resolv.conf。这步完成，虚拟机可以上网，使用SecureCRT主机可以登录虚拟机。 2. 虚拟机进行拷贝增加用户hadoop之后。进行拷贝，拷贝出两个虚拟机用作从机，并重新设置网卡以及主机名。并使用ssh localhost命令在虚拟机互相登录。 3. 使用公钥登录使用root账号，在第一个机器输入ssh-keygen，生成ssh公钥私钥，然后使用ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.xxx.x 发送到指定的某个机器，就可以直接使用ssh登录而不用输入密码了，因为有三台，ssh-keygen需要每台输入，而后面的命令需要每台输入两次，用于 连接两台电脑。详细地址：http://www.linuxidc.com/Linux/2016-03/129204.htm]]></content>
      <categories>
        <category>linux</category>
        <category>hadoop</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[七、JVM体系结构与工作方式]]></title>
    <url>%2F2017%2F08%2F12%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9AJVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. JVM体系结构前言：JVM能够跨计算机体系结构来执行Java字节码，主要是由于JVM屏蔽了与各个计算机平台相关的软件或者硬件之间的差异， 使得与平台相关的耦合统一由JVM提供者来实现。 1. 何谓JVMJVM的全称是Java Virtual Machine(Java虚拟机)，它通过模拟一个计算机来达到一个计算机所具体的计算功能。 我们先来看看一个真实的计算机如何才能具备计算的功能。 指令集，这个计算机能够识别的计算语言的命令集合. 计算单位，即能够识别并且控制指令执行的功能模块。 寻址方式，地址的位数、最小地址和最大地址范围，以及地址的运行规则。 寄存器定义，包括操作数寄存器、变址寄存器、控制寄存器等的定义、数量和使用方式。 存储单元，能够存储操作数和保存操作结构的单元，如内核级缓存、内存和磁盘等。 在上面的几个部分中，与代码执行最密切的还是指令集部分。什么是指令集？有何作用？所谓指令集就是在CPU中用来计算和控制计算机系统的一套指令的集合，每一种新型的CPU在设计时都规定了 一系列与其他硬件电路相配合的指令系统。而指令集的先进与否也关系到CPU的性能发挥，它是体现CPU性能的一个重要标志。在当前计算机中有哪些指令集？从主流的体系结构上分为精简指令集(Reduced Instruction Set Computing, RISC)和复杂指令集 (Complex Instrction Set Computing, CISC)。当前使用的桌面操作系统中基本上使用的都是CISC，如x86架构的的CPU都使用CISC。除了这两种指令集之外Intel和AMD公司还在它们 的基础上开发出了很多扩展指令集，包括多媒体扩展指令，以及3D处理性能开发的指令集等。指令集与汇编语言有什么关系？指令集是可以直接被机器识别的机器码，也就是它必须以二进制格式存在于计算机中。而汇编语言是能够 被人识别的指令，汇编语言在顺序和逻辑上是与机器指令一一对应的。换句话说，汇编语言是为了让人能够更容易地记住机器指令而使用 的助记符。每一条汇编指令都可以直接翻译成一个机器指令，如MOVAX,1234H这条汇编语言对应的机器指令码为B83412。当然也不是所有 的汇编语言都有对应的机器指令，如nop指令。指令集与CPU架构有何联系？如Intel与AMD的CPU的指令集是否兼容？也就是CPU的结构是否会影响指令集？答案都是肯定的。学过汇编语言 的人都知道在汇编语言中都是对寄存器和段的直接操作的命令，这些寄存器和段等芯片都是架构的一部分，所以不同的芯片架构设计一定会 对应到不同的机器指令集合。但是现在不同的芯片厂商往往都会采用兼容的方式来兼容其它不同架构的指令集。如AMD会兼容32为Intel的 x86系统架构的CPU，而当AMD开发出了支持64位指令的x86-64架构时，Intel又迫于压力不得不兼容这种架构而起了另外一个名字EM64T。这种压力来自什么地方？当然是垄断了操作系统的微软，由于现在操作系统是管理计算机的真正入口，几乎所有的程序都要通过操作系统来调用， 所以如果操作系统不支持某种芯片的指令集，用户的程序是不可能执行的。这种情况也存在于我们国家自己设计的龙芯CPU，龙芯CPU不得不使用基于 MIPS架构的指令集(RISC)，因为目前有直接支持MIPS架构的操作系统(Linux)。如果没有操作系统和应用软件，再好的CPU也没有使用价值。 当然在一些很少用到的大型机方面不存在这个问题。回到JVM的主题中来，JVM和实体机到底有何不同呢？大体有如下几点。 一个抽象规范，这个规范就约束了JVM到底是什么，它有那些组成部分。 一个具体的实现，所谓具体的实现就是不同的厂商按照这个抽象的规范，用软件或者软件和硬件结合的方式在相同或者不同的平台上的具体实现。 一个运行中的实例，当用其运行一个Java程序时，它就是一个运行中的实例，每个运行中Java程序都是一个JVM实例。 JVM和实体机一样也必须有一套合适的指令集，这个指令集能够被JVM解析执行。这个指令集我们称为JVM字节码指令集， 符合class文件规范的字节码都可以被JVM执行。 2. JVM体系结构详解除了指令集，JVM还需要哪些组成部分： 类加载器，在JVM启动时或者在类运行时将需要的class加载到JVM中。 执行引擎，执行引擎的任务是负责执行class文件中包含的字节码指令，相当于实际机器上的CPU。 内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者PC指针的记录器等。 本地方法调用，调用C或C++实现的本地方法的代码返回结果。 1. 类加载器在深入分析ClassLoader时我们详细分析了ClassLoader的工作机制，这里需要说明的是，每个被JVM装载的类型都有一个对应的java.lang.Class类的实例 来表示该类型，该实例可以唯一标识被JVM装载的class类，要求这个实例和其他类的实例一样都存放在Java的堆中。 2. 执行引擎执行引擎是JVM的核心部分，执行引擎的作用就是解析JVM字节码指令，得到执行结果。在《Java虚拟机规范》中详细地定义了执行引擎遇到每条 字节码指令时应该处理什么，并且应该得到什么结果。但是并没有规定执行引擎应该如何或取什么方式处理而得到这个结果。 因为执行引擎具体采取什么方式由JVM的实现厂家自己去实现，是直接解释执行还是采用JIT技术或转成本地代码去执行，还是采用寄存器这个芯片 模式去执行都可以。所以执行引擎的具体实现有很大的发挥空间，如SUN的hotspt是基于栈的执行引擎，而Google的Dalvik是基于寄存器的执行引擎。执行引擎也就是执行一条条代码的一个流程，而代码都是包含在方法体内的，所以执行引擎本质上就是执行一个个方法所串起来的流程， 对应到操作系统中一个执行流程是一个Java进程还是一个Java线程呢？很显然是后者，因为一个Java进程可以有多个同时执行的执行流程。 这样说来每个Java县城就是一个执行引擎的实例，那么在一个JVM实例中就会同时有多个执行引擎在工作，这些执行引擎有的在执行用户的程序， 有的在执行JVM内存的程序（如Java垃圾收集器）。 3. Java内存管理执行引擎在执行一段程序时需要存储一些东西，如操作码需要的操作数，操作码的执行结果需要保存。class类的字节码还有类的对象等信息都需要在执行 引擎执行之前就准备好。一个JVM实例会有一个方法区、Java堆、Java栈、PC寄存器和本地方法区。其中方法区和Java堆时所有线程共享的， 也就是可以被所有的执行引擎实例访问。每个新的执行引擎实例被创建时会为这个执行引擎创建一个Java栈和一个PC寄存器， 如果当前正在执行一个Java方法，那么在当前的这个Java栈中保存的是该线程中方法调用的状态，包括方法的参数、方法的局部变量、方法的返回值 以及运算的中间结果等。而PC寄存器会指向即将执行的下一条指令。如果是本地方法调用，则存储在本地方法调用栈中或者特定实现中的某个内存区域中。 2. JVM工作机制1. 机器如何执行代码在分析JVM的执行引擎如何工作之前，我们不妨先看看在普通的实体机上程序是如何执行的。前面已经分析了计算机只接受机器执行，其他高级语言首先必须 经过编译器编译成机器指令才能被计算机正确执行，所以从高级语言到机器语言之间必须要有个翻译的过程，我们知道机器语言一般都是和硬件平台密切相关 的，而高级语言一般都是屏蔽所有底层的硬件平台甚至包括软件平台（如操作系统）的。高级语言之所以能屏蔽这些底层硬件架构的差异就是因为有中间的 一个转换环节，这个转换环节就是便宜，与硬件耦合的麻烦就交给了编译器，所以不同的硬件平台通常需要的编译器也是不同的。在当前这种环境下我们所 说的不同的硬件平台已经被更上一层的软件平台所代替了，这个软件平台就是操作系统，与其说不同的硬件平台的差异还不如说操作系统之间的差异，因为 现在的操作系统几乎完全向用户屏蔽了硬件，所以我们说编译器和操作系统的关系非常密切会更加容易让人理解。如C语言在Windows下的编译器为Microsoft C, 而在linux下通常是gcc，当然还有很多不同厂家的编译器，这些编译器都和操作系统关系不大，只是在实现上有些差异。通常一个程序从编写到执行会经历以下一些阶段： 源代码(source code) -&gt; 预处理器(preprocessor) -&gt; 编译器(compiler) -&gt; 汇编程序(assembler) -&gt; 目标代码(object code) -&gt; 链接器 (Linker) -&gt; 可执行程序(executables) 除了源代码和最后的可执行程序，中间的所有环节都是由现代意义上的编译器统一完成的，如在Linux平台下我们通常安装一个软件需要经过 configure、make、make install、make clean这4个步骤来完成。 configure：为这个程序在当前的操作系统环境下选择合适的编译器来编译这个程序代码，也就是为这个程序代码选择合适的编译器和一些环境参数。 make：自然就是对程序代码进行编译操作了，它会将源码编译成可执行的目标文件。 make install：将已经编译好的可执行文件安装到操作系统指定或者默认的安装目录下。 make clean：用于删除编译时临时产生的目录或文件。 值得注意的是，我们通常所说的编译器都是将某种高级语言直接编译成可执行的目标机器语言（实际上在某种操作系统中是需要动态链接的目标二进制文件： 在Windows下是dynamic link library，DDL；在Linux下是Shared Library，SO库）。但是实际上还有一些编译器是将一种高级语言编译成 另一种高级语言，或者将低级语言编译成高级语言（反编译），或者将高级语言编译成虚拟机目标语言，如Java编译器等。再回到如何让机器（不管是实体机还是虚拟机）执行代码的主题，不管是何种指令集都只有集中最基本的元素：加、减、乘、求余、求模等。 这些运算又可以进一步分解成二进制位运算：与、或、异或等。这些运算又通过指令来完成，而指令的核心目标就是确定需要运算的种类（操作码） 和运算需要的数据（操作数），以及从哪里（寄存器或栈）获取操作数、将运算结果存放到什么地方（寄存器或是栈）等。这种不同的操作 方式又将指令划分为：一地址指令、二地址指令、三地址指令和零地址指令等n地址指令。相应的指令集会有对应的架构实现，如基于寄存器 的架构实现或基于栈的架构实现，这里的基于寄存器或者栈都是指在一个指令中的操作数是如何存取的。 2. JVM为何选择基于栈的架构JVM执行字节码指令是基于栈的架构，也就是所有的操作数必须先入栈，然后根据指令中的操作码选择从栈顶弹出若干个元素进行计算后再将结果压入栈中。 在JVM中操作数可以存放在每一个栈帧中国的一个本地变量集中，即在每个方法调用时就会给这个方法分配一个本地变量集，这个本地变量集在编译时就已经 确定，所以操作数入栈可以直接是常量入栈或者从本地变量集中取一个变量压入栈中。这和一般的基于寄存器的操作有所不同，一个操作需要频繁的入栈和出栈， 如进行一个加法运算，如果啷个操作数都在本地变量中，那么一个加法操作就要有5次栈操作，分别是将两个操作数从本地变量入栈（2次入栈操作），再将 两个操作数出栈用于加法运算（2次出栈），再将加法结果压入栈顶（1次入栈）。如果是基于寄存器的话，一般只需要将两个操作数存入寄存器进行加法运算后 再将结果存入其中一个寄存器即可，不需要这么多的数据移动的操作。那么为什么JVM还要基于栈来设计呢？JVM为何要基于栈来设计有几个理由。一个是JVM要设计成与平台无关的。而平台无关性就是要保证在没有或者有很少的寄存器的机器上也要同样能正确的执行 Java代码。例如，在80x86的机器上寄存器就是没有规律的，很难针对某一款机器设计通用的基于寄存器的指令，所以基于寄存器的架构很难做到通用。在 手机操作系统方面，Google的Android平台上的Dalvik VM就是基于特定芯片（ARM）设计的基于寄存器的架构，这样在特定芯片上实现基于寄存器的架构 可能更多考虑性能，但是也牺牲了跨平台的移植性，当然在当前的手机上这个需求还不是最迫切的。还有一个理由是为了指令的紧凑性，因为Java的字节码可能在网络上传输，所以class文件的大小也是设计JVM字节码指令的一个重要因素，如在class文件 中字节码除了处理两个表示跳转的指令外，其他都是字节对齐的，操作码可以只占一个字节大小，这都是为了尽量让编译后的class文件更加紧凑。为了提高 字节码在网络上的传输效率。Sun设计了一个Jar包的压缩工具Pack2000，它可以将多个class文件中的重复的常量池的信息进行合并，如一般在每个calss文件 中都含有“Ljava/lang/String;”，那么多个class文件中的常量就可以共用，从而起到减少数据量的作用。 3. 执行引擎的架构设计每当创建一个新的线程时，JVM会为这个线程创建一个Java栈，同时会为线程分配一个PC寄存器，并且这个PC寄存器会指向这个线程的第一行可执行代码。 每当调用一个新方法时会在这个栈上创建一个新的栈帧数据结构，这个栈帧会保留这个方法的一些元信息，如在这个方法中定义的局部变量、 一些用来支持常量池的解析、正常方法返回及异常处理机制等。JVM在调用某些指令时可能需要使用到常量池中的一些常量，或者是获取常量代表的数据或者这个数据指向的实例化对象，而这些信息都存储在所有线程共享 的方法区和Java堆中。 4. 执行引擎的执行过程1234567public class Math &#123; public static void main(String[] args) &#123; int a = 1; int b = 2; int c = (a+b) * 10; &#125;&#125; 其中main的字节码指令如下：对应到执行引擎的各执行部件如下所示：（注意：原书图的标记有问题，这里仍然使用错误的标记易于理解） 5. JVM方法调用栈JVM的方法调用分两种：一种是Java方法调用，另一种是本地方法调用。本地方法调用由于各个虚拟机的实现不太相同(因为跨平台)，所以这里主要介绍Java的方法调用情况。 12345678910public class Math &#123; public static void main(String[] args) &#123; int a = 1; int b = 2; int c = math(a, b) / 1; &#125; public static int math(int a, int b) &#123; return (a + b) * 10; &#125; &#125; 调用细节就不贴图了，记住一点，任何的数据都要入栈，进入存储到变量区时，都要出栈。PC寄存器存储的是下一条指令的指针。 3. 总结 计算机的体系结构：指令集（机器语言）、计算单元（控制指令）、寻址方式（地址的位数，寻址范围）、寄存器、存储单元（存储操作数和保存操作结构）。 class(通过ClassLoader类加载器后)-&gt;执行引擎(内存、方法区、堆、栈、PC寄存器)-&gt;调用本地方法接口(native) JVM和DVM（Dalvik）的核心区别在于，一个基于栈一个基于寄存器，为什么Sun和Google设计的不一样？后者相对来说，执行效率更高，但是前者真正实现 了跨平台，后者是每个APP都是一个VM，就相当于一个操作系统里面运行了多个DVM，而Sun是，一个操作系统运行一个JVM里面运行多个java程序。（相对 而言，Dalvik是可以预加载（Zygote）的，更叼一点，只不过Dalvik为了增加效率（毕竟运行在手机中），在运行时，不同应用是共享相同的类（打开QQ相机， 你再打开微信相机试试？），而JVM里面的程序，打包之后，运行之后，是真正的独立的程序，即便在包里使用了相同的类，运行都是独立加载的。 这里有更加详细的解答，博主也是抽出的简单精华。）]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[六、深入分析ClassLoader工作机制]]></title>
    <url>%2F2017%2F08%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. ClassLoader的等级加载机制 如何保证不同等级的会员通过不同的会员接待室进入会场？有可能有些会员并不能正确的找到接待自己的接待室，也有可能有些会员冒充更高级的会员身份混进去，所以必须要有机制能够保证所有会员都被正确的接待室接待进入会场，而且一个会员只能被一个接待室接待，不能出现被两个接待室 重复接待的情况。如何设计这个接待规则呢？ ClassLoader就设计了这样一种接待机制，即上级(双亲)委托接待机制。任何一个会员到达任何一个会员接待室时，这个接待室首先会检查这个会员P是否已经被自己A接待过，如果已经接待过，则拒绝本次接待，如果自己没有接待过，那么会向上B询问这个会员是否应该在 上一级的更高级别的接待室B接待，上级接待室B会根据它们的接待规则，检查这个会员是否被自己B接待过，如果接待过，将已经接待的结果反馈下一级A， 如果也没有接待过，则向上一级询问这个会员P是否应该在上一级的更高级别的接待室接待，一直这样接待，直到有一级接待室接待或者告诉它 下一级这个会员不是自己接待的结果； 如果这个会员来到的这个接待室A得到它上一级B的接待室反馈认为这个会员没有被接待，并且也不应该由它们BC接待，这个接待室A将会正式 接待这个会员，并发入会证明，这个会员就被定义为这个接待室等级的会员。 整个JVM平台提供三层ClassLoader，这三层ClassLoader可以分为两种类型，可以理解为：为接待室服务的接待室和为会员服务的接待室两种。 1. BootstrapClassLoader这个ClassLoader就是接待室服务自身的，它主要加载JVM自身工作需要的类，这个ClassLoader完全是由JVM自己控制的，需要加载哪个类、 怎么加载都由JVM自己控制，别人也访问不到这个类，所以这个ClassLoader是不遵守前面介绍的加载规则的，它仅仅是一个类的加载工具而已， 既没有更高一级的父加载器，也没有子加载器。 2. ExtClassLoader这个类加载器有点特殊，它是JVM自身的一部分，但是它的血统不是很纯正，它并不是JVM亲自实现的，我们可以理解为这个类加载器是那些与这个大会合作单位的员工会员， 这些会员既不是JVM内部的，也和普通的外部会员不同，所以就由这个类即在其来加载。它服务的特定目标在System.getProperty(&quot;java.ext.dirs&quot;)目录下。 3. AppClassLoader这个类加载器就是专门为接待会员服务的，它的父类是ExtClassLoader。它服务的目标是广大普通会员，所有在System.getProperty(&quot;java.class.path&quot;) 目录下的类都可以被这个类加载器加载，这个目录就是我们经常用到的classpath。 如果我们要实现自己的类加载器，不管你是直接实现抽象类ClassLoader，还是继承URLClassLoader类，或者其他子类，它的父加载器都是AppClassLoader， 因为不管调用哪个父类构造器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器。而getSystemClassLoader()方法获取 到的正是AppClassLoader。很多文章在介绍ClassLoader的等级结构时把Bootstrap ClassLoader也列在ExtClassLoader的上一级中，其实BootstrapClassLoader并不属于JVM的类等级层次， 因为BootstrapClassLoader并没有遵守ClassLoader的加载规则。另外BootstrapClassLoader并没有子类。ExtClassLoader的父类也不是BootstrapClassLoader，ExtClassLoader并没有父类，我们在应用中能提取到的顶层父类是ExtClassLoader。ExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，它们是Launcher类的内部类。如果在Java应用中没有定义其他ClassLoader，那么除了System.getProperty(&quot;java.ext.dirs&quot;)目录下的类是由ExtClassLoader加载外， 其他类都由AppClassLoader加载。JVM加载class文件到内存由两种方式。 隐式加载：即不在代码里调用ClassLoader来加载所需要的类，而是通过JVM来自动加载所需要的类到内存的方式。例如，当我们在类中继承或者引用某个类时， JVM在解析当前这个类时发现引用的类不在内存中，那么就会自动将这么类加载到内存中。 显式加载：即调用this.getClass().getClassLoader().loadClass()或者Class.forName()，或者我们自己实现的ClassLoader的findClass()方法等。 ClassLoader().loadClass()底层是loadClass(name, false),即只加载不解析。而Class.forName()底层是forName0(className, true, ClassLoader.getClassLoader(caller), caller)， 即初始化。注意：在Java中，类装载分三步，对应三种状态，即：加载-&gt;链接(校验、准备、解析)-&gt;初始化。第一种对应的加载后，第二种对应的时链接后。例如：即要对驱动初始化才能使用就使用的后者加载Class.forName(“com.mysql.jdbc.Driver”)。 2. 如何加载class文件 找到.class文件，并把这个文件包含的字节码加载到内存中。 字节码验证、Class类数据结构分析、内存分配，符号表的链接。 [类中静态属性和初始化赋值][1]，以及静态块的执行等。 1. 加载字节码到内存抽象类ClassLoader中并没有定义如何去加载，让子类具体实现找到指定类并把它的字节码加载到内存需要的子类中， 例如：URLClassLoader如何实现的findClass()方法，这个类底层通过URLClassPath取得要加载的class文件字节流， 而这个URLClassPath定义了到哪里去找这个class文件，如果找到了这个class文件，再读取它的byte字节流，通过 调用defineClass()方法来创建类对象。URL数组是创建URLClassPath对象的必要条件。 2. 验证与解析 字节码验证：确保格式正确、行为正确。 类准备：准备类中定义的字段、方法和实现接口所必须的数据结构 解析：类装入器装入类所引用的其他所有累。如超类(父类)、接口、字段、方法签名、方法中使用的本地变量。 3. 初始化Class对象在类中包含的静态初始化器都被执行，在这一阶段末尾静态字段被初始化为默认值。 3. 常见加载类错误分析1. ClassNotFoundExceptionJVM要加载指定文件的字节码到内存时，并没有找到这个文件对应的字节码文件，即.class文件不存在。解决的办法就是检查 在当前的classpath目录下有没有指定的文件存在。可通过以下命令：this.getClass().getClassLoader().getResource(&quot;&quot;).toString()获取之后结果，让我大吃一惊，这不是我用idea设置的output文件夹么，原来idea设置的output文件夹有这个作用！ 2.NoClassDefFoundError确保每个类引用的类都在当前的classpath下面。 3. UnsatisfiedLinkError常见在JVM启动时，JVM中的某个lib删除了，可能会报这个错误（并这个lib中包含native标示的方法）。 4. ClassCastException 对于普通对象，对象必须是目标类的实例或目标类的子类的实例。如果目标类是接口，那么 会把它当作实现了该接口的一个子类。 对于数组类型，目标类型必须是数组类型或java.lang.Object、java.lang.Cloneable、java.io.Serializable。 123456Integer[] a = new Integer[]&#123;1&#125;;Object b = a;Cloneable c = a;Serializable d = a;System.out.println(b + "," + c + "," + d);//output:[Ljava.lang.Integer;@78e03bb5,[Ljava.lang.Integer;@78e03bb5,[Ljava.lang.Integer;@78e03bb5 建议先使用instanceof检查是不是目标类型，再进行强制类型转换。 5. ExceptionInInitializerError1234567891011public static Map m = new HashMap()&#123; &#123; m.put("a","2"); &#125; &#125;;@Testpublic void sss() &#123; Integer s = (Integer) m.get("a"); System.out.println(s);&#125; 初始化类的时候，给静态属性m赋值出现了异常导致抛出错误。 4. 常用ClassLoader分析基于对Tomcat的源码分析，对部署在Tomcat的Servlet的项目，执行 12345ClassLoader classLoader = this.getClass().getClassLoader();while (classLoader != null) &#123; System.out.println(classLoader.getClass().getCanonicalName()); classLoader = classLoader.getParent();&#125; Tomcat本身自己实现了WebappClassLoader，会优先检查WebappClassLoader加载到额缓存，而不是JVM的findLoaderClass缓存。并设置WebappClassLoadera的加载路径为WEB-INF/classes目录，查找文件的字节码，然后保存类的元信息，方便下次查找。 （前提是被查找的类再BootstrapClassLoader、ExtClassLoader、AppClassLoader等父加载器都反馈为不为他们加载）。 5. 如何实现自己的ClassLoaderClassLoader能够完成的事情： 在自定义路径下查找定义的class类文件，也许我们需要的class文件并不总在已经设置好的ClassPath下面，那么我们 必须想办法来找到这个类，这时，就需要自己实现一个ClassLoader。 对我们自己的要加载的类做特殊处理，如保证通过网络传输的类的安全性，可以将类经过加密后再传输，再加载到JVM 之前需对类的字节码再解码，这个过程就可以在自定义的ClassLoader中实现。 可以定义类的实现机制，我们可以检查已经加载的class文件是否被修改，如果修改了，可以重新加载这个类，从而实现 类的热部署。 1. 加载自定义路径下的class文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PathClassLoader extends ClassLoader &#123; private String classPath; private String packageName = "com.lwg.classknow"; public PathClassLoader(String classPath) &#123; this.classPath = classPath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; if (name.startsWith(packageName)) &#123; // 这里写从自己的缓冲中寻找，找到就直接返回。 byte[] classData = getData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; // 这里写放入自己的缓存中，或者注册到一个Bean管理器，统一管理等。 return defineClass(name, classData, 0, classData.length); &#125; &#125; else &#123; return super.loadClass(name); &#125; &#125; private byte[] getData(String className) &#123; String path = classPath + File.separator + className.replace('.', File.separatorChar) + ".class"; try&#123; // 如果是通过某种加密的文件，则这么可以进行特殊的解密 InputStream is = new FileInputStream(path); ByteArrayOutputStream stream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int num = 0; while ((num = is.read(buffer)) != -1) &#123; stream.write(buffer, 0, num); &#125; return stream.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] agrs) &#123; PathClassLoader loader = new PathClassLoader("C:\\lwg\\lwg\\out\\production\\lwg"); try &#123; Class cus = loader.findClass("com.lwg.classknow.classloader.ssss"); System.out.println(cus); //output:class com.lwg.classknow.classloader.ssss &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 还有直接继承URLClassLoader(下面代码没有经过验证): 1234567891011121314151617181920212223242526public class URLPathClassLoader extends URLClassLoader &#123; private String packageName = "com.lwg.classknow.classloader"; public URLPathClassLoader(URL[] urls, ClassLoader parent) &#123; super(urls, parent); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; clz = findLoadedClass(name); if (clz != null) &#123; return clz; &#125; if (!packageName.startsWith(name)) &#123; return super.loadClass(name); &#125; else &#123; return findClass(name); &#125; &#125; public static void main(String[] args) throws ClassNotFoundException, MalformedURLException &#123; URLPathClassLoader loader = new URLPathClassLoader(new URL[]&#123;new URL("http://www.xxx.com")&#125;, null); loader.findClass("com.lwg.classknow.classloader.ssss"); &#125;&#125; 6. 实现类的热部署JVM在加载类之前会检查请求的类是否已经被加载起来，也就是要调用findLoaderClass()方法查看是否能偶返回类实例。如果类已经加载过来，再调用 loadClass()将会导致类冲突。但是JVM标示一个类是否是同一个类会有两个条件。 类的完整类名是否一样，这个类名包括类所在的包名。 加载这个类的ClassLoader是否是同一个实例。所以要实现类的热部署可以创建不同的ClassLoader的实例对象，然后通过对这个不同的实例对象来加载同名的类。 使用不同的ClassLoader实例加载同一个类，会不会导致JVM的PermGen区无限增大？答案是否定的，因为我们的ClassLoader对象也会和其他对象一样， 当没有对象再引用它以后，也会被JVM回收。但是需要注意的一点是，被这个ClassLoader加载的类的字节码会保存在JVM的PermGen区，这个数据一般 只是在执行Full GC时才会被回收的，所以如果在你的应用中都是大量的动态类加载，Full GC又不是太频繁，也要注意PermGen区的大小，防止内存溢出。 7. Java应不应该动态加载类我想大家都知道用Java有一个痛处，就是修改一个类，必须要重启一遍，很费时。于是就想能不能来个动态类的加载而不需要重启JVM，如果你了解JVM 的工作机制，就应该放弃这个念头。Java的优势正是基于共享对象的机制，达到信息的高度共享，也就是通过保存并持有对象的状态而省去类信息的重复创建和回收。我们知道对象一旦被创建， 这个对象就可以被人持有和引用。假如，我们能够动态加载一个对象进入JVM，但是如何做到JVM中对象的平滑过渡？几乎不可能！虽然在JVM中对象只有一份，在理论上可以直接诶替换这个 对象，然后更新Java栈中所有对原对象的引用关系。看起来好像对象可以被替换了，但是这仍然不可行，因为它违反了JVM的设计原则，对象的引用关系 只有对象的创建者持有和使用，JVM不可以干预对象的引用关系，因为JVM并不知道对象是怎么被使用的，这就涉及JVM并不知道对象的运行时类型 而只知道编译时类型。假如一个对象的属性结构被修改，但是在运行时其他对象可能仍然引用该属性。虽然完全的无障碍的替换时不现实的，但是如果你非要那么做，也还是可以。前面的分析造成不能动态提供类对象的关键是，对象的状态被保存了， 并且被其他对象引用了，一个简单的解决方法就是不保存对象的状态，对象被创建使用后被释放掉，下次修改后，对象也就是新的了。这就是JSP，动态的加载类，所有其他解释型语言都是如此。 8. 总结ClassLoader的基本工作机制，以及双亲委派机制的解释，自己创建ClassLoader以及热部署的原理。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五、深入class文件结构]]></title>
    <url>%2F2017%2F08%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1. JVM指令集简介前言：从底层讲解Java为什么是“一次编译导出运行”，以及一个class文件的内容。在分析class文件之前我们先学会使用Oolong汇编语言，它能将class文件的二进制表示的结构形式先转化成能够理解的汇编语言。下载Oolong.jar 包后将其放在jdk的lib目录下，然后增加一个CLASSPATH精准的指向该Oolong.jar目录。 1234567package com.lwg.classknow;public class Message &#123; public static void main(String[] args) &#123; System.out.printf("junshan say: Hello World"); &#125;&#125; 在当前class文件目录下，命令行输入:java COM.sootNsmoke.oolong.Gnoloo Message.class即可获得Message.j文件，如下： 12345678910111213141516171819202122232425262728293031.source Message.java.class public super com/lwg/classknow/Message.super java/lang/Object.method public &lt;init&gt; ()V.limit stack 1.limit locals 1.var 0 is this Lcom/lwg/classknow/Message; from l0 to l5.line 3l0: aload_0l1: invokespecial java/lang/Object/&lt;init&gt; ()Vl4: return.end method.method public static main ([Ljava/lang/String;)V.limit stack 3.limit locals 1.var 0 is args [Ljava/lang/String; from l0 to l14.line 5l0: getstatic java/lang/System/out Ljava/io/PrintStream;l3: ldc &quot;junshan say: Hello World&quot;l5: iconst_0l6: anewarray java/lang/Objectl9: invokevirtual java/io/PrintStream/printf (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;l12: pop.line 6l13: return.end method 汇编比较复杂，就不深究了，但是要知道，跨平台其实是JVM的跨平台，.java-&gt;.class-&gt;JVM(跨平台)-&gt;机器码(平台)。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四、Javac编译原理]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9AJavac%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. Javac是什么前言：Java语言与Java语言规范，Java虚拟机有Java虚拟机规范，如何让Java的语法规则适应Java虚拟机的语法规范呢？它的任务就是 由Javac编译器完成的，将Java语言规范转化为Java虚拟机语言规范，完成“翻译”工作。 Javac是一种编译器，将一种语言规范转化成另外一种语言规范。虽然机器码执行非常高效，但是对人不友好，开发这个代码 的成本远远高于省下的机器的执行成本，所以才有了编译器的出现，有了编译器才有可能出现这么多的高级编程语言。关于具体的机器，平台，Javac是不管的，这是JVM的事情，Javac的任务就是将Java源代码语言先转化成JVM能够识别的 一种语言，然后由JVM将JVM语言再转化为当前这个机器能够识别的机器语言。表面上Javac的任务就是将Java源码编译成Java字节码，也就是JVM能够识别的二进制码，即.java-&gt;.class的转化 而实际上Java的源码转为一连串二进制数字，这些二进制数字是有格式的，只有JVM能够正确识别它们表达的意思。 2. Javac编译器的基本结构必须要先知道一个编译器完成一个语言规范到另一种语言规范的转化需要哪些步骤，如何完成这些步骤，也就是这个编译器 的基本结构是什么。 词法分析：首先，读取源代码，一个字节为一节地都进来，找出这些字节中哪些是我们定义的语法关键字，如Java中的if、else等关键词： 要识别哪些if是合法的关键词，哪些不是，这个步骤就是词法分析过程。词法分析的结构就是从源代码中找出一些规范化的Token流，就像在人类预言中，一句话中哪些是词语，哪些是标点符号，哪些是 动词，哪些是名词等。 语法分析：接着就是对Token流进行语法分析，即检查是不是符合Java语言规范，如if的后面是不是紧跟着一个布尔判断表达式。就像人类语言是不是有主谓宾。语法分析的结果就是形成一个符合Java语言规范的抽象语法树，对这棵语法树我们可以在后面按照新的规则再重新组织。语法分析之后的结果是符合规范的。 词义分析：的结果就是将复杂的语法转化成最简单的语法，对应到Java中，如将foreach转成for循环结构，还有注 解等，最后形成一个注解过后的抽象语法树，这棵语法树更接近目标语言的语法规则。 代码生成器：就是最后生成符合Java虚拟机规范的字节码了。即：主要四个模块：词法分析器、语法分析器、词义分析器、代码生成器。 3. Javac工作原理分析1. 词法分析器从源文件的第一个字符开始，按照Java语法规范依次找出package、import、类定义以及属性和方法定义等，最后生成一个Token流。其中有两个关键点： Javac是如何分辨这一个个Token的呢？例如，它怎么知道package就是一个Token.PACKAGE,而不是用户自定义的Token. IDENTIFIEDR的名称呢? Javac是如何分辨一个Token的，如compile这个词就是一个Token，为什么不是com或者comp抑或compi等，也就是Javac是如何知道 哪些字符组合在一起就是一个Token的呢？ 答案是：Java有特定的语法规则，即空格分词，第一个是package，一行结束最后必然是}或者;等。而Token类似一个key、value的数据结构，PACKAGE:package。 2. 语法分析器获得了Token流，接着，获取每个token的值，根据Java语法规则，进行顺序的，使用不同的解析方法进行解析，例如发现这个Token是import，则使用import语法分析，检查是否有static关键字 等，判断是否静态引入。接着进行类的解析，包括interface、class、enum等，分别进行语法分析。最后进行classBody的解析，即按照变量定义解析、方法定义解析和内部类定义解析进行的。这个过程比较复杂，将结果保存再list集合中，最后添加到class（假如是class）树中。例如下面的class和语法树的对应关系： 123456789101112public class Yufa &#123; int a; private int c = a + 1; public int getC() &#123; &#125; public void setC(int c) &#123; this.c = c; &#125;&#125; 部分节点在图中省略了。最后这个类节点加入到这个类对应的包路径的顶层节点中： 3. 语义分析器我们需要将树进行细化，例如：添加默认的构造函数，检查变量在使用前是否初始化，将一些常量进行合并处理，检查操作变量类型是否匹配， 检查checked exception异常是否已经捕获或抛出，解除Java的语法糖等等，还有符号，有专门的类进行完成。还有专门进行处理annotation（注解）分析，以及变量的自动转化，包装等。内部类是如何解析的呢？ 1234567891011public class Yuyi &#123; public void main(String[] args) &#123; Inner inner = new Inner(); inner.print(); &#125; class Inner &#123; public void print() &#123; System.out.println("print"); &#125; &#125;&#125; 最后被解析成： 12345678910111213141516171819202122232425public class Yuyi &#123; public Yuyi() &#123; super(); &#125; public void main(String[] args) &#123; Yuyi$Inner inner = new Yuyi$Inner(this); inner.print(); &#125; &#123; &#125;&#125;class Yuyi$Inner &#123; final Yuyi this$0; Yuyi$Inner(final Yuyi this$0) &#123; this.this$0 = this$0; super(); &#125; public void print() &#123; System.out.println("print"); &#125;&#125; 内部类会有外部类对象的引用，并且会独立出来。 4. 代码生成器4. 设计模式解析之访问者模式遍历语法树，都会进行不同的处理工作，同时也对这棵语法树进行进一步处理。实际采用的访问者模式设计，每次遍历都是 一次访问者的执行过程。访问者，得到被访问者的实例，并进行操作。 12345678910111213141516171819202122232425262728293031323334353637public abstract class Visitor &#123; protected String name; public void setName(String name) &#123; this.name = name; &#125; public abstract void visit(JCCompiletionUnit_tree jcCompiletionUnitTree); public abstract void visit(JCIf_tree jcIfTree);&#125;public class Attr_visitor extends Visitor&#123; @Override public void visit(JCCompiletionUnit_tree jcCompiletionUnitTree) &#123; jcCompiletionUnitTree.length = 2; System.out.println("Attr_visitor修改Unit_tree"); &#125; @Override public void visit(JCIf_tree jcIfTree) &#123; System.out.println("Attr_visitor修改JCIf_tree"); &#125;&#125;public class Enter_visitor extends Visitor &#123; @Override public void visit(JCCompiletionUnit_tree jcCompiletionUnitTree) &#123; System.out.println("Enter_visitor修改Unit_tree"); &#125; @Override public void visit(JCIf_tree jcIfTree) &#123; jcIfTree.length = 3; System.out.println("Enter_visitor修改Unit_tree"); &#125;&#125; 被访问者，有个接受访问者的方法，接着将自己放入到这个被访问者中，比较绕： 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class Tree &#123; protected Integer length; public Tree (Integer length) &#123; this.length = length; &#125; public abstract void accept(Visitor visitor); public Integer getLength() &#123; return length; &#125; public void setLength(Integer length) &#123; this.length = length; &#125;&#125;public class JCIf_tree extends Tree &#123; public JCIf_tree(Integer length) &#123; super(length); &#125; @Override public void accept(Visitor visitor) &#123; System.out.println("被访问者的JCIf方法"); visitor.visit(this); &#125;&#125;public class JCCompiletionUnit_tree extends Tree &#123; public JCCompiletionUnit_tree(Integer length) &#123; super(length); &#125; @Override public void accept(Visitor visitor) &#123; System.out.println("被访问者的unit方法"); visitor.visit(this); &#125;&#125; 最后是主函数： 12345678910111213141516171819202122232425public class Demo &#123; List&lt;Tree&gt; trees = new ArrayList&lt;&gt;(); public void add(Tree tree) &#123; trees.add(tree); &#125; public void print(Visitor visitor) &#123; for (Tree tree : trees) &#123; tree.accept(visitor); &#125; &#125; @Test public void testVisitorPattrn()&#123; Visitor attr_visitor = new Attr_visitor(); Demo demo = new Demo(); Tree jcCompiletionUnit_tree = new JCCompiletionUnit_tree(0); Tree jcif_tree = new JCIf_tree(0); demo.add(jcCompiletionUnit_tree); demo.add(jcif_tree); demo.print(attr_visitor); &#125;&#125; 5. 总结基于编译器原理，讲解Javac的编译以及使用的设计模式，访问者模式，遍历语法树。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三、深入分析Java Web中的中文编码问题]]></title>
    <url>%2F2017%2F08%2F07%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 几种常见的编码格式1. 为什么需要编码？ 计算机中存储信息的最小单位是1个字节，即8个bit，所以能表示的字符范围是2^8=256个。 人类符号过于复杂，至少一个几个字节才能满足人类的一个单位。 2. 常见编码编码即就是人类的字符-&gt;机器的字符的过程。 1. ASCII码总共有128个，用1个字节的低七位表示，0~31是控制字符，如换行、回车、删除，32~126是打印字符，可以通过键盘输入并且能够显示出来。 2. ISO-8859-1128个字符显示是不够的，于是ISO组织在ASCII码基础上又制定了一系列标准来扩展ASCII编码，他们是ISO-8859-1至ISO-8859-15。ISO-8859-1仍然 是单字节编码，它总共能表示256个字符。 3. GB2312GB2312全称是《信息技术·中文编码字符集》，总的编码范围是：A1~F7。它是双字节编码。包含了符号以及汉字。 4. GBKGBK全称是《汉字内码扩展规范》，是国家技术监督局为Windows95所制定新的汉字内码规范，它的出现是为了扩展GB2312，并加入更多的汉字。 编码范围是8140~FEFE，总共23940，表示21003个汉字，编码是和GB2312兼容，也就是GB2312编码的汉字可以用GBK解码，不会乱码。 5. GB18030应用不广泛，与GB2312兼容 6. UTF-16Unicode（Universal Code统一码），ISO试图创建一个全新的超语言字典，世界上所有的语言都可以通过这个字典来相互翻译。可想而知这个字典是多么 复杂。Unicode是Java和XML的基础。UTF-16具体定义了Unicode字符在计算机中的存取方法，UTF-16用两个字节来表示Unicode的转化格式，它采用定长的表示方法，即不论什么字符都可以用 两个字节表示。两个字节是16个bit，所以叫UTF-16。UTF-16表示字符非常方便，每两个字节表示一个字符，简化了字符串操作，这也是Java以UTF-16作为内存的字符存储 格式的一个重要的原因。 7. UTF-8UTF-16统一采用两个字节表示一个字符，虽然表示上简单方便，但是也有其缺点，很大一部分字符用一个字节就可以表示的现在要用两个字节表示，存储空间 放大了一倍。而UTF-8采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1~6个字节组成。 如果是一个字节。最高为为0，则表示这是一个ASCII字符，可见，所有ASCII编码已经是UTF-8了。 如果是一个字节，以11开头，则连续的1的个数暗示这个字符的字节数。例如：110xxxxx代表它是双字节UTF-8字符的首字节。 如果是一个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。 2. 编码的场景1. I/O操作Reader类和InputStream之间的InputStreamReader，通过StreamDecoder以及StreamEncoder进行字符和字节的转换，在解码过程必须指定编码格式， 否则按系统编码。 123456789101112131415161718String file = "D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt";String charset = "UTF-8";FileOutputStream fileOutputStream = new FileOutputStream(file);OutputStreamWriter writer = new OutputStreamWriter(fileOutputStream);writer.write("这是要保存的中文字符");writer.close();FileInputStream fileInputStream = new FileInputStream(file);InputStreamReader reader = new InputStreamReader(fileInputStream, charset);char[] buf = new char[1024];int count = 0;StringBuffer buffer = new StringBuffer();while((count = reader.read(buf)) != -1) &#123; buffer.append(buf, 0, count);&#125;System.out.print(buffer.toString());reader.close(); 2. 在内存操作中的编码12345678910111213141516// 第一种，通过字符串操作String s = "中文";byte[] b = s.getBytes("UTF-8");String n = new String(b, "UTF-8");System.out.print(n);// 第二种，通过nio中的Charset与Buffer实现编码解码。Charset charset = Charset.forName("UTF-8");ByteBuffer buffer = charset.encode(s); //字符转字节CharBuffer buffer1 = charset.decode(buffer); //字节转字符char[] a = buffer1.array();System.out.print(a);// 第三种，通过将16bit的char拆分为2个8bit的byte，没有编码解码，只是软转化ByteBuffer byteBuffer = ByteBuffer.allocate(1024);ByteBuffer byteBuffer1 = byteBuffer.putChar('a'); 3. 在Java中如何编解码UTF_32，GBK等编码都是继承自Charset（查看GB18030类的源码，会让你大吃一惊）。Java内存编码采用的UTF-16编码，编码效率高，虽然用双字节存储，但是不适合网络之间传输，因为网络传输容易损坏字节流，当一个字节损坏，就两个字节没用了，UTF-8更适合网络传输。UTF-8对ASCII字符采用单字节存储，另外单个字符损坏也不会影响后面的其他字符，编码效率上介于GBK和 UTF-16之间，所以UTF-8在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。 4. 在Java Web中设计的编解码有I/O的地方就会涉及编码。网络传输都是以字节为单位的，所以所有的数据必须能够被序列化，即继承Serializable。一个文本的实际大小应该怎么计算。例如：把整型数字1234567当做字符哎存储，则采用UTF-8编码会占用7个字节，采用UTF-16编码会占用14个字节，但是当把它当成int类型的数字来存储则只需要4个字节。 1. URL的编码其中浏览器对PathInfo和QueryString是编码不同的，因此服务器分别在不同的地方对其进行解码。例如Tomcat先判断URIEncoding是否有定义，如果没有则默认使用ISO-8859-1解析。而QueryString，无论POST请求还是GET请求，对它们的解码都是在request.getParameters()方法中，当然内部对POST和GET解码是不同的。其中GET请求，是通过HTTP的Header传到服务端的，是通过useBodyEncodingForURL设置。因此在服务器最好设置URIEncoding和useBodyEncoding两个参数。 2. HTTP Header的编解码如Cookie等，一些头信息，Tomcat对Header解码是在调用request.getHeader()方法时进行的。如果有非ASCII字符，使用URLEncoder进行编码，网络传输。 3. POST表单的编解码提交时，浏览器先根据ContentType的Charset编码进行参数编码，然后再提交到服务端，服务端同样也用ContentType中的字符集进行解码。服务端可以通过 request.setCharacterEncoding(charset)来设置。注意：要在第一次调用request.getParameter()方法之前就设置request.setCharacterEncoding(charset)。如果服务端没有设置request.setCharacterEncoding(charset)，那么表单提交的数据将会按照系统的默认编码方式解析。另外，针对multipart/form-data类型的参数，即上传文件，也是通过ContentType定义的字符编码。上传文件是用字节流的方式传输到服务器的本地 临时目录，这个过程并没有涉及字符编码，而真正编码是在讲文件内容添加到parameters，如果用这个不能编码，则会使用默认的ISO-8859-1编码。 4. HTTP BODY的编解码通过Response返回给客户端浏览器。这个过程要经过编码，即response.setCharcterEncoding()来设置，它将会覆盖request.getCharacterEncoding() 的值，并通过Header的Content-Type返回客户端，浏览器接收到返回的Socket流时将通过Content-Type的charset来解码。如果返回的HTTP Header中Content-Type 没有设置charset，那么浏览器将根据浏览器的中的charset来解码， 如果浏览器中没有定义，则使用默认的编码。连接JDBC也是指定一致的编码：jdbc:mysql://localhost:3306?DB?useUnicode=true&amp;characterEncoding=GBK。 5. 在JS的编码1. 外部引入JS文件1&lt;script scr="script.js" charset="gbk"&gt;&lt;/script&gt; 而script.js脚本中，有如下代码： 1document.write("中国"); 如果引入的时候没有设置charset，浏览器就会以当前页面的默认字符集解析这个JS文件。如果一致那就没问题，但是如果页面和js字符编码不一致，就会变成乱码。 2. JS的URL编码1. escape()这组函数已经从ECMAScript v3标准删除了，URL的编码可以用encodeURI和encodeURIComponent来代替。 2. encodeURI()对某些特殊的字符不进行编码如!、a-z、A-Z、0-9、=、@、?、;、:、-、+、(、)、&amp;、#、.、~、*。 3. encodeURIComponent()编码更加彻底，用于整个URL编码，因为它将&amp;也编码了。除了!、a-z、A-Z、0-9、-、、.、~、*。 4. Java与JS编解码问题Java端处理URL编解码有两个类，分别是URLEncoder和URLDecoder。这两个类可以将所有“%”加UTF-8码值用UTF-8解码，从而得到原始的值。对应的前端JS是encodeURIComponent和decodeURLComponent。注意，前端用encodeURIComponent，服务端用URLDecoder解码可能会乱码， 可能是两个字符编码类型不一致，JS编码默认是UTF-8编码，而服务端中文解码一般都是GBK或者GB2312，所以encodeURIComponent编码后是 UTF-8，而Java用GBK去解码显然不对。解决方式是encodeURIComponent两次编码，服务端使用request.getParameter()用GBK解码后，再用UTF-8解码。 6. 常见编码问题1. 中文变成看不懂的字符1234String a = "淘！我喜欢！";byte[] b = a.getBytes("GBK"); //可以表示中文，占两个字节String c = new String(b, "ISO-8859-1"); //将两个字节分别作为一个单独的字符显示System.out.println(c); // output: ÌÔ£¡ÎÒÏ²»¶£¡ 双字节变成单字节 2. 中文变成一个问号 1234String a = "淘！我喜欢！";byte[] b = a.getBytes("ISO-8859-1"); //找不到对应的字符String c = new String(b, "ISO-8859-1");System.out.println(c); // ?????? 3. 中文变成两个问号经过了多次的编码解码。 4. 一种不正常的正确编码直接调用 String value = request.getParameter(name);会出现乱码。但是 String value = new String(request.getParameter(name).getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;)会正常，为什么呢？网络通过GBK编码之后的字节数组进行传输，Tomcat没有配置useBodyEncodingForURI，造成第一次解析通过ISO-8859-1解析， 这时候我们手动通过ISO-8859-1编码，再通过GBK解码就可以获得正确的值，但是额外增加了一次编解码过程。 7. 总结总结了几种常见编码格式的区别： ISO-8859-1：单字节编码，最多能表示256个字符。 GBK、GB2312：双字节编码，前者兼容后者。 UTF-16：双字节编码，Java内部内存额字符存储格式，操作方便，全部都是两个字节，但是浪费空间。 UTF-8：动态字节编码。以及IO的编码实现类：StreamEncoder/StreamDecoder，对char和byte的编解码。 HTTP过程的编码，包括： URL、URI的编码。 Header的编解码。 POST表单的编解码。Java使用request.getParameter()获取之前，先设置request.setCharacterEncoding(charset)。 BODY的编解码，即Response的编解码。 JS的编解码。 Tomcat编解码源码。以及常见乱码问题的原因。注意一定要手动设置编码的格式，实现真正的跨平台。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二、课外学习NIO]]></title>
    <url>%2F2017%2F08%2F04%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%85%B3%E4%BA%8ENIO%2F</url>
    <content type="text"><![CDATA[1.跑个Channel实例12345678910111213141516171819202122232425262728@Test public void testFileChannel() throws Exception &#123; // 源目标，春运的100W人 RandomAccessFile aFile=new RandomAccessFile("data.txt","rw"); // 获得源目标的运载交通工具，例如动车，同时动车的站台也站了100W人。 FileChannel inChannel=aFile.getChannel(); // 分配buffer，这次春运，这辆D8888，每次跑两个字节单位的座位 ByteBuffer buf=ByteBuffer.allocate(2); // 把动车的站台人和座位连接在一起，得到一个返回值，即该动车和两个字节单位座位的车票信息。 int bytesRead=inChannel.read(buf); // 车票如果是-1说明车票没了，载完了，动车就去保养了。 while(bytesRead!=-1) &#123; // 座位的保险带绑上，人不能下座位或者上座位了，只能被车站人员检查 buf.flip(); // 车站人员检查座位是否有对应的人的信息 while(buf.hasRemaining()) &#123; // 打印出以两个字节为单位的座位的人的信息 System.out.print((char)buf.get()); &#125; // 座位保险带放开，人下车，座位就被清空 buf.clear(); // 动车继续拉两个字节座位的人，又得到了座位的车票信息 bytesRead=inChannel.read(buf); &#125; aFile.close();&#125; 其中的Buffer作为一个顶层抽象类，下面有不止八个子类，对应八种数据类型以及其他一些类型。 当Buffer，即座位在调用flip()方法之前，是写模式，即保险带是放开的，想上就上想下就下。切记：Buffer只是在一个改变capacity、position、limit三个值的方法（还有mark，用于临时标记position，通常用于 发送某个指定位置之后，返回到发送指定位置之前的position，因为内部提供了方法用于这个需求）。 1. 写模式 capacity：固定的大小。 position：初始值为0，写一单位数据就移动下一个可插入数据的单位，最大为capacity-1。 limit：额外的变量，用于读写分离。此时limit=capacity，写入的最大值。 2. 读模式 capacity：固定的大小。 position：重置为0，读一单位数据就移动下一个可插入数据的单位。 limit：重置为position，你只能读你写了多少单位的数据。（flip()方法其实，就是将limit重置为position，position重置为0） 2. Buffer读写数据以及常用方法除了通过Channel写入数据，还可以使用Buffer.put()，写入执行某个位置。也可以通过Buffer.get()，读取某个位置的数据。 1. Buffer.clear()limit设置为capacity，position重置为0。 2. Buffer.compact()释放缓存区无用数据。当源目标为Mellow，我们已经读取了Me，现在缓存区还是Mellow，但是Me是无用的，这时候就可以调用该方法。 你可以使用 Buffer.put()以及Buffer.get()方法达到这个效果。底层其实是将position-limit数据复制到开始的位置，并重置position = limit - position。WHY？这个position是什么意思？其实原因在于这个方法用于：我读了Me，position为2，此时我想开始写数据，但是我以后会在某个时间点回来继续读， 则position就变成4，以后不管你写了多少，都正好不会覆盖未读数据。 3. Buffer.rewind()用于position重置为0，即重新开始写，或者读。 4. Buffer.mark()和Buffer.reset()mark默认为-1。 mark()：将当前position赋值给mark变量。reset()：将mark赋值给position变量。 5. Buffer.equals()和Buffer.compareTo()相等的条件：类型相同、剩余的单位数量相同、剩余的单位类型相同。比较的条件：第一个不相同的元素的大小，如果都相同，则看数量的多少。 3. scatter与gather1. scatter12345ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] byteBuffers = &#123;header, body&#125;;FileChannel channel = new RandomAccessFile("data.txt","rw").getChannel();channel.read(byteBuffers); 不适用与动态消息，第一个Buffer被填充完毕之后才会填充第二个。 2. gather12345ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] buffers = &#123;header, body&#125;;FileChannel channel = new RandomAccessFile("data.txt","rw").getChannel();channel.write(buffers); 只会有position-limit的数据会被写入。 4. Channel之间进行数据传输1234567RandomAccessFile sourceFile = new RandomAccessFile("SourceData.txt", "rw");FileChannel sourceChannel = sourceFile.getChannel();RandomAccessFile targetFile = new RandomAccessFile("TargetData.txt", "rw");FileChannel targetChannel = targetFile.getChannel();long position = 0;long count = sourceChannel.size();targetChannel.transferFrom(sourceChannel, position, count); 还有一个Channel.transferTo()方法，和上面的方法相反的作用。注意：目标文件如果本来大于源文件，目标文件只会被覆盖源文件要传输的数据，剩余的数据还会存在。 如果count传入的时候实际大于size，则被当做count，如果小于size，则会按小于的值覆盖。查看源码即可知。 5. Selector1. 为什么使用Selector？Selector是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。 这样一个单独的线程可以管理多个Channel，从而管理多个网络连接。可以使用一个线程处理所有的通道，而对于操作系统来说，线程之间上下文切换的开销很大，Selector则是 可以处理多个Channel。 2. Selector使用1234567// 创建SeletorSelector selector = Selector.open();// channel注册到selector// 继承自AbstractSelectableChannel的方法ServerSocketChannel channel = ServerSocketChannel.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ); 与Selector一起使用时，Channel必须处于费阻塞模式下，而FileChannel只能是阻塞模式，套接字可以切换。监听的第二个参数是不同类型的事件： Connect：SelectionKey.OP_CONNECT Accept：SelectionKey.OP_ACCEPT Read：SelectionKey.OP_READ Write：SelectionKey.OP_WRITE监听多个事件：第二个参数输入：SelectionKey.OP_CONNECT | SelectionKey.OP_CONNECT 3. SelectionKey1. interset属性其中包含了一些你感兴趣的属性，即注册的事件： 12345int interestSet = selectionKey.interestOps();boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;boolean isInterestedInConnect = (interestSet &amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;boolean isInterestedInRead = (interestSet &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;boolean isInterestedInWrite = (interestSet &amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE; 2. ready属性ready集合是通道已经准备九局的操作的集合，你可以通过int readySet = selectionKey.readyOps()进行分别的访问， 也可以使用： 1234selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); 3. Selector获得Channel12Channel channel = selectionKey.channel();Selector selector = selectionKey.selector(); 4. 附加的对象（可选）12selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment(); 5. 通过Selector选择通道 int select() 该方法会让Selector阻塞，直到至少有一个Channel在你注册的事件上就绪。 int select(long timeout) 设置最长阻塞的毫秒数 int selectNow() 直接返回，无论什么Channel。 返回值表示从上次select()方法调用之后，又有多少符合要求的Channel，不叠加。 6. wakeUp()某个线程调用select()让某个Selector阻塞后，使用该方法可以立马返回，如果没有阻塞，但是提前调用了wakeUp方法， 那么下个调用select方法的线程会立即wake up。 7. 遍历SelectorKeys12345678910111213141516Selector selector = Selector.open();Set selectionKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();while (iterator.hasNext()) &#123; SelectionKey key = iterator.next(); if (key.isAcceptable()) &#123; &#125; else if (key.isConnectable()) &#123; &#125; else if (key.isReadable()) &#123; &#125; else if (key.isWritable()) &#123; &#125; iterator.remove();&#125; 需要手动将事件给移除。 4. 完整的示例1234567891011121314int port = 9999; ServerSocketChannel channel = ServerSocketChannel.open();channel.configureBlocking(false); channel.socket().bind(new InetSocketAddress(port)); Selector selector = Selector.open(); SelectionKey selKey = channel.register(selector, SelectionKey.OP_ACCEPT); int interestSet = selKey.interestOps(); boolean is_accept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;System.out.print("isAccept:"+ is_accept); 6. FileChannel文件通道，用于文件的读写，常用，由于FileChannel无法设置非阻塞模式，它总是运行在阻塞模式下。1234567891011 String str = "112中国";RandomAccessFile file = new RandomAccessFile( "D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt", "rw");FileChannel channel = file.getChannel();channel.position(channel.position() + file.length()); //这行代码设置写入文件的最后ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put(str.getBytes());buffer.flip();while (buffer.hasRemaining()) &#123; channel.write(buffer);&#125; 还有用于截取通道的方法：truncate()，以字节为单位。还有一个force()方法，用于强行将数据写入磁盘， 操作系统一般先将数据写入内存，再从内存写入磁盘，设置为True即可。 7. SocketChannel1234567891011121314// 客户端连接，最后使用close关闭。SocketChannel channel = SocketChannel.open();channel.connect(new InetSocketAddress(8989));ByteBuffer buffer = ByteBuffer.allocate(48);channel.read(buffer);// 从buffer中写入数据到channelString data = "what ? ";buffer.clear();buffer.put(data.getBytes());buffer.flip();while (buffer.hasRemaining()) &#123; channel.write(buffer);&#125;channel.close(); 8. ServerSocketChannel12345678910111213// 服务端开启监听：ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.configureBlocking(false);serverSocketChannel.socket().bind(new InetSocketAddress(8777));while (true)&#123; SocketChannel channel = serverSocketChannel.accept(); // 如果设置为非阻塞，则上面的代码会立马返回，需要判空，是否有连接。 if (channel != null)&#123; String ip = serverSocketChannel.socket().getInetAddress().getHostAddress(); System.out.println(ip); // 此时你得到了channel，就可以使用Buffer对数据进行读取操作了。 &#125;&#125; 9. DatagramChannel用于UDP数据的发送和接收 123456// 服务端DatagramChannel channel = DatagramChannel.open();channel.socket().bind(new InetSocketAddress(9999));ByteBuffer buffer = ByteBuffer.allocate(48);channel.configureBlocking(false);channel.receive(buffer); //将得到的UDP数据写入buffer中 12345678// 客户端DatagramChannel channel = DatagramChannel.open();String data = "中国";ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put(data.getBytes());buffer.flip();channel.send(buffer, new InetSocketAddress(9999));channel.close(); 10. Pipe作为两个线程之间的单向数据连接连接（Channel本身是双向，但是通过两个双向的管道一起组合实现成一个单向的，即Sink-&gt;Source）。 12345678910111213// 向管道写数据Pipe pipe = Pipe.open();Pipe.SinkChannel sinkChannel = pipe.sink();ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put("中国人".getBytes());buffer.flip();while (buffer.hasRemaining())&#123; sinkChannel.write(buffer);&#125;// 从管道读数据Pipe.SourceChannel sourceChannel = pipe.source();buffer.clear();sourceChannel.read(buffer); 11. NIO和IO1. 面向流和面向缓冲IO面向流，每次从流中读取一个或多个字节，直至读取所有的字节，没有被缓存再任何地方，另外，也不能移动流中的数据， 如果想移动，需要手动将流中的数据缓存在一个第三方缓冲区变量中。而NIO则本身就将数据放入到缓冲区中，可以在缓冲区 中前后移动，只是加多了对缓冲区的判断以及更多数据进入缓冲区时，不能覆盖原来的数据。 2. 阻塞和非阻塞本质区别，IO在读写直接阻塞。而NIO的读写的操作会直接返回值，进入下一步操作不会阻塞，并通过Selector来实现一个线程 对多个Channel，即多个读写进行管理。 3. 数据的处理 IO的设计逐字节读取数据。例如你正在处理基于行的文本数据流： 1234567891011/**data.txt * Name: xxx * Age: 18 * Email: xxx@gmail.com * Phone: 135xxxxx */BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("data.txt")));String nameLine = reader.readLine();String ageLine = reader.readLine();String emailLine = reader.readLine();String phoneLine = reader.readLine(); NIO直接读写： 12345678ByteBuffer buffer = ByteBuffer.allocate(48);FileChannel channel = new RandomAccessFile("data.txt", "rw").getChannel();int bytesRead = channel.read(buffer);while (bytesRead != -1) &#123; channel.read(buffer);&#125;channel.close(); 4. 总结 NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样， 如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。 如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二、深入分析Java IO的工作机制]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20IO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. JAVA的I/O类库的基本架构 基于字节操作的I/O接口：InputStream和OutputStream。 基于字符操作的I/O操作：Writer和Reader。 基于磁盘操作的I/O操作：File。 基于网络操作的I/O操作：Socket。 2. 字节字符的转换低级的字节转字符，有InputStreamReader，以及OutputStreamWriter。 而字符转字节一般直接用new String(byte[])。 注意：字符字节的转换在开发中一定要显示指明编码。 在OutputStreamWriter的官方注释中，错误的理解为从字符到字节，其实应该理解成字符与字节之间的桥梁。 3. 访问文件的几种方式前言：读取和写入都是调用操作系统的提供的接口，而操作系统调用就会存在内核空间地址和用户空间地址切换的问题，一般的IO都是数据从 磁盘复制到内核空间，然后再从内核空间复制到用户空间，操作系统为了加速IO访问，在内核空间使用了缓存，即如果是第二次访问同一段 的磁盘地址，直接从内核缓存中取出。 1. 标准访问文件的方式读取：调用操作系统的Read接口，操作系统先检查内核的高速缓存，如果有缓存则直接返回，如果没有则从磁盘中读取，缓存，返回。 写入：调用操作系统的Writer接口，写入到高速缓存中，则通知应用程序完成，什么时候写入磁盘由操作系统决定。当然你可以使用sync强制刷新。 2. 直接I/O的方式即应用程序直接访问磁盘数据，减少一次从内核缓冲区到用户空间的数据复制，例如数据库管理系统，数据库明确的知道哪些数据需要缓存 哪些不需要，以及哪些数据需要先放到内存中预热，但是不好的地方在于，你接管了数据缓存，如果你没有命中，则每次都是IO磁盘，比较 耗时，通常结合直接IO与异步IO。 3. 同步访问文件的方式与标准访问文件不同点在于，写入了磁盘，操作系统才会应用程序返回成功的标志，用于安全性高的场景。 4. 异步访问文件的方式访问文件的请求线程发出后，不会阻塞等待，继续做别的事，完成文件访问后回调某个方法，提高应用程序的效率而不是访问文件的效率。 5. 内存映射的方式操作系统将内存中的某一块区域与磁盘中的文件关联，理解为快捷方式。这样中间加了一层地址映射，空间换时间，在实际开发中，多台业务 服务器对一个统一的路径下进行共享，方便数据的存储。例如A服务器下的data和B服务器下的data进行共享，便于文件的统一上传下载路径管理。 4. 访问磁盘文件前面介绍了操作数据，接着这里介绍数据写向何处，例如持久化到物理磁盘。FileInputStream对象是操作一个文件的接口，创建的同时会创建该文件的描述对象FileDescriptor。操作文件对象的时候可以通过getFD() 方法获取真正与底层操作系统相关联的文件描述。例如调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。byte-&gt;char是解码过程，因此读取文件都是需要StreamDecoder类帮助。 1. Java序列化技术将对象转化成一串二进制表示的字符数组，反序列化时需要原始类作为模板，原因在于序列化之后的文件不保存类的完整结构信息。 建议保存为通用的json/xml格式，比较耗的序列化工具：protobuf。序列化以及反序列需要注意一些常见的问题，例如serialVersionUID被修改， 序列化对象中有属性为对象但是该属性对象没有实现Serializable等。 5. 网络I/O工作机制1. TCP状态 三次握手 客户端CLOSED、SYN-SEND、ESTABLISHED。服务端LISTEN、SYN-RCVD、ESTABLISHED。 四次挥手客户端ESTABLISHED、FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT。服务端ESTABLISHED、CLOSE_WAIT、LAST_ACK、CLOSE。 2. 影响网络传输的因素 网络带宽：物理链路在1s内传输的最大比特值，一般都是1.7Mb/s。 传输距离。 TCP拥塞控制：TCP传输是一个“停等停等”的过程，要步调一致则需要通过拥塞控制来调节。TCP在传输时会设定一个“窗口”，窗口大小由带宽和数据 在两端的来回时间，即响应时间决定的。 3. Java Socket的工作机制 客户端开始建立一个Socket实例时，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、 远程地址和端口号的套接字数据结构，这个数据结构一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将进行TCP的三次握手协议， 三次握手，完成之后，Socket实例创建完成。服务端将创建一个ServerSocket实例，只要指定的端口号没有被占用，一般实例都会创建成功，操作系统底层也会为ServerSocket实例创建一个底层 数据结构，这个数据结构中包含指定的端口号和包含监听地址的通配符，通常都是“*”，即监听所有地址。之后调用accept()方法，进入阻塞状态，等待 客户端的请求。当一个新的请求到达时，为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址 和端口，同时这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，此时服务端的与之对应的Socket实例 并没有完成创建，而是要等待与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并从未连接数据结构列表移到已完成列表。所以与ServerSocket 所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。 4. 数据传输服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream，通过这两个对象来交换数据，同时操作系统会为 这两个对象分配一定大小的缓存区。 写入：数据-&gt;OutputStream对应的SendQ队列，队列填满时，数据将会转移到另一端的InputStream的RecvQ队列中，如果RecvQ已经满了，那么 OuptStream的write方法将会阻塞，直到RecvQ队列可以容纳SendQ队列的数据。因此网络IO还需要一个协调的过程，如果两边同时传输数据则会产生死锁。 6. NIO的工作方式(建议先阅读课外学习：关于NIO)1. BIO的缺点阻塞IO，即BIO，在读取和写入时（InputStream、OutputStream）都有可能堵塞，一旦有堵塞，线程将会失去CPU的使用权，一些方法，例如：一个客户端 一个处理线程、线程池用来减少线程创建和回收的成本。但是，当需要大量的HTTP长连接，例如Web旺旺，虽然并不是每个连接都一直在传输数据，但是如果要 对某个客户端（VIP）提供更高的服务优先，很难通过线程本省的优先级完成，同时访问一些竞争资源时，也会有问题，因此需要同步。因此NIO应运而生。 2. NIO的工作机制通过等待读以及等待写的轮询，在真正进行IO的时候才是使用CPU阻塞，但是由于是memory copy，在带宽足够大的1GB/s基本可以忽略。 3. Buffer的工作方式可以简单理解为操作一组基本数据类型的元素列表：capacity、position、limit、mark。注意，通过Channel获取的IO数据首先经过操作系统的Socket缓冲区，再将数据复制到Buffer中，这个操作系统缓冲区就是底层的TCP所关联的RecvQ或者 SendQ队列。Buffer提供了另一种直接操作操作系统缓冲区的方式，即ByteBuffer.allocateDirector()，这个方法直接返回底层存储空间关联的缓冲区，它通过 Native代码操作非JVM堆的内存空间，每次创建或者释放都要手动调用一次System.gc()。注意：使用该方法直接操作非JVM堆空间会引起JVM内存泄漏问题。适用于数据量比较大，生命周期比较长的情况下，而普通的allocate()方法 适用并发连接少于1000。 4. FileChannel的数据访问1. FileChannel.transferXXX传统的数据访问方式：FileChannel.transferXXX方式： 2. FileChannel.map将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，省去了数据从内核空间向用户空间复制的损耗。 适用于对大文件的只读性操作，如大文件的MD5校验。 7. IO调优1. 磁盘I/O优化1. 性能检测在Linux下的iostat命令，查看I/O wait指标是否正常，即CPU等待I/O指标，如果是4核CPU，那么I、O wait参数不应该超过25%。 2. 提升I/O性能 增加缓存，减少磁盘访问次数。 优化磁盘的管理系统 设计合理的磁盘存储数据块。 2. TCP网络参数调优操作系统的端口号：2^16 = 65535个。 通过查看cat /proc/sys/net/ipv4/ip_local_port_range查看端口范围大量并发，端口号的数量就变成瓶颈，还有TIME_WAIT的数量，如果过多，需要将参数设小，提前释放。 3. 网络I/O优化 减少网络交互的次数SQL在客户端和数据库端设置缓存，请求css、js等可以合并为一个http链接，每个文件通过逗号隔开，服务端一次请求全部返回。 减少网络传输数据量的大小通常Web服务器将请求的Web页面gzip压缩后再传输给浏览器。以及通过简单的协议，读取协议头来获取有用的价值信息。尽量 避免读取整个通信数据，例如4层代理和7层代理，都是精良避免要读取整个通信数据。 尽量减少编码尽量以字节形式发送。 1. 同步与异步 同步一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列，同生同死。 同步能保证程序的可靠性。 异步不需要等待被依赖的任务完成只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行。 异步可以提高程序的性能，需要在同步与异步中保持平衡 2. 阻塞和非阻塞阻塞和非阻塞主要从CPU的消耗上来说。 阻塞CPU停下等待一个慢的操作完成之后，CPU才接着完成其他的工作。 非阻塞这个慢操作执行时，CPU去做其他工作，这个慢操作完成时，CPU收到通知继续完成这个慢操作之后的事。 3. 两种方式的组合 同步阻塞常用，简单，但是IO性能差，CPU大部分处于空闲状态。 同步非阻塞常用于网络IO是长连接同时传输数据不多的情况。提升IO性能的常用手段，会增加CPU消耗，要考虑增加的IO性能能不能补偿CPU的消耗，也就是系统的瓶颈是在IO还是CPU上。 异步阻塞常用于分布式数据库中。例如一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2~3份备份记录会写到 其他机器上，这些备份记录通常都采用异步阻塞的方式写IO，异步阻塞对网络IO能够提升效率，尤其像上面这种同时写多份 相同数据的情况。 异步非阻塞比较复杂，只有在非常负载的分布式情况下使用，集群之间的消息同步机制一般使用这种IO组合方式。如Cassandra的Gossip通信机制就采用 异步非阻塞的方式。适用于同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大但非常频繁的情况。 虽然异步和非阻塞能够提高IO整体性能，但是会增加性能成本，以及程序设计复杂的上升，需要经验丰富的人去设计，如果 设计的不合理反而会导致性能下降。怎样理解阻塞非阻塞与同步异步的区别？ 8. 适配器模式博主做一个Integer转化为String的例子，仿造InputStream转化Reader的简单例子。 123456789101112131415public class InputInteger_ implements Integer_ &#123; private Integer a; public InputInteger_(Integer a)&#123; this.a = a; &#125; public Integer getInteger()&#123; return a; &#125;&#125;public interface Integer_ &#123; public Integer getInteger();&#125; 123456789public class String_ implements InputString_ &#123; public void readString() &#123; &#125;&#125;public interface InputString_ &#123; public void readString();&#125; 1234567891011121314public class InputInteger2String implements InputString_ &#123; Integer_ s; public InputInteger2String(Integer_ s) &#123; this.s = s; &#125; public void readString() &#123; // StreamDecoder Integer r = Integer.valueOf(s.getInteger()); System.out.println(r); &#125;&#125; 123456public class Demo &#123; public static void main(String[] args) &#123; InputInteger2String s = new InputInteger2String(new InputInteger_(4)); s.readString(); &#125;&#125; 9. 装饰器模式赋予被装饰的类更多的功能，就像IO中的BufferedInputStream有缓冲的功能，LineNumberInputStream有提高按行读取数据的功能。 1234567891011121314151617181920public abstract class InputStream_ &#123; public abstract void read();&#125;public class FileInputStream_ extends InputStream_ &#123; public void read() &#123; &#125;&#125;public class FilterInputStream_ extends InputStream_ &#123; protected InputStream_ inputStream_; public FilterInputStream_(InputStream_ inputStream_)&#123; this.inputStream_ = inputStream_; &#125; public void read() &#123; inputStream_.read(); &#125;&#125; 1234567891011121314151617181920public class BufferInputStream_ extends FilterInputStream_ &#123; public BufferInputStream_(InputStream_ inputStream_) &#123; super(inputStream_); &#125; private void bufferFirst()&#123; &#125; private void bufferEnd()&#123; &#125; public void read()&#123; bufferFirst(); super.read(); bufferEnd(); &#125;&#125; 123456789public class Demo &#123; public static void main(String[] args)&#123; InputStream_ inputStream_ = new FileInputStream_(); BufferInputStream_ bufferInputStream_ = new BufferInputStream_(inputStream_); bufferInputStream_.read(); &#125;&#125; 10. 适配器模式与装饰器模式区别它们有个别名，叫包装模式，都起到了包装一个类或对象的作用，但是作用不同。适配器通过改变接口来达到重复使用的目的（如果系统在设计初期，就尽量不要用 适配器模式），而装饰器模式保持原有的接口，增强原有对象的功能。 11. 总结Java中IO的基本库结构，磁盘IO和网络IO的工作方式。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一、深入Web请求过程]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5Web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. DNS域名解析使用浏览器输入网址后，浏览器会检查缓存对应的IP地址，如果没有，浏览器会查找操作系统，即host文件。 所以很多墙外比较慢的网址，可以手动编写host文件对应的IP地址以及对应的网址，可以加快访问速度。 如果实在没有就发送给LDNS，这个LDNS在不同的情况是不一样的，在学校，大部分都是学校的DNS服务器， 家庭的一般都是联通或者电信的DNS服务器，最最最后实在解析不出来，就抛给Root Server域名服务器， 它会返回给本地域名服务器的主域名服务器的地址，即域名空间提供商的域名解析服务器，就像阿里域名解析加速。 2. 清除缓存的域名主要在两个地方缓存：Local DNS Server, 另一个是用户的本机，当然，重启也是更好的方法。 ipconfig /flushdns 在java中，JVM也会缓存DNS的解析结果，分两种，即正确的解析结果，以及错误的解析结果，InetAddress，实际中InetAddress使用必须是单例模式，因为每次创建InetAddress实例都要进行一次完整的域名解析。 3. CDN工作机制CDN也就是内容分布网络(Content Delivery Network)。通过在现有的Internet中增加一层新的网络架构，比镜像更智能。 比喻：CDN=镜像Mirror+缓存Cache+整体负载均衡GSLB。 目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态页面等，用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据。 4. 负载均衡负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，提高服务器响应速度，实现地理位置无关性。 通常有三种负载均衡架构：链路负载均衡、集群负载均衡、操作系统负载均衡。 链路：用户最终访问哪个Web Server是由DNS Server来控制的，优点在于用户直接访问目标服务器，不需要经过其它的代理服务器，通常访问速度更快，缺点在于DNS在用户本地和LDNS都有缓存，一旦某台Web Server挂掉，就难及时更新用户的域名解析结构。 集群：硬件负载以及软件负载均衡，前者需要贵的硬件作为中心，而软件则是成本低，但是需要多次代理服务器转发，从而增加了网络延时。 操作系统：如设置多队列网卡。 5. CDN动态加速原理在于CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，通过DNS的调度将所有请求到选定的路径上回源，一个简单的原则就是在每个CDN节点上从源站下载一个一定大小文件，看哪个链路的总耗时最短，这样可以构成一个链路列表，然后绑定到DNS解析上，更新到CDN的Local DNS。以及网络成本等。 6. 总结主要介绍域名的请求，哪些处理，对CDN以及负载均衡有了解。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
</search>