<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[六、深入分析ClassLoader工作机制]]></title>
    <url>%2F2017%2F08%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. ClassLoader的等级加载机制 如何保证不同等级的会员通过不同的会员接待室进入会场？有可能有些会员并不能正确的找到接待自己的接待室，也有可能有些会员冒充更高级的会员身份混进去，所以必须要有机制能够保证所有会员都被正确的接待室接待进入会场，而且一个会员只能被一个接待室接待，不能出现被两个接待室重复接待的情况。如何设计这个接待规则呢？ ClassLoader就设计了这样一种接待机制，即上级(双亲)委托接待机制。任何一个会员到达任何一个会员接待室时，这个接待室首先会检查这个会员P是否已经被自己A接待过，如果已经接待过，则拒绝本次接待，如果自己没有接待过，那么会向上B询问这个会员是否应该在上一级的更高级别的接待室B接待，上级接待室B会根据它们的接待规则，检查这个会员是否被自己B接待过，如果接待过，将已经接待的结果反馈下一级A，如果也没有接待过，则向上一级询问这个会员P是否应该在上一级的更高级别的接待室接待，一直这样接待，直到有一级接待室接待或者告诉它下一级这个会员不是自己接待的结果； 如果这个会员来到的这个接待室A得到它上一级B的接待室反馈认为这个会员没有被接待，并且也不应该由它们BC接待，这个接待室A将会正式接待这个会员，并发入会证明，这个会员就被定义为这个接待室等级的会员。 整个JVM平台提供三层ClassLoader，这三层ClassLoader可以分为两种类型，可以理解为：为接待室服务的接待室和为会员服务的接待室两种。 1. BootstrapClassLoader这个ClassLoader就是接待室服务自身的，它主要加载JVM自身工作需要的类，这个ClassLoader完全是由JVM自己控制的，需要加载哪个类、怎么加载都由JVM自己控制，别人也访问不到这个类，所以这个ClassLoader是不遵守前面介绍的加载规则的，它仅仅是一个类的加载工具而已，既没有更高一级的父加载器，也没有子加载器。 2. ExtClassLoader这个类加载器有点特殊，它是JVM自身的一部分，但是它的血统不是很纯正，它并不是JVM亲自实现的，我们可以理解为这个类加载器是那些与这个大会合作单位的员工会员，这些会员既不是JVM内部的，也和普通的外部会员不同，所以就由这个类即在其来加载。它服务的特定目标在System.getProperty(&quot;java.ext.dirs&quot;)目录下。 3. AppClassLoader这个类加载器就是专门为接待会员服务的，它的父类是ExtClassLoader。它服务的目标是广大普通会员，所有在System.getProperty(&quot;java.class.path&quot;)目录下的类都可以被这个类加载器加载，这个目录就是我们经常用到的classpath。 如果我们要实现自己的类加载器，不管你是直接实现抽象类ClassLoader，还是继承URLClassLoader类，或者其他子类，它的父加载器都是AppClassLoader，因为不管调用哪个父类构造器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器。而getSystemClassLoader()方法获取到的正是AppClassLoader。很多文章在介绍ClassLoader的等级结构时把Bootstrap ClassLoader也列在ExtClassLoader的上一级中，其实BootstrapClassLoader并不属于JVM的类等级层次，因为BootstrapClassLoader并没有遵守ClassLoader的加载规则。另外BootstrapClassLoader并没有子类。ExtClassLoader的父类也不是BootstrapClassLoader，ExtClassLoader并没有父类，我们在应用中能提取到的顶层父类是ExtClassLoader。ExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，它们是Launcher类的内部类。如果在Java应用中没有定义其他ClassLoader，那么除了System.getProperty(&quot;java.ext.dirs&quot;)目录下的类是由ExtClassLoader加载外，其他类都由AppClassLoader加载。JVM加载class文件到内存由两种方式。 隐式加载：即不在代码里调用ClassLoader来加载所需要的类，而是通过JVM来自动加载所需要的类到内存的方式。例如，当我们在类中继承或者引用某个类时，JVM在解析当前这个类时发现引用的类不在内存中，那么就会自动将这么类加载到内存中。 显式加载：即调用this.getClass().getClassLoader().loadClass()或者Class.forName()，或者我们自己实现的ClassLoader的findClass()方法等。 ClassLoader().loadClass()底层是loadClass(name, false),即只加载不解析。而Class.forName()底层是forName0(className, true, ClassLoader.getClassLoader(caller), caller)，即初始化。注意：在Java中，类装载分三步，对应三种状态，即：加载-&gt;链接(校验、准备、解析)-&gt;初始化。第一种对应的加载后，第二种对应的时链接后。例如：即要对驱动初始化才能使用就使用的后者加载Class.forName(“com.mysql.jdbc.Driver”)。 2. 如何加载class文件 找到.class文件，并把这个文件包含的字节码加载到内存中。 字节码验证、Class类数据结构分析、内存分配，符号表的链接。 [类中静态属性和初始化赋值][1]，以及静态块的执行等。 1. 加载字节码到内存抽象类ClassLoader中并没有定义如何去加载，让子类具体实现找到指定类并把它的字节码加载到内存需要的子类中，例如：URLClassLoader如何实现的findClass()方法，这个类底层通过URLClassPath取得要加载的class文件字节流，而这个URLClassPath定义了到哪里去找这个class文件，如果找到了这个class文件，再读取它的byte字节流，通过调用defineClass()方法来创建类对象。URL数组是创建URLClassPath对象的必要条件。 2. 验证与解析 字节码验证：确保格式正确、行为正确。 类准备：准备类中定义的字段、方法和实现接口所必须的数据结构 解析：类装入器装入类所引用的其他所有累。如超类(父类)、接口、字段、方法签名、方法中使用的本地变量。 3. 初始化Class对象在类中包含的静态初始化器都被执行，在这一阶段末尾静态字段被初始化为默认值。 3. 常见加载类错误分析1. ClassNotFoundExceptionJVM要加载指定文件的字节码到内存时，并没有找到这个文件对应的字节码文件，即.class文件不存在。解决的办法就是检查在当前的classpath目录下有没有指定的文件存在。可通过以下命令：this.getClass().getClassLoader().getResource(&quot;&quot;).toString()获取之后结果，让我大吃一惊，这不是我用idea设置的output文件夹么，原来idea设置的output文件夹有这个作用！ 2.NoClassDefFoundError确保每个类引用的类都在当前的classpath下面。 3. UnsatisfiedLinkError常见在JVM启动时，JVM中的某个lib删除了，可能会报这个错误（并这个lib中包含native标示的方法）。 4. ClassCastException 对于普通对象，对象必须是目标类的实例或目标类的子类的实例。如果目标类是接口，那么 会把它当作实现了该接口的一个子类。 对于数组类型，目标类型必须是数组类型或java.lang.Object、java.lang.Cloneable、java.io.Serializable。 123456Integer[] a = new Integer[]&#123;1&#125;;Object b = a;Cloneable c = a;Serializable d = a;System.out.println(b + "," + c + "," + d);//output:[Ljava.lang.Integer;@78e03bb5,[Ljava.lang.Integer;@78e03bb5,[Ljava.lang.Integer;@78e03bb5 建议先使用instanceof检查是不是目标类型，再进行强制类型转换。 5. ExceptionInInitializerError1234567891011public static Map m = new HashMap()&#123; &#123; m.put("a","2"); &#125; &#125;;@Testpublic void sss() &#123; Integer s = (Integer) m.get("a"); System.out.println(s);&#125; 初始化类的时候，给静态属性m赋值出现了异常导致抛出错误。 4. 常用ClassLoader分析基于对Tomcat的源码分析，对部署在Tomcat的Servlet的项目，执行12345ClassLoader classLoader = this.getClass().getClassLoader();while (classLoader != null) &#123; System.out.println(classLoader.getClass().getCanonicalName()); classLoader = classLoader.getParent();&#125; Tomcat本身自己实现了WebappClassLoader，会优先检查WebappClassLoader加载到额缓存，而不是JVM的findLoaderClass缓存。并设置WebappClassLoadera的加载路径为WEB-INF/classes目录，查找文件的字节码，然后保存类的元信息，方便下次查找。（前提是被查找的类再BootstrapClassLoader、ExtClassLoader、AppClassLoader等父加载器都反馈为不为他们加载）。 5. 如何实现自己的ClassLoaderClassLoader能够完成的事情： 在自定义路径下查找定义的class类文件，也许我们需要的class文件并不总在已经设置好的ClassPath下面，那么我们必须想办法来找到这个类，这时，就需要自己实现一个ClassLoader。 对我们自己的要加载的类做特殊处理，如保证通过网络传输的类的安全性，可以将类经过加密后再传输，再加载到JVM之前需对类的字节码再解码，这个过程就可以在自定义的ClassLoader中实现。 可以定义类的实现机制，我们可以检查已经加载的class文件是否被修改，如果修改了，可以重新加载这个类，从而实现类的热部署。 1. 加载自定义路径下的class文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PathClassLoader extends ClassLoader &#123; private String classPath; private String packageName = "com.lwg.classknow"; public PathClassLoader(String classPath) &#123; this.classPath = classPath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; if (name.startsWith(packageName)) &#123; // 这里写从自己的缓冲中寻找，找到就直接返回。 byte[] classData = getData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; // 这里写放入自己的缓存中，或者注册到一个Bean管理器，统一管理等。 return defineClass(name, classData, 0, classData.length); &#125; &#125; else &#123; return super.loadClass(name); &#125; &#125; private byte[] getData(String className) &#123; String path = classPath + File.separator + className.replace('.', File.separatorChar) + ".class"; try&#123; // 如果是通过某种加密的文件，则这么可以进行特殊的解密 InputStream is = new FileInputStream(path); ByteArrayOutputStream stream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int num = 0; while ((num = is.read(buffer)) != -1) &#123; stream.write(buffer, 0, num); &#125; return stream.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] agrs) &#123; PathClassLoader loader = new PathClassLoader("C:\\lwg\\lwg\\out\\production\\lwg"); try &#123; Class cus = loader.findClass("com.lwg.classknow.classloader.ssss"); System.out.println(cus); //output:class com.lwg.classknow.classloader.ssss &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 还有直接继承URLClassLoader(下面代码没有经过验证):1234567891011121314151617181920212223242526public class URLPathClassLoader extends URLClassLoader &#123; private String packageName = "com.lwg.classknow.classloader"; public URLPathClassLoader(URL[] urls, ClassLoader parent) &#123; super(urls, parent); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; clz = findLoadedClass(name); if (clz != null) &#123; return clz; &#125; if (!packageName.startsWith(name)) &#123; return super.loadClass(name); &#125; else &#123; return findClass(name); &#125; &#125; public static void main(String[] args) throws ClassNotFoundException, MalformedURLException &#123; URLPathClassLoader loader = new URLPathClassLoader(new URL[]&#123;new URL("http://www.xxx.com")&#125;, null); loader.findClass("com.lwg.classknow.classloader.ssss"); &#125;&#125; 6. 实现类的热部署JVM在加载类之前会检查请求的类是否已经被加载起来，也就是要调用findLoaderClass()方法查看是否能偶返回类实例。如果类已经加载过来，再调用loadClass()将会导致类冲突。但是JVM标示一个类是否是同一个类会有两个条件。 类的完整类名是否一样，这个类名包括类所在的包名。 加载这个类的ClassLoader是否是同一个实例。所以要实现类的热部署可以创建不同的ClassLoader的实例对象，然后通过对这个不同的实例对象来加载同名的类。 使用不同的ClassLoader实例加载同一个类，会不会导致JVM的PermGen区无限增大？答案是否定的，因为我们的ClassLoader对象也会和其他对象一样，当没有对象再引用它以后，也会被JVM回收。但是需要注意的一点是，被这个ClassLoader加载的类的字节码会保存在JVM的PermGen区，这个数据一般只是在执行Full GC时才会被回收的，所以如果在你的应用中都是大量的动态类加载，Full GC又不是太频繁，也要注意PermGen区的大小，防止内存溢出。 7. Java应不应该动态加载类我想大家都知道用Java有一个痛处，就是修改一个类，必须要重启一遍，很费时。于是就想能不能来个动态类的加载而不需要重启JVM，如果你了解JVM的工作机制，就应该放弃这个念头。Java的优势正是基于共享对象的机制，达到信息的高度共享，也就是通过保存并持有对象的状态而省去类信息的重复创建和回收。我们知道对象一旦被创建，这个对象就可以被人持有和引用。假如，我们能够动态加载一个对象进入JVM，但是如何做到JVM中对象的平滑过渡？几乎不可能！虽然在JVM中对象只有一份，在理论上可以直接诶替换这个对象，然后更新Java栈中所有对原对象的引用关系。看起来好像对象可以被替换了，但是这仍然不可行，因为它违反了JVM的设计原则，对象的引用关系只有对象的创建者持有和使用，JVM不可以干预对象的引用关系，因为JVM并不知道对象是怎么被使用的，这就涉及JVM并不知道对象的运行时类型而只知道编译时类型。假如一个对象的属性结构被修改，但是在运行时其他对象可能仍然引用该属性。虽然完全的无障碍的替换时不现实的，但是如果你非要那么做，也还是可以。前面的分析造成不能动态提供类对象的关键是，对象的状态被保存了，并且被其他对象引用了，一个简单的解决方法就是不保存对象的状态，对象被创建使用后被释放掉，下次修改后，对象也就是新的了。这就是JSP，动态的加载类，所有其他解释型语言都是如此。 8. 总结ClassLoader的基本工作机制，以及双亲委派机制的解释，自己创建ClassLoader以及热部署的原理。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五、深入class文件结构]]></title>
    <url>%2F2017%2F08%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1. JVM指令集简介前言：从底层讲解Java为什么是“一次编译导出运行”，以及一个class文件的内容。在分析class文件之前我们先学会使用Oolong汇编语言，它能将class文件的二进制表示的结构形式先转化成能够理解的汇编语言。下载Oolong.jar包后将其放在jdk的lib目录下，然后增加一个CLASSPATH精准的指向该Oolong.jar目录。1234567package com.lwg.classknow;public class Message &#123; public static void main(String[] args) &#123; System.out.printf("junshan say: Hello World"); &#125;&#125; 在当前class文件目录下，命令行输入:java COM.sootNsmoke.oolong.Gnoloo Message.class即可获得Message.j文件，如下：12345678910111213141516171819202122232425262728293031.source Message.java.class public super com/lwg/classknow/Message.super java/lang/Object.method public &lt;init&gt; ()V.limit stack 1.limit locals 1.var 0 is this Lcom/lwg/classknow/Message; from l0 to l5.line 3l0: aload_0l1: invokespecial java/lang/Object/&lt;init&gt; ()Vl4: return.end method.method public static main ([Ljava/lang/String;)V.limit stack 3.limit locals 1.var 0 is args [Ljava/lang/String; from l0 to l14.line 5l0: getstatic java/lang/System/out Ljava/io/PrintStream;l3: ldc &quot;junshan say: Hello World&quot;l5: iconst_0l6: anewarray java/lang/Objectl9: invokevirtual java/io/PrintStream/printf (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;l12: pop.line 6l13: return.end method 汇编比较复杂，就不深究了，但是要知道，跨平台其实是JVM的跨平台，.java-&gt;.class-&gt;JVM(跨平台)-&gt;机器码(平台)。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四、Javac编译原理]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9AJavac%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. Javac是什么前言：Java语言与Java语言规范，Java虚拟机有Java虚拟机规范，如何让Java的语法规则适应Java虚拟机的语法规范呢？它的任务就是由Javac编译器完成的，将Java语言规范转化为Java虚拟机语言规范，完成“翻译”工作。Javac是一种编译器，将一种语言规范转化成另外一种语言规范。虽然机器码执行非常高效，但是对人不友好，开发这个代码的成本远远高于省下的机器的执行成本，所以才有了编译器的出现，有了编译器才有可能出现这么多的高级编程语言。关于具体的机器，平台，Javac是不管的，这是JVM的事情，Javac的任务就是将Java源代码语言先转化成JVM能够识别的一种语言，然后由JVM将JVM语言再转化为当前这个机器能够识别的机器语言。表面上Javac的任务就是将Java源码编译成Java字节码，也就是JVM能够识别的二进制码，即.java-&gt;.class的转化而实际上Java的源码转为一连串二进制数字，这些二进制数字是有格式的，只有JVM能够正确识别它们表达的意思。 2. Javac编译器的基本结构必须要先知道一个编译器完成一个语言规范到另一种语言规范的转化需要哪些步骤，如何完成这些步骤，也就是这个编译器的基本结构是什么。 词法分析：首先，读取源代码，一个字节为一节地都进来，找出这些字节中哪些是我们定义的语法关键字，如Java中的if、else等关键词：要识别哪些if是合法的关键词，哪些不是，这个步骤就是词法分析过程。词法分析的结构就是从源代码中找出一些规范化的Token流，就像在人类预言中，一句话中哪些是词语，哪些是标点符号，哪些是动词，哪些是名词等。 语法分析：接着就是对Token流进行语法分析，即检查是不是符合Java语言规范，如if的后面是不是紧跟着一个布尔判断表达式。就像人类语言是不是有主谓宾。语法分析的结果就是形成一个符合Java语言规范的抽象语法树，对这棵语法树我们可以在后面按照新的规则再重新组织。语法分析之后的结果是符合规范的。 词义分析：的结果就是将复杂的语法转化成最简单的语法，对应到Java中，如将foreach转成for循环结构，还有注解等，最后形成一个注解过后的抽象语法树，这棵语法树更接近目标语言的语法规则。 代码生成器：就是最后生成符合Java虚拟机规范的字节码了。即：主要四个模块：词法分析器、语法分析器、词义分析器、代码生成器。 3. Javac工作原理分析1. 词法分析器从源文件的第一个字符开始，按照Java语法规范依次找出package、import、类定义以及属性和方法定义等，最后生成一个Token流。其中有两个关键点： Javac是如何分辨这一个个Token的呢？例如，它怎么知道package就是一个Token.PACKAGE,而不是用户自定义的Token.IDENTIFIEDR的名称呢? Javac是如何分辨一个Token的，如compile这个词就是一个Token，为什么不是com或者comp抑或compi等，也就是Javac是如何知道哪些字符组合在一起就是一个Token的呢？ 答案是：Java有特定的语法规则，即空格分词，第一个是package，一行结束最后必然是}或者;等。而Token类似一个key、value的数据结构，PACKAGE:package。 2. 语法分析器获得了Token流，接着，获取每个token的值，根据Java语法规则，进行顺序的，使用不同的解析方法进行解析，例如发现这个Token是import，则使用import语法分析，检查是否有static关键字等，判断是否静态引入。接着进行类的解析，包括interface、class、enum等，分别进行语法分析。最后进行classBody的解析，即按照变量定义解析、方法定义解析和内部类定义解析进行的。这个过程比较复杂，将结果保存再list集合中，最后添加到class（假如是class）树中。例如下面的class和语法树的对应关系：123456789101112public class Yufa &#123; int a; private int c = a + 1; public int getC() &#123; &#125; public void setC(int c) &#123; this.c = c; &#125;&#125; 部分节点在图中省略了。最后这个类节点加入到这个类对应的包路径的顶层节点中： 3. 语义分析器我们需要将树进行细化，例如：添加默认的构造函数，检查变量在使用前是否初始化，将一些常量进行合并处理，检查操作变量类型是否匹配，检查checked exception异常是否已经捕获或抛出，解除Java的语法糖等等，还有符号，有专门的类进行完成。还有专门进行处理annotation（注解）分析，以及变量的自动转化，包装等。内部类是如何解析的呢？1234567891011public class Yuyi &#123; public void main(String[] args) &#123; Inner inner = new Inner(); inner.print(); &#125; class Inner &#123; public void print() &#123; System.out.println("print"); &#125; &#125;&#125; 最后被解析成：12345678910111213141516171819202122232425public class Yuyi &#123; public Yuyi() &#123; super(); &#125; public void main(String[] args) &#123; Yuyi$Inner inner = new Yuyi$Inner(this); inner.print(); &#125; &#123; &#125;&#125;class Yuyi$Inner &#123; final Yuyi this$0; Yuyi$Inner(final Yuyi this$0) &#123; this.this$0 = this$0; super(); &#125; public void print() &#123; System.out.println("print"); &#125;&#125; 内部类会有外部类对象的引用，并且会独立出来。 4. 代码生成器4. 设计模式解析之访问者模式遍历语法树，都会进行不同的处理工作，同时也对这棵语法树进行进一步处理。实际采用的访问者模式设计，每次遍历都是一次访问者的执行过程。访问者，得到被访问者的实例，并进行操作。12345678910111213141516171819202122232425262728293031323334353637public abstract class Visitor &#123; protected String name; public void setName(String name) &#123; this.name = name; &#125; public abstract void visit(JCCompiletionUnit_tree jcCompiletionUnitTree); public abstract void visit(JCIf_tree jcIfTree);&#125;public class Attr_visitor extends Visitor&#123; @Override public void visit(JCCompiletionUnit_tree jcCompiletionUnitTree) &#123; jcCompiletionUnitTree.length = 2; System.out.println("Attr_visitor修改Unit_tree"); &#125; @Override public void visit(JCIf_tree jcIfTree) &#123; System.out.println("Attr_visitor修改JCIf_tree"); &#125;&#125;public class Enter_visitor extends Visitor &#123; @Override public void visit(JCCompiletionUnit_tree jcCompiletionUnitTree) &#123; System.out.println("Enter_visitor修改Unit_tree"); &#125; @Override public void visit(JCIf_tree jcIfTree) &#123; jcIfTree.length = 3; System.out.println("Enter_visitor修改Unit_tree"); &#125;&#125; 被访问者，有个接受访问者的方法，接着将自己放入到这个被访问者中，比较绕：123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class Tree &#123; protected Integer length; public Tree (Integer length) &#123; this.length = length; &#125; public abstract void accept(Visitor visitor); public Integer getLength() &#123; return length; &#125; public void setLength(Integer length) &#123; this.length = length; &#125;&#125;public class JCIf_tree extends Tree &#123; public JCIf_tree(Integer length) &#123; super(length); &#125; @Override public void accept(Visitor visitor) &#123; System.out.println("被访问者的JCIf方法"); visitor.visit(this); &#125;&#125;public class JCCompiletionUnit_tree extends Tree &#123; public JCCompiletionUnit_tree(Integer length) &#123; super(length); &#125; @Override public void accept(Visitor visitor) &#123; System.out.println("被访问者的unit方法"); visitor.visit(this); &#125;&#125; 最后是主函数：12345678910111213141516171819202122232425public class Demo &#123; List&lt;Tree&gt; trees = new ArrayList&lt;&gt;(); public void add(Tree tree) &#123; trees.add(tree); &#125; public void print(Visitor visitor) &#123; for (Tree tree : trees) &#123; tree.accept(visitor); &#125; &#125; @Test public void testVisitorPattrn()&#123; Visitor attr_visitor = new Attr_visitor(); Demo demo = new Demo(); Tree jcCompiletionUnit_tree = new JCCompiletionUnit_tree(0); Tree jcif_tree = new JCIf_tree(0); demo.add(jcCompiletionUnit_tree); demo.add(jcif_tree); demo.print(attr_visitor); &#125;&#125; 5. 总结基于编译器原理，讲解Javac的编译以及使用的设计模式，访问者模式，遍历语法树。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三、深入分析Java Web中的中文编码问题]]></title>
    <url>%2F2017%2F08%2F07%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20Web%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 几种常见的编码格式1. 为什么需要编码？ 计算机中存储信息的最小单位是1个字节，即8个bit，所以能表示的字符范围是2^8=256个。 人类符号过于复杂，至少一个几个字节才能满足人类的一个单位。 2. 常见编码编码即就是人类的字符-&gt;机器的字符的过程。 1. ASCII码总共有128个，用1个字节的低七位表示，0~31是控制字符，如换行、回车、删除，32~126是打印字符，可以通过键盘输入并且能够显示出来。 2. ISO-8859-1128个字符显示是不够的，于是ISO组织在ASCII码基础上又制定了一系列标准来扩展ASCII编码，他们是ISO-8859-1至ISO-8859-15。ISO-8859-1仍然是单字节编码，它总共能表示256个字符。 3. GB2312GB2312全称是《信息技术·中文编码字符集》，总的编码范围是：A1~F7。它是双字节编码。包含了符号以及汉字。 4. GBKGBK全称是《汉字内码扩展规范》，是国家技术监督局为Windows95所制定新的汉字内码规范，它的出现是为了扩展GB2312，并加入更多的汉字。编码范围是8140~FEFE，总共23940，表示21003个汉字，编码是和GB2312兼容，也就是GB2312编码的汉字可以用GBK解码，不会乱码。 5. GB18030应用不广泛，与GB2312兼容 6. UTF-16Unicode（Universal Code统一码），ISO试图创建一个全新的超语言字典，世界上所有的语言都可以通过这个字典来相互翻译。可想而知这个字典是多么复杂。Unicode是Java和XML的基础。UTF-16具体定义了Unicode字符在计算机中的存取方法，UTF-16用两个字节来表示Unicode的转化格式，它采用定长的表示方法，即不论什么字符都可以用两个字节表示。两个字节是16个bit，所以叫UTF-16。UTF-16表示字符非常方便，每两个字节表示一个字符，简化了字符串操作，这也是Java以UTF-16作为内存的字符存储格式的一个重要的原因。 7. UTF-8UTF-16统一采用两个字节表示一个字符，虽然表示上简单方便，但是也有其缺点，很大一部分字符用一个字节就可以表示的现在要用两个字节表示，存储空间放大了一倍。而UTF-8采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1~6个字节组成。 如果是一个字节。最高为为0，则表示这是一个ASCII字符，可见，所有ASCII编码已经是UTF-8了。 如果是一个字节，以11开头，则连续的1的个数暗示这个字符的字节数。例如：110xxxxx代表它是双字节UTF-8字符的首字节。 如果是一个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。 2. 编码的场景1. I/O操作Reader类和InputStream之间的InputStreamReader，通过StreamDecoder以及StreamEncoder进行字符和字节的转换，在解码过程必须指定编码格式，否则按系统编码。123456789101112131415161718String file = "D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt";String charset = "UTF-8";FileOutputStream fileOutputStream = new FileOutputStream(file);OutputStreamWriter writer = new OutputStreamWriter(fileOutputStream);writer.write("这是要保存的中文字符");writer.close();FileInputStream fileInputStream = new FileInputStream(file);InputStreamReader reader = new InputStreamReader(fileInputStream, charset);char[] buf = new char[1024];int count = 0;StringBuffer buffer = new StringBuffer();while((count = reader.read(buf)) != -1) &#123; buffer.append(buf, 0, count);&#125;System.out.print(buffer.toString());reader.close(); 2. 在内存操作中的编码12345678910111213141516// 第一种，通过字符串操作String s = "中文";byte[] b = s.getBytes("UTF-8");String n = new String(b, "UTF-8");System.out.print(n);// 第二种，通过nio中的Charset与Buffer实现编码解码。Charset charset = Charset.forName("UTF-8");ByteBuffer buffer = charset.encode(s); //字符转字节CharBuffer buffer1 = charset.decode(buffer); //字节转字符char[] a = buffer1.array();System.out.print(a);// 第三种，通过将16bit的char拆分为2个8bit的byte，没有编码解码，只是软转化ByteBuffer byteBuffer = ByteBuffer.allocate(1024);ByteBuffer byteBuffer1 = byteBuffer.putChar('a'); 3. 在Java中如何编解码UTF_32，GBK等编码都是继承自Charset（查看GB18030类的源码，会让你大吃一惊）。Java内存编码采用的UTF-16编码，编码效率高，虽然用双字节存储，但是不适合网络之间传输，因为网络传输容易损坏字节流，当一个字节损坏，就两个字节没用了，UTF-8更适合网络传输。UTF-8对ASCII字符采用单字节存储，另外单个字符损坏也不会影响后面的其他字符，编码效率上介于GBK和UTF-16之间，所以UTF-8在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。 4. 在Java Web中设计的编解码有I/O的地方就会涉及编码。网络传输都是以字节为单位的，所以所有的数据必须能够被序列化，即继承Serializable。一个文本的实际大小应该怎么计算。例如：把整型数字1234567当做字符哎存储，则采用UTF-8编码会占用7个字节，采用UTF-16编码会占用14个字节，但是当把它当成int类型的数字来存储则只需要4个字节。 1. URL的编码其中浏览器对PathInfo和QueryString是编码不同的，因此服务器分别在不同的地方对其进行解码。例如Tomcat先判断URIEncoding是否有定义，如果没有则默认使用ISO-8859-1解析。而QueryString，无论POST请求还是GET请求，对它们的解码都是在request.getParameters()方法中，当然内部对POST和GET解码是不同的。其中GET请求，是通过HTTP的Header传到服务端的，是通过useBodyEncodingForURL设置。因此在服务器最好设置URIEncoding和useBodyEncoding两个参数。 2. HTTP Header的编解码如Cookie等，一些头信息，Tomcat对Header解码是在调用request.getHeader()方法时进行的。如果有非ASCII字符，使用URLEncoder进行编码，网络传输。 3. POST表单的编解码提交时，浏览器先根据ContentType的Charset编码进行参数编码，然后再提交到服务端，服务端同样也用ContentType中的字符集进行解码。服务端可以通过request.setCharacterEncoding(charset)来设置。注意：要在第一次调用request.getParameter()方法之前就设置request.setCharacterEncoding(charset)。如果服务端没有设置request.setCharacterEncoding(charset)，那么表单提交的数据将会按照系统的默认编码方式解析。另外，针对multipart/form-data类型的参数，即上传文件，也是通过ContentType定义的字符编码。上传文件是用字节流的方式传输到服务器的本地临时目录，这个过程并没有涉及字符编码，而真正编码是在讲文件内容添加到parameters，如果用这个不能编码，则会使用默认的ISO-8859-1编码。 4. HTTP BODY的编解码通过Response返回给客户端浏览器。这个过程要经过编码，即response.setCharcterEncoding()来设置，它将会覆盖request.getCharacterEncoding()的值，并通过Header的Content-Type返回客户端，浏览器接收到返回的Socket流时将通过Content-Type的charset来解码。如果返回的HTTP Header中Content-Type没有设置charset，那么浏览器将根据浏览器的中的charset来解码，如果浏览器中没有定义，则使用默认的编码。连接JDBC也是指定一致的编码：jdbc:mysql://localhost:3306?DB?useUnicode=true&amp;characterEncoding=GBK。 5. 在JS的编码1. 外部引入JS文件1&lt;script scr="script.js" charset="gbk"&gt;&lt;/script&gt; 而script.js脚本中，有如下代码：1document.write("中国"); 如果引入的时候没有设置charset，浏览器就会以当前页面的默认字符集解析这个JS文件。如果一致那就没问题，但是如果页面和js字符编码不一致，就会变成乱码。 2. JS的URL编码1. escape()这组函数已经从ECMAScript v3标准删除了，URL的编码可以用encodeURI和encodeURIComponent来代替。 2. encodeURI()对某些特殊的字符不进行编码如!、a-z、A-Z、0-9、=、@、?、;、:、-、+、(、)、&amp;、#、.、~、*。 3. encodeURIComponent()编码更加彻底，用于整个URL编码，因为它将&amp;也编码了。除了!、a-z、A-Z、0-9、-、、.、~、*。 4. Java与JS编解码问题Java端处理URL编解码有两个类，分别是URLEncoder和URLDecoder。这两个类可以将所有“%”加UTF-8码值用UTF-8解码，从而得到原始的值。对应的前端JS是encodeURIComponent和decodeURLComponent。注意，前端用encodeURIComponent，服务端用URLDecoder解码可能会乱码，可能是两个字符编码类型不一致，JS编码默认是UTF-8编码，而服务端中文解码一般都是GBK或者GB2312，所以encodeURIComponent编码后是UTF-8，而Java用GBK去解码显然不对。解决方式是encodeURIComponent两次编码，服务端使用request.getParameter()用GBK解码后，再用UTF-8解码。 6. 常见编码问题1. 中文变成看不懂的字符1234String a = "淘！我喜欢！";byte[] b = a.getBytes("GBK"); //可以表示中文，占两个字节String c = new String(b, "ISO-8859-1"); //将两个字节分别作为一个单独的字符显示System.out.println(c); // output: ÌÔ£¡ÎÒÏ²»¶£¡ 双字节变成单字节 2. 中文变成一个问号1234String a = "淘！我喜欢！";byte[] b = a.getBytes("ISO-8859-1"); //找不到对应的字符String c = new String(b, "ISO-8859-1");System.out.println(c); // ?????? 3. 中文变成两个问号经过了多次的编码解码。 4. 一种不正常的正确编码直接调用String value = request.getParameter(name);会出现乱码。但是String value = new String(request.getParameter(name).getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;)会正常，为什么呢？网络通过GBK编码之后的字节数组进行传输，Tomcat没有配置useBodyEncodingForURI，造成第一次解析通过ISO-8859-1解析，这时候我们手动通过ISO-8859-1编码，再通过GBK解码就可以获得正确的值，但是额外增加了一次编解码过程。 7. 总结总结了几种常见编码格式的区别： ISO-8859-1：单字节编码，最多能表示256个字符。 GBK、GB2312：双字节编码，前者兼容后者。 UTF-16：双字节编码，Java内部内存额字符存储格式，操作方便，全部都是两个字节，但是浪费空间。 UTF-8：动态字节编码。以及IO的编码实现类：StreamEncoder/StreamDecoder，对char和byte的编解码。 HTTP过程的编码，包括： URL、URI的编码。 Header的编解码。 POST表单的编解码。Java使用request.getParameter()获取之前，先设置request.setCharacterEncoding(charset)。 BODY的编解码，即Response的编解码。 JS的编解码。 Tomcat编解码源码。以及常见乱码问题的原因。注意一定要手动设置编码的格式，实现真正的跨平台。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二、课外学习NIO]]></title>
    <url>%2F2017%2F08%2F04%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%85%B3%E4%BA%8ENIO%2F</url>
    <content type="text"><![CDATA[1.跑个Channel实例12345678910111213141516171819202122232425262728@Test public void testFileChannel() throws Exception &#123; // 源目标，春运的100W人 RandomAccessFile aFile=new RandomAccessFile("data.txt","rw"); // 获得源目标的运载交通工具，例如动车，同时动车的站台也站了100W人。 FileChannel inChannel=aFile.getChannel(); // 分配buffer，这次春运，这辆D8888，每次跑两个字节单位的座位 ByteBuffer buf=ByteBuffer.allocate(2); // 把动车的站台人和座位连接在一起，得到一个返回值，即该动车和两个字节单位座位的车票信息。 int bytesRead=inChannel.read(buf); // 车票如果是-1说明车票没了，载完了，动车就去保养了。 while(bytesRead!=-1) &#123; // 座位的保险带绑上，人不能下座位或者上座位了，只能被车站人员检查 buf.flip(); // 车站人员检查座位是否有对应的人的信息 while(buf.hasRemaining()) &#123; // 打印出以两个字节为单位的座位的人的信息 System.out.print((char)buf.get()); &#125; // 座位保险带放开，人下车，座位就被清空 buf.clear(); // 动车继续拉两个字节座位的人，又得到了座位的车票信息 bytesRead=inChannel.read(buf); &#125; aFile.close();&#125; 其中的Buffer作为一个顶层抽象类，下面有不止八个子类，对应八种数据类型以及其他一些类型。当Buffer，即座位在调用flip()方法之前，是写模式，即保险带是放开的，想上就上想下就下。切记：Buffer只是在一个改变capacity、position、limit三个值的方法（还有mark，用于临时标记position，通常用于发送某个指定位置之后，返回到发送指定位置之前的position，因为内部提供了方法用于这个需求）。 1. 写模式 capacity：固定的大小。 position：初始值为0，写一单位数据就移动下一个可插入数据的单位，最大为capacity-1。 limit：额外的变量，用于读写分离。此时limit=capacity，写入的最大值。 2. 读模式 capacity：固定的大小。 position：重置为0，读一单位数据就移动下一个可插入数据的单位。 limit：重置为position，你只能读你写了多少单位的数据。（flip()方法其实，就是将limit重置为position，position重置为0） 2. Buffer读写数据以及常用方法除了通过Channel写入数据，还可以使用Buffer.put()，写入执行某个位置。也可以通过Buffer.get()，读取某个位置的数据。 1. Buffer.clear()limit设置为capacity，position重置为0。 2. Buffer.compact()释放缓存区无用数据。当源目标为Mellow，我们已经读取了Me，现在缓存区还是Mellow，但是Me是无用的，这时候就可以调用该方法。 你可以使用Buffer.put()以及Buffer.get()方法达到这个效果。底层其实是将position-limit数据复制到开始的位置，并重置position = limit - position。WHY？这个position是什么意思？其实原因在于这个方法用于：我读了Me，position为2，此时我想开始写数据，但是我以后会在某个时间点回来继续读，则position就变成4，以后不管你写了多少，都正好不会覆盖未读数据。 3. Buffer.rewind()用于position重置为0，即重新开始写，或者读。 4. Buffer.mark()和Buffer.reset()mark默认为-1。mark()：将当前position赋值给mark变量。reset()：将mark赋值给position变量。 5. Buffer.equals()和Buffer.compareTo()相等的条件：类型相同、剩余的单位数量相同、剩余的单位类型相同。比较的条件：第一个不相同的元素的大小，如果都相同，则看数量的多少。 3. scatter与gather1. scatter12345ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] byteBuffers = &#123;header, body&#125;;FileChannel channel = new RandomAccessFile("data.txt","rw").getChannel();channel.read(byteBuffers); 不适用与动态消息，第一个Buffer被填充完毕之后才会填充第二个。 2. gather12345ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] buffers = &#123;header, body&#125;;FileChannel channel = new RandomAccessFile("data.txt","rw").getChannel();channel.write(buffers); 只会有position-limit的数据会被写入。 4. Channel之间进行数据传输1234567RandomAccessFile sourceFile = new RandomAccessFile("SourceData.txt", "rw");FileChannel sourceChannel = sourceFile.getChannel();RandomAccessFile targetFile = new RandomAccessFile("TargetData.txt", "rw");FileChannel targetChannel = targetFile.getChannel();long position = 0;long count = sourceChannel.size();targetChannel.transferFrom(sourceChannel, position, count); 还有一个Channel.transferTo()方法，和上面的方法相反的作用。注意：目标文件如果本来大于源文件，目标文件只会被覆盖源文件要传输的数据，剩余的数据还会存在。如果count传入的时候实际大于size，则被当做count，如果小于size，则会按小于的值覆盖。查看源码即可知。 5. Selector1. 为什么使用Selector？Selector是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样一个单独的线程可以管理多个Channel，从而管理多个网络连接。可以使用一个线程处理所有的通道，而对于操作系统来说，线程之间上下文切换的开销很大，Selector则是可以处理多个Channel。 2. Selector使用1234567// 创建SeletorSelector selector = Selector.open();// channel注册到selector// 继承自AbstractSelectableChannel的方法ServerSocketChannel channel = ServerSocketChannel.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ); 与Selector一起使用时，Channel必须处于费阻塞模式下，而FileChannel只能是阻塞模式，套接字可以切换。监听的第二个参数是不同类型的事件： Connect：SelectionKey.OP_CONNECT Accept：SelectionKey.OP_ACCEPT Read：SelectionKey.OP_READ Write：SelectionKey.OP_WRITE监听多个事件：第二个参数输入：SelectionKey.OP_CONNECT | SelectionKey.OP_CONNECT 3. SelectionKey1. interset属性其中包含了一些你感兴趣的属性，即注册的事件：12345int interestSet = selectionKey.interestOps();boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;boolean isInterestedInConnect = (interestSet &amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;boolean isInterestedInRead = (interestSet &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;boolean isInterestedInWrite = (interestSet &amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE; 2. ready属性ready集合是通道已经准备九局的操作的集合，你可以通过int readySet = selectionKey.readyOps()进行分别的访问，也可以使用：1234selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); 3. Selector获得Channel12Channel channel = selectionKey.channel();Selector selector = selectionKey.selector(); 4. 附加的对象（可选）12selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment(); 5. 通过Selector选择通道 int select()该方法会让Selector阻塞，直到至少有一个Channel在你注册的事件上就绪。 int select(long timeout)设置最长阻塞的毫秒数 int selectNow()直接返回，无论什么Channel。 返回值表示从上次select()方法调用之后，又有多少符合要求的Channel，不叠加。 6. wakeUp()某个线程调用select()让某个Selector阻塞后，使用该方法可以立马返回，如果没有阻塞，但是提前调用了wakeUp方法，那么下个调用select方法的线程会立即wake up。 7. 遍历SelectorKeys12345678910111213141516Selector selector = Selector.open();Set selectionKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();while (iterator.hasNext()) &#123; SelectionKey key = iterator.next(); if (key.isAcceptable()) &#123; &#125; else if (key.isConnectable()) &#123; &#125; else if (key.isReadable()) &#123; &#125; else if (key.isWritable()) &#123; &#125; iterator.remove();&#125; 需要手动将事件给移除。 4. 完整的示例1234567891011121314int port = 9999; ServerSocketChannel channel = ServerSocketChannel.open();channel.configureBlocking(false); channel.socket().bind(new InetSocketAddress(port)); Selector selector = Selector.open(); SelectionKey selKey = channel.register(selector, SelectionKey.OP_ACCEPT); int interestSet = selKey.interestOps(); boolean is_accept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;System.out.print("isAccept:"+ is_accept); 6. FileChannel文件通道，用于文件的读写，常用，由于FileChannel无法设置非阻塞模式，它总是运行在阻塞模式下。1234567891011 String str = "112中国";RandomAccessFile file = new RandomAccessFile( "D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt", "rw");FileChannel channel = file.getChannel();channel.position(channel.position() + file.length()); //这行代码设置写入文件的最后ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put(str.getBytes());buffer.flip();while (buffer.hasRemaining()) &#123; channel.write(buffer);&#125; 还有用于截取通道的方法：truncate()，以字节为单位。还有一个force()方法，用于强行将数据写入磁盘，操作系统一般先将数据写入内存，再从内存写入磁盘，设置为True即可。 7. SocketChannel1234567891011121314// 客户端连接，最后使用close关闭。SocketChannel channel = SocketChannel.open();channel.connect(new InetSocketAddress(8989));ByteBuffer buffer = ByteBuffer.allocate(48);channel.read(buffer);// 从buffer中写入数据到channelString data = "what ? ";buffer.clear();buffer.put(data.getBytes());buffer.flip();while (buffer.hasRemaining()) &#123; channel.write(buffer);&#125;channel.close(); 8. ServerSocketChannel12345678910111213// 服务端开启监听：ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.configureBlocking(false);serverSocketChannel.socket().bind(new InetSocketAddress(8777));while (true)&#123; SocketChannel channel = serverSocketChannel.accept(); // 如果设置为非阻塞，则上面的代码会立马返回，需要判空，是否有连接。 if (channel != null)&#123; String ip = serverSocketChannel.socket().getInetAddress().getHostAddress(); System.out.println(ip); // 此时你得到了channel，就可以使用Buffer对数据进行读取操作了。 &#125;&#125; 9. DatagramChannel用于UDP数据的发送和接收123456// 服务端DatagramChannel channel = DatagramChannel.open();channel.socket().bind(new InetSocketAddress(9999));ByteBuffer buffer = ByteBuffer.allocate(48);channel.configureBlocking(false);channel.receive(buffer); //将得到的UDP数据写入buffer中 12345678// 客户端DatagramChannel channel = DatagramChannel.open();String data = "中国";ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put(data.getBytes());buffer.flip();channel.send(buffer, new InetSocketAddress(9999));channel.close(); 10. Pipe作为两个线程之间的单向数据连接连接（Channel本身是双向，但是通过两个双向的管道一起组合实现成一个单向的，即Sink-&gt;Source）。12345678910111213// 向管道写数据Pipe pipe = Pipe.open();Pipe.SinkChannel sinkChannel = pipe.sink();ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put("中国人".getBytes());buffer.flip();while (buffer.hasRemaining())&#123; sinkChannel.write(buffer);&#125;// 从管道读数据Pipe.SourceChannel sourceChannel = pipe.source();buffer.clear();sourceChannel.read(buffer); 11. NIO和IO1. 面向流和面向缓冲IO面向流，每次从流中读取一个或多个字节，直至读取所有的字节，没有被缓存再任何地方，另外，也不能移动流中的数据，如果想移动，需要手动将流中的数据缓存在一个第三方缓冲区变量中。而NIO则本身就将数据放入到缓冲区中，可以在缓冲区中前后移动，只是加多了对缓冲区的判断以及更多数据进入缓冲区时，不能覆盖原来的数据。 2. 阻塞和非阻塞本质区别，IO在读写直接阻塞。而NIO的读写的操作会直接返回值，进入下一步操作不会阻塞，并通过Selector来实现一个线程对多个Channel，即多个读写进行管理。 3. 数据的处理 IO的设计逐字节读取数据。例如你正在处理基于行的文本数据流： 1234567891011/**data.txt * Name: xxx * Age: 18 * Email: xxx@gmail.com * Phone: 135xxxxx */BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("data.txt")));String nameLine = reader.readLine();String ageLine = reader.readLine();String emailLine = reader.readLine();String phoneLine = reader.readLine(); NIO直接读写： 12345678ByteBuffer buffer = ByteBuffer.allocate(48);FileChannel channel = new RandomAccessFile("data.txt", "rw").getChannel();int bytesRead = channel.read(buffer);while (bytesRead != -1) &#123; channel.read(buffer);&#125;channel.close(); 4. 总结 NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。 如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一、深入Web请求过程]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5Web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. DNS域名解析使用浏览器输入网址后，浏览器会检查缓存对应的IP地址，如果没有，浏览器会查找操作系统，即host文件。所以很多墙外比较慢的网址，可以手动编写host文件对应的IP地址以及对应的网址，可以加快访问速度。如果实在没有就发送给LDNS，这个LDNS在不同的情况是不一样的，在学校，大部分都是学校的DNS服务器，家庭的一般都是联通或者电信的DNS服务器，最最最后实在解析不出来，就抛给Root Server域名服务器，它会返回给本地域名服务器的主域名服务器的地址，即域名空间提供商的域名解析服务器，就像阿里域名解析加速。 2. 清除缓存的域名主要在两个地方缓存：Local DNS Server, 另一个是用户的本机，当然，重启也是更好的方法。 ipconfig /flushdns 在java中，JVM也会缓存DNS的解析结果，分两种，即正确的解析结果，以及错误的解析结果，InetAddress，实际中InetAddress使用必须是单例模式，因为每次创建InetAddress实例都要进行一次完整的域名解析。 3. CDN工作机制CDN也就是内容分布网络(Content Delivery Network)。通过在现有的Internet中增加一层新的网络架构，比镜像更智能。比喻：CDN=镜像Mirror+缓存Cache+整体负载均衡GSLB。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态页面等，用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据。 4. 负载均衡负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，提高服务器响应速度，实现地理位置无关性。通常有三种负载均衡架构：链路负载均衡、集群负载均衡、操作系统负载均衡。 链路：用户最终访问哪个Web Server是由DNS Server来控制的，优点在于用户直接访问目标服务器，不需要经过其它的代理服务器，通常访问速度更快，缺点在于DNS在用户本地和LDNS都有缓存，一旦某台Web Server挂掉，就难及时更新用户的域名解析结构。 集群：硬件负载以及软件负载均衡，前者需要贵的硬件作为中心，而软件则是成本低，但是需要多次代理服务器转发，从而增加了网络延时。 操作系统：如设置多队列网卡。 5. CDN动态加速原理在于CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，通过DNS的调度将所有请求到选定的路径上回源，一个简单的原则就是在每个CDN节点上从源站下载一个一定大小文件，看哪个链路的总耗时最短，这样可以构成一个链路列表，然后绑定到DNS解析上，更新到CDN的Local DNS。以及网络成本等。 6. 总结主要介绍域名的请求，哪些处理，对CDN以及负载均衡有了解。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二、深入分析Java IO的工作机制]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20IO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. JAVA的I/O类库的基本架构 基于字节操作的I/O接口：InputStream和OutputStream。 基于字符操作的I/O操作：Writer和Reader。 基于磁盘操作的I/O操作：File。 基于网络操作的I/O操作：Socket。 2. 字节字符的转换低级的字节转字符，有InputStreamReader，以及OutputStreamWriter。而字符转字节一般直接用new String(byte[])。注意：字符字节的转换在开发中一定要显示指明编码。在OutputStreamWriter的官方注释中，错误的理解为从字符到字节，其实应该理解成字符与字节之间的桥梁。 3. 访问文件的几种方式前言：读取和写入都是调用操作系统的提供的接口，而操作系统调用就会存在内核空间地址和用户空间地址切换的问题，一般的IO都是数据从磁盘复制到内核空间，然后再从内核空间复制到用户空间，操作系统为了加速IO访问，在内核空间使用了缓存，即如果是第二次访问同一段的磁盘地址，直接从内核缓存中取出。 1. 标准访问文件的方式读取：调用操作系统的Read接口，操作系统先检查内核的高速缓存，如果有缓存则直接返回，如果没有则从磁盘中读取，缓存，返回。写入：调用操作系统的Writer接口，写入到高速缓存中，则通知应用程序完成，什么时候写入磁盘由操作系统决定。当然你可以使用sync强制刷新。 2. 直接I/O的方式即应用程序直接访问磁盘数据，减少一次从内核缓冲区到用户空间的数据复制，例如数据库管理系统，数据库明确的知道哪些数据需要缓存哪些不需要，以及哪些数据需要先放到内存中预热，但是不好的地方在于，你接管了数据缓存，如果你没有命中，则每次都是IO磁盘，比较耗时，通常结合直接IO与异步IO。 3. 同步访问文件的方式与标准访问文件不同点在于，写入了磁盘，操作系统才会应用程序返回成功的标志，用于安全性高的场景。 4. 异步访问文件的方式访问文件的请求线程发出后，不会阻塞等待，继续做别的事，完成文件访问后回调某个方法，提高应用程序的效率而不是访问文件的效率。 5. 内存映射的方式操作系统将内存中的某一块区域与磁盘中的文件关联，理解为快捷方式。这样中间加了一层地址映射，空间换时间，在实际开发中，多台业务服务器对一个统一的路径下进行共享，方便数据的存储。例如A服务器下的data和B服务器下的data进行共享，便于文件的统一上传下载路径管理。 4. 访问磁盘文件前面介绍了操作数据，接着这里介绍数据写向何处，例如持久化到物理磁盘。FileInputStream对象是操作一个文件的接口，创建的同时会创建该文件的描述对象FileDescriptor。操作文件对象的时候可以通过getFD()方法获取真正与底层操作系统相关联的文件描述。例如调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。byte-&gt;char是解码过程，因此读取文件都是需要StreamDecoder类帮助。 1. Java序列化技术将对象转化成一串二进制表示的字符数组，反序列化时需要原始类作为模板，原因在于序列化之后的文件不保存类的完整结构信息。建议保存为通用的json/xml格式，比较耗的序列化工具：protobuf。序列化以及反序列需要注意一些常见的问题，例如serialVersionUID被修改，序列化对象中有属性为对象但是该属性对象没有实现Serializable等。 5. 网络I/O工作机制1. TCP状态 三次握手客户端CLOSED、SYN-SEND、ESTABLISHED。服务端LISTEN、SYN-RCVD、ESTABLISHED。 四次挥手客户端ESTABLISHED、FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT。服务端ESTABLISHED、CLOSE_WAIT、LAST_ACK、CLOSE。 2. 影响网络传输的因素 网络带宽：物理链路在1s内传输的最大比特值，一般都是1.7Mb/s。 传输距离。 TCP拥塞控制：TCP传输是一个“停等停等”的过程，要步调一致则需要通过拥塞控制来调节。TCP在传输时会设定一个“窗口”，窗口大小由带宽和数据在两端的来回时间，即响应时间决定的。 3. Java Socket的工作机制客户端开始建立一个Socket实例时，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、远程地址和端口号的套接字数据结构，这个数据结构一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将进行TCP的三次握手协议，三次握手，完成之后，Socket实例创建完成。服务端将创建一个ServerSocket实例，只要指定的端口号没有被占用，一般实例都会创建成功，操作系统底层也会为ServerSocket实例创建一个底层数据结构，这个数据结构中包含指定的端口号和包含监听地址的通配符，通常都是“*”，即监听所有地址。之后调用accept()方法，进入阻塞状态，等待客户端的请求。当一个新的请求到达时，为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口，同时这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，此时服务端的与之对应的Socket实例并没有完成创建，而是要等待与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并从未连接数据结构列表移到已完成列表。所以与ServerSocket所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。 4. 数据传输服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream，通过这两个对象来交换数据，同时操作系统会为这两个对象分配一定大小的缓存区。 写入：数据-&gt;OutputStream对应的SendQ队列，队列填满时，数据将会转移到另一端的InputStream的RecvQ队列中，如果RecvQ已经满了，那么OuptStream的write方法将会阻塞，直到RecvQ队列可以容纳SendQ队列的数据。因此网络IO还需要一个协调的过程，如果两边同时传输数据则会产生死锁。 6. NIO的工作方式(建议先阅读课外学习：关于NIO)1. BIO的缺点阻塞IO，即BIO，在读取和写入时（InputStream、OutputStream）都有可能堵塞，一旦有堵塞，线程将会失去CPU的使用权，一些方法，例如：一个客户端一个处理线程、线程池用来减少线程创建和回收的成本。但是，当需要大量的HTTP长连接，例如Web旺旺，虽然并不是每个连接都一直在传输数据，但是如果要对某个客户端（VIP）提供更高的服务优先，很难通过线程本省的优先级完成，同时访问一些竞争资源时，也会有问题，因此需要同步。因此NIO应运而生。 2. NIO的工作机制通过等待读以及等待写的轮询，在真正进行IO的时候才是使用CPU阻塞，但是由于是memory copy，在带宽足够大的1GB/s基本可以忽略。 3. Buffer的工作方式可以简单理解为操作一组基本数据类型的元素列表：capacity、position、limit、mark。注意，通过Channel获取的IO数据首先经过操作系统的Socket缓冲区，再将数据复制到Buffer中，这个操作系统缓冲区就是底层的TCP所关联的RecvQ或者SendQ队列。Buffer提供了另一种直接操作操作系统缓冲区的方式，即ByteBuffer.allocateDirector()，这个方法直接返回底层存储空间关联的缓冲区，它通过Native代码操作非JVM堆的内存空间，每次创建或者释放都要手动调用一次System.gc()。注意：使用该方法直接操作非JVM堆空间会引起JVM内存泄漏问题。适用于数据量比较大，生命周期比较长的情况下，而普通的allocate()方法适用并发连接少于1000。 4. FileChannel的数据访问1. FileChannel.transferXXX传统的数据访问方式：FileChannel.transferXXX方式： 2. FileChannel.map将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，省去了数据从内核空间向用户空间复制的损耗。适用于对大文件的只读性操作，如大文件的MD5校验。 7. IO调优1. 磁盘I/O优化1. 性能检测在Linux下的iostat命令，查看I/O wait指标是否正常，即CPU等待I/O指标，如果是4核CPU，那么I、O wait参数不应该超过25%。 2. 提升I/O性能 增加缓存，减少磁盘访问次数。 优化磁盘的管理系统 设计合理的磁盘存储数据块。 2. TCP网络参数调优操作系统的端口号：2^16 = 65535个。通过查看cat /proc/sys/net/ipv4/ip_local_port_range查看端口范围大量并发，端口号的数量就变成瓶颈，还有TIME_WAIT的数量，如果过多，需要将参数设小，提前释放。 3. 网络I/O优化 减少网络交互的次数SQL在客户端和数据库端设置缓存，请求css、js等可以合并为一个http链接，每个文件通过逗号隔开，服务端一次请求全部返回。 减少网络传输数据量的大小通常Web服务器将请求的Web页面gzip压缩后再传输给浏览器。以及通过简单的协议，读取协议头来获取有用的价值信息。尽量避免读取整个通信数据，例如4层代理和7层代理，都是精良避免要读取整个通信数据。 尽量减少编码尽量以字节形式发送。 1. 同步与异步 同步一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列，同生同死。同步能保证程序的可靠性。 异步不需要等待被依赖的任务完成只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行。异步可以提高程序的性能，需要在同步与异步中保持平衡 2. 阻塞和非阻塞阻塞和非阻塞主要从CPU的消耗上来说。 阻塞CPU停下等待一个慢的操作完成之后，CPU才接着完成其他的工作。 非阻塞这个慢操作执行时，CPU去做其他工作，这个慢操作完成时，CPU收到通知继续完成这个慢操作之后的事。 3. 两种方式的组合 同步阻塞常用，简单，但是IO性能差，CPU大部分处于空闲状态。 同步非阻塞常用于网络IO是长连接同时传输数据不多的情况。提升IO性能的常用手段，会增加CPU消耗，要考虑增加的IO性能能不能补偿CPU的消耗，也就是系统的瓶颈是在IO还是CPU上。 异步阻塞常用于分布式数据库中。例如一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2~3份备份记录会写到其他机器上，这些备份记录通常都采用异步阻塞的方式写IO，异步阻塞对网络IO能够提升效率，尤其像上面这种同时写多份相同数据的情况。 异步非阻塞比较复杂，只有在非常负载的分布式情况下使用，集群之间的消息同步机制一般使用这种IO组合方式。如Cassandra的Gossip通信机制就采用异步非阻塞的方式。适用于同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大但非常频繁的情况。 虽然异步和非阻塞能够提高IO整体性能，但是会增加性能成本，以及程序设计复杂的上升，需要经验丰富的人去设计，如果设计的不合理反而会导致性能下降。怎样理解阻塞非阻塞与同步异步的区别？ 8. 适配器模式博主做一个Integer转化为String的例子，仿造InputStream转化Reader的简单例子。123456789101112131415public class InputInteger_ implements Integer_ &#123; private Integer a; public InputInteger_(Integer a)&#123; this.a = a; &#125; public Integer getInteger()&#123; return a; &#125;&#125;public interface Integer_ &#123; public Integer getInteger();&#125; 123456789public class String_ implements InputString_ &#123; public void readString() &#123; &#125;&#125;public interface InputString_ &#123; public void readString();&#125; 1234567891011121314public class InputInteger2String implements InputString_ &#123; Integer_ s; public InputInteger2String(Integer_ s) &#123; this.s = s; &#125; public void readString() &#123; // StreamDecoder Integer r = Integer.valueOf(s.getInteger()); System.out.println(r); &#125;&#125; 123456public class Demo &#123; public static void main(String[] args) &#123; InputInteger2String s = new InputInteger2String(new InputInteger_(4)); s.readString(); &#125;&#125; 9. 装饰器模式赋予被装饰的类更多的功能，就像IO中的BufferedInputStream有缓冲的功能，LineNumberInputStream有提高按行读取数据的功能。1234567891011121314151617181920public abstract class InputStream_ &#123; public abstract void read();&#125;public class FileInputStream_ extends InputStream_ &#123; public void read() &#123; &#125;&#125;public class FilterInputStream_ extends InputStream_ &#123; protected InputStream_ inputStream_; public FilterInputStream_(InputStream_ inputStream_)&#123; this.inputStream_ = inputStream_; &#125; public void read() &#123; inputStream_.read(); &#125;&#125; 1234567891011121314151617181920public class BufferInputStream_ extends FilterInputStream_ &#123; public BufferInputStream_(InputStream_ inputStream_) &#123; super(inputStream_); &#125; private void bufferFirst()&#123; &#125; private void bufferEnd()&#123; &#125; public void read()&#123; bufferFirst(); super.read(); bufferEnd(); &#125;&#125; 123456789public class Demo &#123; public static void main(String[] args)&#123; InputStream_ inputStream_ = new FileInputStream_(); BufferInputStream_ bufferInputStream_ = new BufferInputStream_(inputStream_); bufferInputStream_.read(); &#125;&#125; 10. 适配器模式与装饰器模式区别它们有个别名，叫包装模式，都起到了包装一个类或对象的作用，但是作用不同。适配器通过改变接口来达到重复使用的目的（如果系统在设计初期，就尽量不要用适配器模式），而装饰器模式保持原有的接口，增强原有对象的功能。 11. 总结Java中IO的基本库结构，磁盘IO和网络IO的工作方式。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
</search>