<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二、课外学习NIO]]></title>
    <url>%2F2017%2F08%2F05%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%85%B3%E4%BA%8ENIO%2F</url>
    <content type="text"><![CDATA[1.跑个Channel实例12345678910111213141516171819202122232425262728@Test public void testFileChannel() throws Exception &#123; // 源目标，春运的100W人 RandomAccessFile aFile=new RandomAccessFile("data.txt","rw"); // 获得源目标的运载交通工具，例如动车，同时动车的站台也站了100W人。 FileChannel inChannel=aFile.getChannel(); // 分配buffer，这次春运，这辆D8888，每次跑两个字节单位的座位 ByteBuffer buf=ByteBuffer.allocate(2); // 把动车的站台人和座位连接在一起，得到一个返回值，即该动车和两个字节单位座位的车票信息。 int bytesRead=inChannel.read(buf); // 车票如果是-1说明车票没了，载完了，动车就去保养了。 while(bytesRead!=-1) &#123; // 座位的保险带绑上，人不能下座位或者上座位了，只能被车站人员检查 buf.flip(); // 车站人员检查座位是否有对应的人的信息 while(buf.hasRemaining()) &#123; // 打印出以两个字节为单位的座位的人的信息 System.out.print((char)buf.get()); &#125; // 座位保险带放开，人下车，座位就被清空 buf.clear(); // 动车继续拉两个字节座位的人，又得到了座位的车票信息 bytesRead=inChannel.read(buf); &#125; aFile.close();&#125; 其中的Buffer作为一个顶层抽象类，下面有不止八个子类，对应八种数据类型以及其他一些类型。当Buffer，即座位在调用flip()方法之前，是写模式，即保险带是放开的，想上就上想下就下。切记：Buffer只是在一个改变capacity、position、limit三个值的方法（还有mark，用于临时标记position，通常用于发送某个指定位置之后，返回到发送指定位置之前的position，因为内部提供了方法用于这个需求）。 1. 写模式 capacity：固定的大小。 position：初始值为0，写一单位数据就移动下一个可插入数据的单位，最大为capacity-1。 limit：额外的变量，用于读写分离。此时limit=capacity，写入的最大值。 2. 读模式 capacity：固定的大小。 position：重置为0，读一单位数据就移动下一个可插入数据的单位。 limit：重置为position，你只能读你写了多少单位的数据。（flip()方法其实，就是将limit重置为position，position重置为0） 2. Buffer读写数据以及常用方法除了通过Channel写入数据，还可以使用Buffer.put()，写入执行某个位置。也可以通过Buffer.get()，读取某个位置的数据。 1. Buffer.clear()limit设置为capacity，position重置为0。 2. Buffer.compact()释放缓存区无用数据。当源目标为Mellow，我们已经读取了Me，现在缓存区还是Mellow，但是Me是无用的，这时候就可以调用该方法。 你可以使用Buffer.put()以及Buffer.get()方法达到这个效果。底层其实是将position-limit数据复制到开始的位置，并重置position = limit - position。WHY？这个position是什么意思？其实原因在于这个方法用于：我读了Me，position为2，此时我想开始写数据，但是我以后会在某个时间点回来继续读，则position就变成4，以后不管你写了多少，都正好不会覆盖未读数据。 3. Buffer.rewind()用于position重置为0，即重新开始写，或者读。 4. Buffer.mark()和Buffer.reset()mark默认为-1。mark()：将当前position赋值给mark变量。reset()：将mark赋值给position变量。 5. Buffer.equals()和Buffer.compareTo()相等的条件：类型相同、剩余的单位数量相同、剩余的单位类型相同。比较的条件：第一个不相同的元素的大小，如果都相同，则看数量的多少。 3. scatter与gather1. scatter12345ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] byteBuffers = &#123;header, body&#125;;FileChannel channel = new RandomAccessFile("data.txt","rw").getChannel();channel.read(byteBuffers); 不适用与动态消息，第一个Buffer被填充完毕之后才会填充第二个。 2. gather12345ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] buffers = &#123;header, body&#125;;FileChannel channel = new RandomAccessFile("data.txt","rw").getChannel();channel.write(buffers); 只会有position-limit的数据会被写入。 4. Channel之间进行数据传输1234567RandomAccessFile sourceFile = new RandomAccessFile("SourceData.txt", "rw");FileChannel sourceChannel = sourceFile.getChannel();RandomAccessFile targetFile = new RandomAccessFile("TargetData.txt", "rw");FileChannel targetChannel = targetFile.getChannel();long position = 0;long count = sourceChannel.size();targetChannel.transferFrom(sourceChannel, position, count); 还有一个Channel.transferTo()方法，和上面的方法相反的作用。注意：目标文件如果本来大于源文件，目标文件只会被覆盖源文件要传输的数据，剩余的数据还会存在。如果count传入的时候实际大于size，则被当做count，如果小于size，则会按小于的值覆盖。查看源码即可知。 5. Selector1. 为什么使用Selector？Selector是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样一个单独的线程可以管理多个Channel，从而管理多个网络连接。可以使用一个线程处理所有的通道，而对于操作系统来说，线程之间上下文切换的开销很大，Selector则是可以处理多个Channel。 2. Selector使用1234567// 创建SeletorSelector selector = Selector.open();// channel注册到selector// 继承自AbstractSelectableChannel的方法ServerSocketChannel channel = ServerSocketChannel.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ); 与Selector一起使用时，Channel必须处于费阻塞模式下，而FileChannel只能是阻塞模式，套接字可以切换。监听的第二个参数是不同类型的事件： Connect：SelectionKey.OP_CONNECT Accept：SelectionKey.OP_ACCEPT Read：SelectionKey.OP_READ Write：SelectionKey.OP_WRITE监听多个事件：第二个参数输入：SelectionKey.OP_CONNECT | SelectionKey.OP_CONNECT 3. SelectionKey1. interset属性其中包含了一些你感兴趣的属性，即注册的事件：12345int interestSet = selectionKey.interestOps();boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;boolean isInterestedInConnect = (interestSet &amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;boolean isInterestedInRead = (interestSet &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;boolean isInterestedInWrite = (interestSet &amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE; 2. ready属性ready集合是通道已经准备九局的操作的集合，你可以通过int readySet = selectionKey.readyOps()进行分别的访问，也可以使用：1234selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); 3. Selector获得Channel12Channel channel = selectionKey.channel();Selector selector = selectionKey.selector(); 4. 附加的对象（可选）12selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment(); 5. 通过Selector选择通道 int select()该方法会让Selector阻塞，直到至少有一个Channel在你注册的事件上就绪。 int select(long timeout)设置最长阻塞的毫秒数 int selectNow()直接返回，无论什么Channel。 返回值表示从上次select()方法调用之后，又有多少符合要求的Channel，不叠加。 6. wakeUp()某个线程调用select()让某个Selector阻塞后，使用该方法可以立马返回，如果没有阻塞，但是提前调用了wakeUp方法，那么下个调用select方法的线程会立即wake up。 7. 遍历SelectorKeys12345678910111213141516Selector selector = Selector.open();Set selectionKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();while (iterator.hasNext()) &#123; SelectionKey key = iterator.next(); if (key.isAcceptable()) &#123; &#125; else if (key.isConnectable()) &#123; &#125; else if (key.isReadable()) &#123; &#125; else if (key.isWritable()) &#123; &#125; iterator.remove();&#125; 需要手动将事件给移除。 4. 完整的示例1234567891011121314int port = 9999; ServerSocketChannel channel = ServerSocketChannel.open();channel.configureBlocking(false); channel.socket().bind(new InetSocketAddress(port)); Selector selector = Selector.open(); SelectionKey selKey = channel.register(selector, SelectionKey.OP_ACCEPT); int interestSet = selKey.interestOps(); boolean is_accept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;System.out.print("isAccept:"+ is_accept); 6. FileChannel文件通道，用于文件的读写，常用，由于FileChannel无法设置非阻塞模式，它总是运行在阻塞模式下。1234567891011 String str = "112中国";RandomAccessFile file = new RandomAccessFile( "D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt", "rw");FileChannel channel = file.getChannel();channel.position(channel.position() + file.length()); //这行代码设置写入文件的最后ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put(str.getBytes());buffer.flip();while (buffer.hasRemaining()) &#123; channel.write(buffer);&#125; 还有用于截取通道的方法：truncate()，以字节为单位。还有一个force()方法，用于强行将数据写入磁盘，操作系统一般先将数据写入内存，再从内存写入磁盘，设置为True即可。 7. SocketChannel1234567891011121314// 客户端连接，最后使用close关闭。SocketChannel channel = SocketChannel.open();channel.connect(new InetSocketAddress(8989));ByteBuffer buffer = ByteBuffer.allocate(48);channel.read(buffer);// 从buffer中写入数据到channelString data = "what ? ";buffer.clear();buffer.put(data.getBytes());buffer.flip();while (buffer.hasRemaining()) &#123; channel.write(buffer);&#125;channel.close(); 8. ServerSocketChannel12345678910111213// 服务端开启监听：ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.configureBlocking(false);serverSocketChannel.socket().bind(new InetSocketAddress(8777));while (true)&#123; SocketChannel channel = serverSocketChannel.accept(); // 如果设置为非阻塞，则上面的代码会立马返回，需要判空，是否有连接。 if (channel != null)&#123; String ip = serverSocketChannel.socket().getInetAddress().getHostAddress(); System.out.println(ip); // 此时你得到了channel，就可以使用Buffer对数据进行读取操作了。 &#125;&#125; 9. DatagramChannel用于UDP数据的发送和接收123456// 服务端DatagramChannel channel = DatagramChannel.open();channel.socket().bind(new InetSocketAddress(9999));ByteBuffer buffer = ByteBuffer.allocate(48);channel.configureBlocking(false);channel.receive(buffer); //将得到的UDP数据写入buffer中 12345678// 客户端DatagramChannel channel = DatagramChannel.open();String data = "中国";ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put(data.getBytes());buffer.flip();channel.send(buffer, new InetSocketAddress(9999));channel.close(); 10. Pipe作为两个线程之间的单向数据连接连接（Channel本身是双向，但是通过两个双向的管道一起组合实现成一个单向的，即Sink-&gt;Source）。12345678910111213// 向管道写数据Pipe pipe = Pipe.open();Pipe.SinkChannel sinkChannel = pipe.sink();ByteBuffer buffer = ByteBuffer.allocate(48);buffer.put("中国人".getBytes());buffer.flip();while (buffer.hasRemaining())&#123; sinkChannel.write(buffer);&#125;// 从管道读数据Pipe.SourceChannel sourceChannel = pipe.source();buffer.clear();sourceChannel.read(buffer); 11. NIO和IO1. 面向流和面向缓冲IO面向流，每次从流中读取一个或多个字节，直至读取所有的字节，没有被缓存再任何地方，另外，也不能移动流中的数据，如果想移动，需要手动将流中的数据缓存在一个第三方缓冲区变量中。而NIO则本身就将数据放入到缓冲区中，可以在缓冲区中前后移动，只是加多了对缓冲区的判断以及更多数据进入缓冲区时，不能覆盖原来的数据。 2. 阻塞和非阻塞本质区别，IO在读写直接阻塞。而NIO的读写的操作会直接返回值，进入下一步操作不会阻塞，并通过Selector来实现一个线程对多个Channel，即多个读写进行管理。 3. 数据的处理 IO的设计逐字节读取数据。例如你正在处理基于行的文本数据流： 1234567891011/**data.txt * Name: xxx * Age: 18 * Email: xxx@gmail.com * Phone: 135xxxxx */BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("data.txt")));String nameLine = reader.readLine();String ageLine = reader.readLine();String emailLine = reader.readLine();String phoneLine = reader.readLine(); NIO直接读写： 12345678ByteBuffer buffer = ByteBuffer.allocate(48);FileChannel channel = new RandomAccessFile("data.txt", "rw").getChannel();int bytesRead = channel.read(buffer);while (bytesRead != -1) &#123; channel.read(buffer);&#125;channel.close(); 4. 总结 NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。 如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一、深入Web请求过程]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5Web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. DNS域名解析使用浏览器输入网址后，浏览器会检查缓存对应的IP地址，如果没有，浏览器会查找操作系统，即host文件。所以很多墙外比较慢的网址，可以手动编写host文件对应的IP地址以及对应的网址，可以加快访问速度。如果实在没有就发送给LDNS，这个LDNS在不同的情况是不一样的，在学校，大部分都是学校的DNS服务器，家庭的一般都是联通或者电信的DNS服务器，最最最后实在解析不出来，就抛给Root Server域名服务器，它会返回给本地域名服务器的主域名服务器的地址，即域名空间提供商的域名解析服务器，就像阿里域名解析加速。 2. 清除缓存的域名主要在两个地方缓存：Local DNS Server, 另一个是用户的本机，当然，重启也是更好的方法。 ipconfig /flushdns 在java中，JVM也会缓存DNS的解析结果，分两种，即正确的解析结果，以及错误的解析结果，InetAddress，实际中InetAddress使用必须是单例模式，因为每次创建InetAddress实例都要进行一次完整的域名解析。 3. CDN工作机制CDN也就是内容分布网络(Content Delivery Network)。通过在现有的Internet中增加一层新的网络架构，比镜像更智能。比喻：CDN=镜像Mirror+缓存Cache+整体负载均衡GSLB。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态页面等，用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据。 4. 负载均衡负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，提高服务器响应速度，实现地理位置无关性。通常有三种负载均衡架构：链路负载均衡、集群负载均衡、操作系统负载均衡。 链路：用户最终访问哪个Web Server是由DNS Server来控制的，优点在于用户直接访问目标服务器，不需要经过其它的代理服务器，通常访问速度更快，缺点在于DNS在用户本地和LDNS都有缓存，一旦某台Web Server挂掉，就难及时更新用户的域名解析结构。 集群：硬件负载以及软件负载均衡，前者需要贵的硬件作为中心，而软件则是成本低，但是需要多次代理服务器转发，从而增加了网络延时。 操作系统：如设置多队列网卡。 5. CDN动态加速原理在于CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，通过DNS的调度将所有请求到选定的路径上回源，一个简单的原则就是在每个CDN节点上从源站下载一个一定大小文件，看哪个链路的总耗时最短，这样可以构成一个链路列表，然后绑定到DNS解析上，更新到CDN的Local DNS。以及网络成本等。 6. 总结主要介绍域名的请求，哪些处理，对CDN以及负载均衡有了解。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二、深入分析Java IO的工作机制]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java_Web%E6%8A%80%E6%9C%AF%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20IO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. JAVA的I/O类库的基本架构 基于字节操作的I/O接口：InputStream和OutputStream。 基于字符操作的I/O操作：Writer和Reader。 基于磁盘操作的I/O操作：File。 基于网络操作的I/O操作：Socket。 2. 字节字符的转换低级的字节转字符，有InputStreamReader，以及OutputStreamWriter。而字符转字节一般直接用new String(byte[])。注意：字符字节的转换在开发中一定要显示指明编码。在OutputStreamWriter的官方注释中，错误的理解为从字符到字节，其实应该理解成字符与字节之间的桥梁。 3. 访问文件的几种方式前言：读取和写入都是调用操作系统的提供的接口，而操作系统调用就会存在内核空间地址和用户空间地址切换的问题，一般的IO都是数据从磁盘复制到内核空间，然后再从内核空间复制到用户空间，操作系统为了加速IO访问，在内核空间使用了缓存，即如果是第二次访问同一段的磁盘地址，直接从内核缓存中取出。 1. 标准访问文件的方式读取：调用操作系统的Read接口，操作系统先检查内核的高速缓存，如果有缓存则直接返回，如果没有则从磁盘中读取，缓存，返回。写入：调用操作系统的Writer接口，写入到高速缓存中，则通知应用程序完成，什么时候写入磁盘由操作系统决定。当然你可以使用sync强制刷新。 2. 直接I/O的方式即应用程序直接访问磁盘数据，减少一次从内核缓冲区到用户空间的数据复制，例如数据库管理系统，数据库明确的知道哪些数据需要缓存哪些不需要，以及哪些数据需要先放到内存中预热，但是不好的地方在于，你接管了数据缓存，如果你没有命中，则每次都是IO磁盘，比较耗时，通常结合直接IO与异步IO。 3. 同步访问文件的方式与标准访问文件不同点在于，写入了磁盘，操作系统才会应用程序返回成功的标志，用于安全性高的场景。 4. 异步访问文件的方式访问文件的请求线程发出后，不会阻塞等待，继续做别的事，完成文件访问后回调某个方法，提高应用程序的效率而不是访问文件的效率。 5. 内存映射的方式操作系统将内存中的某一块区域与磁盘中的文件关联，理解为快捷方式。这样中间加了一层地址映射，空间换时间，在实际开发中，多台业务服务器对一个统一的路径下进行共享，方便数据的存储。例如A服务器下的data和B服务器下的data进行共享，便于文件的统一上传下载路径管理。 4. 访问磁盘文件前面介绍了操作数据，接着这里介绍数据写向何处，例如持久化到物理磁盘。FileInputStream对象是操作一个文件的接口，创建的同时会创建该文件的描述对象FileDescriptor。操作文件对象的时候可以通过getFD()方法获取真正与底层操作系统相关联的文件描述。例如调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。byte-&gt;char是解码过程，因此读取文件都是需要StreamDecoder类帮助。 1. Java序列化技术将对象转化成一串二进制表示的字符数组，反序列化时需要原始类作为模板，原因在于序列化之后的文件不保存类的完整结构信息。建议保存为通用的json/xml格式，比较耗的序列化工具：protobuf。序列化以及反序列需要注意一些常见的问题，例如serialVersionUID被修改，序列化对象中有属性为对象但是该属性对象没有实现Serializable等。 5. 网络I/O工作机制1. TCP状态 三次握手客户端CLOSED、SYN-SEND、ESTABLISHED。服务端LISTEN、SYN-RCVD、ESTABLISHED。 四次挥手客户端ESTABLISHED、FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT。服务端ESTABLISHED、CLOSE_WAIT、LAST_ACK、CLOSE。 2. 影响网络传输的因素 网络带宽：物理链路在1s内传输的最大比特值，一般都是1.7Mb/s。 传输距离。 TCP拥塞控制：TCP传输是一个“停等停等”的过程，要步调一致则需要通过拥塞控制来调节。TCP在传输时会设定一个“窗口”，窗口大小由带宽和数据在两端的来回时间，即响应时间决定的。 3. Java Socket的工作机制![][1-5)]客户端开始建立一个Socket实例时，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、远程地址和端口号的套接字数据结构，这个数据结构一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将进行TCP的三次握手协议，三次握手，完成之后，Socket实例创建完成。服务端将创建一个ServerSocket实例，只要指定的端口号没有被占用，一般实例都会创建成功，操作系统底层也会为ServerSocket实例创建一个底层数据结构，这个数据结构中包含指定的端口号和包含监听地址的通配符，通常都是“*”，即监听所有地址。之后调用accept()方法，进入阻塞状态，等待客户端的请求。当一个新的请求到达时，为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口，同时这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，此时服务端的与之对应的Socket实例并没有完成创建，而是要等待与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并从未连接数据结构列表移到已完成列表。所以与ServerSocket所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。 4. 数据传输服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream，通过这两个对象来交换数据，同时操作系统会为这两个对象分配一定大小的缓存区。 写入：数据-&gt;OutputStream对应的SendQ队列，队列填满时，数据将会转移到另一端的InputStream的RecvQ队列中，如果RecvQ已经满了，那么OuptStream的write方法将会阻塞，直到RecvQ队列可以容纳SendQ队列的数据。因此网络IO还需要一个协调的过程，如果两边同时传输数据则会产生死锁。 6. NIO的工作方式(建议先阅读课外学习：关于NIO)1. BIO的缺点阻塞IO，即BIO，在读取和写入时（InputStream、OutputStream）都有可能堵塞，一旦有堵塞，线程将会失去CPU的使用权，一些方法，例如：一个客户端一个处理线程、线程池用来减少线程创建和回收的成本。但是，当需要大量的HTTP长连接，例如Web旺旺，虽然并不是每个连接都一直在传输数据，但是如果要对某个客户端（VIP）提供更高的服务优先，很难通过线程本省的优先级完成，同时访问一些竞争资源时，也会有问题，因此需要同步。因此NIO应运而生。 2. NIO的工作机制通过等待读以及等待写的轮询，在真正进行IO的时候才是使用CPU阻塞，但是由于是memory copy，在带宽足够大的1GB/s基本可以忽略。 3. Buffer的工作方式可以简单理解为操作一组基本数据类型的元素列表：capacity、position、limit、mark。注意，通过Channel获取的IO数据首先经过操作系统的Socket缓冲区，再将数据复制到Buffer中，这个操作系统缓冲区就是底层的TCP所关联的RecvQ或者SendQ队列。Buffer提供了另一种直接操作操作系统缓冲区的方式，即ByteBuffer.allocateDirector()，这个方法直接返回底层存储空间关联的缓冲区，它通过Native代码操作非JVM堆的内存空间，每次创建或者释放都要手动调用一次System.gc()。注意：使用该方法直接操作非JVM堆空间会引起JVM内存泄漏问题。适用于数据量比较大，生命周期比较长的情况下，而普通的allocate()方法适用并发连接少于1000。 4. FileChannel的数据访问1. FileChannel.transferXXX传统的数据访问方式：FileChannel.transferXXX方式： 2. FileChannel.map将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，省去了数据从内核空间向用户空间复制的损耗。适用于对大文件的只读性操作，如大文件的MD5校验。 7. IO调优1. 磁盘I/O优化1. 性能检测在Linux下的iostat命令，查看I/O wait指标是否正常，即CPU等待I/O指标，如果是4核CPU，那么I、O wait参数不应该超过25%。 2. 提升I/O性能]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入分析Java_Web技术</category>
      </categories>
  </entry>
</search>